{"version":3,"file":".rspeedy/main/main-thread.js","sources":["file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/performance.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/root.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/event/jsReady.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/renderToOpcodes/index.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/worklet-runtime/lib/bindings/events.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/patch/snapshotPatch.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycleConstant.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/opcodes.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/gesture/types.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/dist/preact.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/hooks/dist/hooks.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/compat/dist/compat.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot/ref.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot/workletRef.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/worklet-runtime/lib/bindings/bindings.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/utils.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/hydrate.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/list.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/patch/snapshotPatchApply.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/pass.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/patch/updateMainThread.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/renderToOpcodes/constants.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/render.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/workletRefPool.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/destroy.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot/event.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/calledByNative.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/reload.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/env.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/internal.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lepus/jsx-runtime/index.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/src/App.tsx","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/src/index.tsx","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx-api.js"],"sourcesContent":["// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\nimport { DIFF } from '../renderToOpcodes/constants.js';\nimport { __globalSnapshotPatch } from '../lifecycle/patch/snapshotPatch.js';\nvar PerformanceTimingKeys;\n(function (PerformanceTimingKeys) {\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_set_state_trigger\"] = 0] = \"update_set_state_trigger\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_diff_vdom_start\"] = 1] = \"update_diff_vdom_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_diff_vdom_end\"] = 2] = \"update_diff_vdom_end\";\n    // update_set_state_trigger, update_diff_vdom_start and update_diff_vdom_end is deprecated\n    PerformanceTimingKeys[PerformanceTimingKeys[\"diff_vdom_start\"] = 3] = \"diff_vdom_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"diff_vdom_end\"] = 4] = \"diff_vdom_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"pack_changes_start\"] = 5] = \"pack_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"pack_changes_end\"] = 6] = \"pack_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"parse_changes_start\"] = 7] = \"parse_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"parse_changes_end\"] = 8] = \"parse_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"patch_changes_start\"] = 9] = \"patch_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"patch_changes_end\"] = 10] = \"patch_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"hydrate_parse_snapshot_start\"] = 11] = \"hydrate_parse_snapshot_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"hydrate_parse_snapshot_end\"] = 12] = \"hydrate_parse_snapshot_end\";\n})(PerformanceTimingKeys || (PerformanceTimingKeys = {}));\n/**\n * @deprecated used by old timing api(setState timing flag)\n */\nconst PerfSpecificKey = '__lynx_timing_flag';\nlet timingFlag;\nlet shouldMarkDiffVdomStart = false;\nlet shouldMarkDiffVdomEnd = false;\nlet globalPipelineOptions;\n/**\n * @deprecated used by old timing api(setState timing flag)\n */\nfunction markTimingLegacy(key, timingFlag_) {\n    switch (key) {\n        case PerformanceTimingKeys.update_set_state_trigger: {\n            shouldMarkDiffVdomStart = true;\n            shouldMarkDiffVdomEnd = true;\n            timingFlag = timingFlag_;\n            break;\n        }\n        case PerformanceTimingKeys.update_diff_vdom_start: {\n            /* v8 ignore start */\n            if (!shouldMarkDiffVdomStart) {\n                return;\n            }\n            /* v8 ignore stop */\n            shouldMarkDiffVdomStart = false;\n            break;\n        }\n        case PerformanceTimingKeys.update_diff_vdom_end: {\n            if (!shouldMarkDiffVdomEnd) {\n                return;\n            }\n            shouldMarkDiffVdomEnd = false;\n            break;\n        }\n    }\n    lynx.getNativeApp().markTiming?.(timingFlag, PerformanceTimingKeys[key]);\n}\nfunction beginPipeline(needTimestamps, timingFlag) {\n    globalPipelineOptions = lynx.performance?._generatePipelineOptions?.();\n    if (globalPipelineOptions) {\n        globalPipelineOptions.needTimestamps = needTimestamps;\n        lynx.performance?._onPipelineStart?.(globalPipelineOptions.pipelineID);\n        if (timingFlag) {\n            lynx.performance?._bindPipelineIdWithTimingFlag?.(globalPipelineOptions.pipelineID, timingFlag);\n        }\n    }\n}\nfunction setPipeline(pipeline) {\n    globalPipelineOptions = pipeline;\n}\nfunction markTiming(timestampKey, force) {\n    if (globalPipelineOptions && (force || globalPipelineOptions.needTimestamps)) {\n        lynx.performance?._markTiming?.(globalPipelineOptions.pipelineID, PerformanceTimingKeys[timestampKey]);\n    }\n}\nfunction initTimingAPI() {\n    const oldDiff = options[DIFF];\n    options[DIFF] = (vnode) => {\n        // check `__globalSnapshotPatch` to make sure this only runs after hydrate\n        if (__JS__ && __globalSnapshotPatch) {\n            if (!globalPipelineOptions) {\n                beginPipeline(false);\n                markTiming(PerformanceTimingKeys.diff_vdom_start, true);\n            }\n            if (shouldMarkDiffVdomStart) {\n                markTimingLegacy(PerformanceTimingKeys.update_diff_vdom_start);\n            }\n        }\n        oldDiff?.(vnode);\n    };\n}\n/**\n * @internal\n */\nexport { PerformanceTimingKeys, PerfSpecificKey, markTimingLegacy, initTimingAPI, beginPipeline, markTiming, setPipeline, globalPipelineOptions, };\n//# sourceMappingURL=performance.js.map","import { ListUpdateInfoRecording, __pendingListUpdates, snapshotDestroyList } from './list.js';\nimport { unref } from './snapshot/ref.js';\nimport { SnapshotOperation, __globalSnapshotPatch } from './lifecycle/patch/snapshotPatch.js';\nimport { isDirectOrDeepEqual } from './utils.js';\nexport var DynamicPartType;\n(function (DynamicPartType) {\n    DynamicPartType[DynamicPartType[\"Attr\"] = 0] = \"Attr\";\n    DynamicPartType[DynamicPartType[\"Spread\"] = 1] = \"Spread\";\n    DynamicPartType[DynamicPartType[\"Slot\"] = 2] = \"Slot\";\n    // Component,\n    DynamicPartType[DynamicPartType[\"Children\"] = 3] = \"Children\";\n    DynamicPartType[DynamicPartType[\"ListChildren\"] = 4] = \"ListChildren\";\n    // Used by compat layer\n    DynamicPartType[DynamicPartType[\"MultiChildren\"] = 5] = \"MultiChildren\";\n})(DynamicPartType || (DynamicPartType = {}));\nexport let __page;\nexport let __pageId = 0;\nexport function setupPage(page) {\n    __page = page;\n    __pageId = __GetElementUniqueID(page);\n}\nexport const snapshotManager = {\n    values: /* @__PURE__ */ new Map([\n        [\n            'root',\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__page];\n                },\n                update: [],\n                slot: [[DynamicPartType.Children, 0]],\n                isListHolder: false,\n                cssId: 0,\n            },\n        ],\n        [\n            'wrapper',\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__CreateWrapperElement(__pageId)];\n                },\n                update: [],\n                slot: [[DynamicPartType.Children, 0]],\n                isListHolder: false,\n            },\n        ],\n        [\n            null,\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__CreateElement('raw-text', __pageId)];\n                },\n                update: [\n                    ctx => {\n                        /* v8 ignore start */\n                        if (__JS__ && !__DEV__) {\n                            return;\n                        }\n                        /* v8 ignore stop */\n                        if (ctx.__elements) {\n                            __SetAttribute(ctx.__elements[0], 'text', ctx.__values[0]);\n                        }\n                    },\n                ],\n                slot: [],\n                isListHolder: false,\n            },\n        ],\n    ]),\n};\nexport const snapshotInstanceManager = {\n    nextId: 0,\n    values: /* @__PURE__ */ new Map(),\n    clear() {\n        // not resetting `nextId` to prevent id collision\n        this.values.clear();\n    },\n};\nexport const backgroundSnapshotInstanceManager = {\n    nextId: 0,\n    values: /* @__PURE__ */ new Map(),\n    clear() {\n        // not resetting `nextId` to prevent id collision\n        this.values.clear();\n    },\n    updateId(id, newId) {\n        const values = this.values;\n        const si = values.get(id);\n        values.delete(id);\n        values.set(newId, si);\n        si.__id = newId;\n    },\n    getValueBySign(str) {\n        const res = str?.split(':');\n        if (!res || (res.length != 2 && res.length != 3)) {\n            throw new Error('Invalid ctx format: ' + str);\n        }\n        let id = Number(res[0]);\n        const expIndex = Number(res[1]);\n        const ctx = this.values.get(id);\n        if (!ctx) {\n            return null;\n        }\n        const spreadKey = res[2];\n        if (spreadKey) {\n            return ctx.__values[expIndex][spreadKey];\n        }\n        else {\n            return ctx.__values[expIndex];\n        }\n    },\n};\nexport function createSnapshot(uniqID, create, update, slot, cssId, entryName) {\n    if (__DEV__ && __JS__\n        // `__globalSnapshotPatch` does not exist before hydration,\n        // so the snapshot of the first screen will not be sent to the main thread.\n        && __globalSnapshotPatch\n        && !snapshotManager.values.has(uniqID)\n        // `create` may be `null` when loading a lazy bundle after hydration.\n        && create !== null) {\n        // We only update the lepus snapshot if the `uniqID` is different.\n        // This means that `uniqID` is considered the \"hash\" of the snapshot.\n        // When HMR (Hot Module Replacement) or fast refresh updates occur, `createSnapshot` will be re-executed with the new snapshot definition.\n        __globalSnapshotPatch.push(SnapshotOperation.DEV_ONLY_AddSnapshot, uniqID, \n        // We use `Function.prototype.toString` to serialize the `create` and `update` functions for Lepus.\n        // This allows the updates to be applied to Lepus.\n        // As a result, both the static part (`create`) and the dynamic parts (`update` and `slot`) can be updated.\n        create.toString(), update?.map(f => f.toString()) ?? [], slot, cssId, entryName);\n    }\n    if (entryName) {\n        uniqID = `${entryName}:${uniqID}`;\n    }\n    const s = { create, update, slot, cssId, entryName };\n    snapshotManager.values.set(uniqID, s);\n    if (slot && slot[0] && slot[0][0] === DynamicPartType.ListChildren) {\n        s.isListHolder = true;\n    }\n    return uniqID;\n}\nexport function traverseSnapshotInstance(si, callback) {\n    const c = si.childNodes;\n    callback(si);\n    for (const vv of c) {\n        traverseSnapshotInstance(vv, callback);\n    }\n}\nconst DEFAULT_ENTRY_NAME = '__Card__';\nconst DEFAULT_CSS_ID = 0;\nexport class SnapshotInstance {\n    type;\n    __id;\n    __snapshot_def;\n    __elements;\n    __element_root;\n    __values;\n    __current_slot_index = 0;\n    __ref_set;\n    __worklet_ref_set;\n    __listItemPlatformInfo;\n    constructor(type, id) {\n        this.type = type;\n        this.__snapshot_def = snapshotManager.values.get(type);\n        id ||= snapshotInstanceManager.nextId -= 1;\n        this.__id = id;\n        snapshotInstanceManager.values.set(id, this);\n    }\n    ensureElements() {\n        const { create, slot, isListHolder, cssId, entryName } = this.__snapshot_def;\n        const elements = create(this);\n        this.__elements = elements;\n        this.__element_root = elements[0];\n        if (cssId === undefined) {\n            // This means either:\n            //   CSS Scope is removed(We only need to call `__SetCSSId` when there is `entryName`)\n            //   Or an old bundle(`__SetCSSId` is called in `create`), we skip calling `__SetCSSId`\n            if (entryName !== DEFAULT_ENTRY_NAME && entryName !== undefined) {\n                __SetCSSId(this.__elements, DEFAULT_CSS_ID, entryName);\n            }\n        }\n        else {\n            // cssId !== undefined\n            if (entryName !== DEFAULT_ENTRY_NAME && entryName !== undefined) {\n                // For lazy bundle, we need add `entryName` to the third params\n                __SetCSSId(this.__elements, cssId, entryName);\n            }\n            else {\n                __SetCSSId(this.__elements, cssId);\n            }\n        }\n        const values = this.__values;\n        if (values) {\n            this.__values = undefined;\n            this.setAttribute('values', values);\n        }\n        if (isListHolder) {\n            // never recurse into list's children\n        }\n        else {\n            let index = 0;\n            let child = this.__firstChild;\n            while (child) {\n                child.ensureElements();\n                const [type, elementIndex] = slot[index];\n                switch (type) {\n                    case DynamicPartType.Slot: {\n                        __ReplaceElement(child.__element_root, elements[elementIndex]);\n                        elements[elementIndex] = child.__element_root;\n                        index++;\n                        break;\n                    }\n                    /* v8 ignore start */\n                    case DynamicPartType.MultiChildren: {\n                        if (__GetTag(elements[elementIndex]) === 'wrapper') {\n                            __ReplaceElement(child.__element_root, elements[elementIndex]);\n                        }\n                        else {\n                            __AppendElement(elements[elementIndex], child.__element_root);\n                        }\n                        index++;\n                        break;\n                    }\n                    /* v8 ignore end */\n                    case DynamicPartType.Children:\n                    case DynamicPartType.ListChildren: {\n                        __AppendElement(elements[elementIndex], child.__element_root);\n                        break;\n                    }\n                }\n                child = child.__nextSibling;\n            }\n        }\n    }\n    unRenderElements() {\n        const { isListHolder } = this.__snapshot_def;\n        this.__elements = undefined;\n        this.__element_root = undefined;\n        if (isListHolder) {\n            // never recurse into list's children\n        }\n        else {\n            let child = this.__firstChild;\n            while (child) {\n                child.unRenderElements();\n                child = child.__nextSibling;\n            }\n        }\n    }\n    takeElements() {\n        const a = Object.create(SnapshotInstance.prototype);\n        a.__id = this.__id;\n        a.__snapshot_def = this.__snapshot_def;\n        a.__values = this.__values;\n        // all clear\n        a.__parent = null;\n        a.__firstChild = null;\n        a.__lastChild = null;\n        a.__nextSibling = null;\n        a.__previousSibling = null;\n        this.childNodes.map(c => c.takeElements()).forEach(node => a.__insertBefore(node));\n        a.__elements = this.__elements;\n        a.__element_root = this.__element_root;\n        this.__elements = undefined;\n        this.__element_root = undefined;\n        return a;\n    }\n    // onCreate?: () => void;\n    // onAttach?: () => void;\n    // onDetach?: () => void;\n    // onRef?: () => void;\n    // onUnref?: () => void;\n    __parent = null;\n    __firstChild = null;\n    __lastChild = null;\n    __previousSibling = null;\n    __nextSibling = null;\n    get parentNode() {\n        return this.__parent;\n    }\n    get nextSibling() {\n        return this.__nextSibling;\n    }\n    // get isConnected() {\n    //   return !!this.__parent;\n    // }\n    contains(child) {\n        return child.parentNode === this;\n    }\n    get childNodes() {\n        const nodes = [];\n        let node = this.__firstChild;\n        while (node) {\n            nodes.push(node);\n            node = node.__nextSibling;\n        }\n        return nodes;\n    }\n    __insertBefore(node, beforeNode) {\n        // If the node already has a parent, remove it from its current parent\n        if (node.__parent) {\n            node.__parent.__removeChild(node);\n        }\n        // If beforeNode is not provided, add the new node as the last child\n        if (beforeNode) {\n            // If beforeNode is provided, insert the new node before beforeNode\n            if (beforeNode.__previousSibling) {\n                beforeNode.__previousSibling.__nextSibling = node;\n                node.__previousSibling = beforeNode.__previousSibling;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            beforeNode.__previousSibling = node;\n            node.__nextSibling = beforeNode;\n            node.__parent = this;\n        }\n        else {\n            if (this.__lastChild) {\n                this.__lastChild.__nextSibling = node;\n                node.__previousSibling = this.__lastChild;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            this.__lastChild = node;\n            node.__parent = this;\n            node.__nextSibling = null;\n        }\n    }\n    __removeChild(node) {\n        if (node.__parent !== this) {\n            throw new Error('The node to be removed is not a child of this node.');\n        }\n        if (node.__previousSibling) {\n            node.__previousSibling.__nextSibling = node.__nextSibling;\n        }\n        else {\n            this.__firstChild = node.__nextSibling;\n        }\n        if (node.__nextSibling) {\n            node.__nextSibling.__previousSibling = node.__previousSibling;\n        }\n        else {\n            this.__lastChild = node.__previousSibling;\n        }\n        node.__parent = null;\n        node.__previousSibling = null;\n        node.__nextSibling = null;\n    }\n    insertBefore(newNode, existingNode) {\n        const __snapshot_def = this.__snapshot_def;\n        if (__snapshot_def.isListHolder) {\n            (__pendingListUpdates.values[this.__id] ??= new ListUpdateInfoRecording(this)).onInsertBefore(newNode, existingNode);\n            this.__insertBefore(newNode, existingNode);\n            return;\n        }\n        const shouldRemove = newNode.__parent === this;\n        this.__insertBefore(newNode, existingNode);\n        const __elements = this.__elements;\n        if (__elements) {\n            if (!newNode.__elements) {\n                newNode.ensureElements();\n            }\n        }\n        else {\n            return;\n        }\n        const count = __snapshot_def.slot.length;\n        if (count === 1) {\n            const [, elementIndex] = __snapshot_def.slot[0];\n            const parent = __elements[elementIndex];\n            if (shouldRemove) {\n                __RemoveElement(parent, newNode.__element_root);\n            }\n            if (existingNode) {\n                __InsertElementBefore(parent, newNode.__element_root, existingNode.__element_root);\n            }\n            else {\n                __AppendElement(parent, newNode.__element_root);\n            }\n        }\n        else if (count > 1) {\n            const index = this.__current_slot_index++;\n            const [s, elementIndex] = __snapshot_def.slot[index];\n            if (s === DynamicPartType.Slot) {\n                __ReplaceElement(newNode.__element_root, __elements[elementIndex]);\n                __elements[elementIndex] = newNode.__element_root;\n                /* v8 ignore start */\n            }\n            else if (s === DynamicPartType.MultiChildren) {\n                if (__GetTag(__elements[elementIndex]) === 'wrapper') {\n                    __ReplaceElement(newNode.__element_root, __elements[elementIndex]);\n                }\n                else {\n                    __AppendElement(__elements[elementIndex], newNode.__element_root);\n                }\n            }\n            /* v8 ignore end */\n        }\n    }\n    removeChild(child) {\n        const r = () => {\n            this.__removeChild(child);\n            traverseSnapshotInstance(child, v => {\n                v.__parent = null;\n                snapshotInstanceManager.values.delete(v.__id);\n            });\n        };\n        const __snapshot_def = this.__snapshot_def;\n        if (__snapshot_def.isListHolder) {\n            (__pendingListUpdates.values[this.__id] ??= new ListUpdateInfoRecording(this)).onRemoveChild(child);\n            r();\n            return;\n        }\n        // TODO: ref: can this be done on the background thread?\n        unref(child, true);\n        r();\n        if (this.__elements) {\n            const [, elementIndex] = __snapshot_def.slot[0];\n            __RemoveElement(this.__elements[elementIndex], child.__element_root);\n        }\n        if (child.__snapshot_def.isListHolder) {\n            snapshotDestroyList(child);\n        }\n    }\n    setAttribute(key, value) {\n        const helper = (index, oldValue, newValue) => {\n            if (isDirectOrDeepEqual(oldValue, newValue)) { }\n            else {\n                this.__snapshot_def.update[index](this, index, oldValue);\n            }\n        };\n        if (key === 'values') {\n            const oldValues = this.__values;\n            this.__values = value;\n            if (oldValues) {\n                for (let index = 0; index < value.length; index++) {\n                    helper(index, oldValues[index], value[index]);\n                }\n            }\n            else {\n                for (let index = 0; index < value.length; index++) {\n                    helper(index, undefined, value[index]);\n                }\n            }\n            return;\n        }\n        const index = typeof key === 'string' ? Number(key.slice(2)) : key;\n        this.__values ??= [];\n        helper(index, this.__values[index], this.__values[index] = value);\n    }\n    toJSON() {\n        return {\n            id: this.__id,\n            type: this.type,\n            values: this.__values,\n            children: this.__firstChild ? this.childNodes : undefined,\n        };\n    }\n}\n//# sourceMappingURL=snapshot.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { BackgroundSnapshotInstance } from './backgroundSnapshot.js';\nimport { SnapshotInstance } from './snapshot.js';\nlet __root;\nfunction setRoot(root) {\n    __root = root;\n}\nif (__LEPUS__) {\n    setRoot(new SnapshotInstance('root'));\n}\nelse if (__JS__) {\n    setRoot(new BackgroundSnapshotInstance('root'));\n}\nexport { __root, setRoot };\n//# sourceMappingURL=root.js.map","import { LifecycleConstant } from '../../lifecycleConstant.js';\nimport { __root } from '../../root.js';\nimport { takeGlobalRefPatchMap } from '../../snapshot/ref.js';\nlet isJSReady;\nlet jsReadyEventIdSwap;\nfunction jsReady() {\n    isJSReady = true;\n    __OnLifecycleEvent([\n        LifecycleConstant.firstScreen, /* FIRST_SCREEN */\n        {\n            root: JSON.stringify(__root),\n            refPatch: JSON.stringify(takeGlobalRefPatchMap()),\n            jsReadyEventIdSwap,\n        },\n    ]);\n    jsReadyEventIdSwap = {};\n}\nfunction clearJSReadyEventIdSwap() {\n    jsReadyEventIdSwap = {};\n}\nfunction resetJSReady() {\n    isJSReady = false;\n    jsReadyEventIdSwap = {};\n}\n/**\n * @internal\n */\nexport { jsReady, isJSReady, jsReadyEventIdSwap, clearJSReadyEventIdSwap, resetJSReady };\n//# sourceMappingURL=jsReady.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\n// modified from preact-render-to-string@6.0.3\n// @ts-nocheck\nimport { Fragment, h, options } from 'preact';\nimport { CHILDREN, COMMIT, COMPONENT, DIFF, DIFFED, DIRTY, NEXT_STATE, PARENT, RENDER, SKIP_EFFECTS, VNODE, } from './constants.js';\n/** @typedef {import('preact').VNode} VNode */\nconst EMPTY_ARR = [];\nconst isArray = /* @__PURE__ */ Array.isArray;\nconst assign = /* @__PURE__ */ Object.assign;\n// Global state for the current render pass\nlet beforeDiff, afterDiff, renderHook, ummountHook;\n/**\n * Render Preact JSX + Components to an HTML string.\n * @param {VNode} vnode\tJSX Element / VNode to render\n * @param {object} [context] Initial root context object\n */\nexport function renderToString(vnode, context) {\n    // Performance optimization: `renderToString` is synchronous and we\n    // therefore don't execute any effects. To do that we pass an empty\n    // array to `options._commit` (`__c`). But we can go one step further\n    // and avoid a lot of dirty checks and allocations by setting\n    // `options._skipEffects` (`__s`) too.\n    const previousSkipEffects = options[SKIP_EFFECTS];\n    options[SKIP_EFFECTS] = true;\n    // store options hooks once before each synchronous render call\n    beforeDiff = options[DIFF];\n    afterDiff = options[DIFFED];\n    renderHook = options[RENDER];\n    ummountHook = options.unmount;\n    const parent = h(Fragment, null);\n    parent[CHILDREN] = [vnode];\n    const opcodes = [];\n    try {\n        _renderToString(vnode, context || EMPTY_OBJ, false, undefined, parent, opcodes);\n    }\n    finally {\n        // options._commit, we don't schedule any effects in this library right now,\n        // so we can pass an empty queue to this hook.\n        if (options[COMMIT])\n            options[COMMIT](vnode, EMPTY_ARR);\n        options[SKIP_EFFECTS] = previousSkipEffects;\n        EMPTY_ARR.length = 0;\n    }\n    return opcodes;\n}\n// Installed as setState/forceUpdate for function components\nfunction markAsDirty() {\n    this.__d = true;\n}\nconst EMPTY_OBJ = {};\nexport const __OpBegin = 0;\nexport const __OpEnd = 1;\nexport const __OpAttr = 2;\nexport const __OpText = 3;\n/**\n * @param {VNode} vnode\n * @param {Record<string, unknown>} context\n */\nfunction renderClassComponent(vnode, context) {\n    let type = /** @type {import(\"preact\").ComponentClass<typeof vnode.props>} */ (vnode.type);\n    let c = new type(vnode.props, context);\n    vnode[COMPONENT] = c;\n    c[VNODE] = vnode;\n    c.props = vnode.props;\n    c.context = context;\n    // turn off stateful re-rendering:\n    c[DIRTY] = true;\n    if (c.state == null)\n        c.state = EMPTY_OBJ;\n    if (c[NEXT_STATE] == null) {\n        c[NEXT_STATE] = c.state;\n    }\n    if (type.getDerivedStateFromProps) {\n        c.state = assign({}, c.state, type.getDerivedStateFromProps(c.props, c.state));\n    }\n    if (renderHook)\n        renderHook(vnode);\n    return c.render(c.props, c.state, context);\n}\n/**\n * Recursively render VNodes to HTML.\n * @param {VNode|any} vnode\n * @param {any} context\n * @param {boolean} isSvgMode\n * @param {any} selectValue\n * @param {VNode} parent\n * @param opcodes\n */\nfunction _renderToString(vnode, context, isSvgMode, selectValue, parent, opcodes) {\n    // Ignore non-rendered VNodes/values\n    if (vnode == null || vnode === true || vnode === false || vnode === '') {\n        return;\n    }\n    // Text VNodes: escape as HTML\n    if (typeof vnode !== 'object') {\n        if (typeof vnode === 'function')\n            return;\n        opcodes.push(__OpText, vnode + '');\n        return;\n    }\n    // Recurse into children / Arrays\n    if (isArray(vnode)) {\n        parent[CHILDREN] = vnode;\n        for (let i = 0; i < vnode.length; i++) {\n            let child = vnode[i];\n            if (child == null || typeof child === 'boolean')\n                continue;\n            _renderToString(child, context, isSvgMode, selectValue, parent, opcodes);\n        }\n        return;\n    }\n    // VNodes have {constructor:undefined} to prevent JSON injection:\n    // if (vnode.constructor !== undefined) return;\n    vnode[PARENT] = parent;\n    if (beforeDiff)\n        beforeDiff(vnode);\n    let type = vnode.type, props = vnode.props, cctx = context, contextType, rendered, component;\n    // Invoke rendering on Components\n    if (typeof type === 'function') {\n        if (type === Fragment) {\n            rendered = props.children;\n        }\n        else {\n            contextType = type.contextType;\n            if (contextType != null) {\n                let provider = context[contextType.__c];\n                cctx = provider ? provider.props.value : contextType.__;\n            }\n            if (type.prototype && typeof type.prototype.render === 'function') {\n                rendered = /**#__NOINLINE__**/ renderClassComponent(vnode, cctx);\n                component = vnode[COMPONENT];\n            }\n            else {\n                component = {\n                    __v: vnode,\n                    props,\n                    context: cctx,\n                    // silently drop state updates\n                    setState: markAsDirty,\n                    forceUpdate: markAsDirty,\n                    __d: true,\n                    // hooks\n                    __h: [],\n                };\n                vnode[COMPONENT] = component;\n                component.constructor = type;\n                component.render = doRender;\n                // If a hook invokes setState() to invalidate the component during rendering,\n                // re-render it up to 25 times to allow \"settling\" of memoized states.\n                // Note:\n                //   This will need to be updated for Preact 11 to use internal.flags rather than component._dirty:\n                //   https://github.com/preactjs/preact/blob/d4ca6fdb19bc715e49fd144e69f7296b2f4daa40/src/diff/component.js#L35-L44\n                let count = 0;\n                while (component[DIRTY] && count++ < 25) {\n                    component[DIRTY] = false;\n                    if (renderHook)\n                        renderHook(vnode);\n                    rendered = component.render(props, component.state, cctx);\n                }\n                component[DIRTY] = true;\n            }\n            if (component.getChildContext != null) {\n                context = assign({}, context, component.getChildContext());\n            }\n        }\n        // When a component returns a Fragment node we flatten it in core, so we\n        // need to mirror that logic here too\n        let isTopLevelFragment = rendered != null && rendered.type === Fragment\n            && rendered.key == null;\n        rendered = isTopLevelFragment ? rendered.props.children : rendered;\n        // Recurse into children before invoking the after-diff hook\n        _renderToString(rendered, context, isSvgMode, selectValue, vnode, opcodes);\n        if (afterDiff)\n            afterDiff(vnode);\n        vnode[PARENT] = undefined;\n        if (ummountHook)\n            ummountHook(vnode);\n        return;\n    }\n    let children;\n    opcodes.push(__OpBegin, vnode);\n    for (let name in props) {\n        let v = props[name];\n        switch (name) {\n            case 'children':\n                children = v;\n                continue;\n            // VDOM-specific props\n            /* c8 ignore next 5 */\n            case 'key':\n            case 'ref':\n            case '__self':\n            case '__source':\n                continue;\n            default: { }\n        }\n        // write this attribute to the buffer\n        if (v != null && v !== false && typeof v !== 'function') {\n            opcodes.push(__OpAttr, name, v);\n        }\n    }\n    if (typeof children === 'string') {\n        // single text child\n        opcodes.push(__OpText, children);\n    }\n    else if (children != null && children !== false && children !== true) {\n        // recurse into this element VNode's children\n        _renderToString(children, context, false, selectValue, vnode, opcodes);\n    }\n    if (afterDiff)\n        afterDiff(vnode);\n    vnode[PARENT] = undefined;\n    if (ummountHook)\n        ummountHook(vnode);\n    opcodes.push(__OpEnd);\n    return;\n}\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n    return this.constructor(props, context);\n}\nexport default renderToString;\nexport const render = renderToString;\nexport const renderToStaticMarkup = renderToString;\n//# sourceMappingURL=index.js.map","var WorkletEvents;\n(function (WorkletEvents) {\n    WorkletEvents[\"runWorkletCtx\"] = \"Lynx.Worklet.runWorkletCtx\";\n    WorkletEvents[\"runOnBackground\"] = \"Lynx.Worklet.runOnBackground\";\n    WorkletEvents[\"FunctionCallRet\"] = \"Lynx.Worklet.FunctionCallRet\";\n    WorkletEvents[\"releaseBackgroundWorkletCtx\"] = \"Lynx.Worklet.releaseBackgroundWorkletCtx\";\n    WorkletEvents[\"releaseWorkletRef\"] = \"Lynx.Worklet.releaseWorkletRef\";\n})(WorkletEvents || (WorkletEvents = {}));\nexport { WorkletEvents };\n//# sourceMappingURL=events.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport var SnapshotOperation;\n(function (SnapshotOperation) {\n    SnapshotOperation[SnapshotOperation[\"CreateElement\"] = 0] = \"CreateElement\";\n    SnapshotOperation[SnapshotOperation[\"InsertBefore\"] = 1] = \"InsertBefore\";\n    SnapshotOperation[SnapshotOperation[\"RemoveChild\"] = 2] = \"RemoveChild\";\n    SnapshotOperation[SnapshotOperation[\"SetAttribute\"] = 3] = \"SetAttribute\";\n    SnapshotOperation[SnapshotOperation[\"SetAttributes\"] = 4] = \"SetAttributes\";\n    SnapshotOperation[SnapshotOperation[\"DEV_ONLY_AddSnapshot\"] = 100] = \"DEV_ONLY_AddSnapshot\";\n    SnapshotOperation[SnapshotOperation[\"DEV_ONLY_RegisterWorklet\"] = 101] = \"DEV_ONLY_RegisterWorklet\";\n})(SnapshotOperation || (SnapshotOperation = {}));\nexport let __globalSnapshotPatch;\nexport function takeGlobalSnapshotPatch() {\n    if (__globalSnapshotPatch) {\n        const list = __globalSnapshotPatch;\n        __globalSnapshotPatch = [];\n        return list;\n    }\n    else {\n        return undefined;\n    }\n}\nexport function initGlobalSnapshotPatch() {\n    __globalSnapshotPatch = [];\n}\nexport function deinitGlobalSnapshotPatch() {\n    __globalSnapshotPatch = undefined;\n}\n//# sourceMappingURL=snapshotPatch.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport class LifecycleConstant {\n    static firstScreen = 'rLynxFirstScreen';\n    static updateFromRoot = 'updateFromRoot';\n    static globalEventFromLepus = 'globalEventFromLepus';\n    static ref = 'rLynxRef';\n    static jsReady = 'rLynxJSReady';\n    static patchUpdate = 'rLynxChange';\n}\nexport var NativeUpdateDataType;\n(function (NativeUpdateDataType) {\n    NativeUpdateDataType[NativeUpdateDataType[\"UPDATE\"] = 0] = \"UPDATE\";\n    NativeUpdateDataType[NativeUpdateDataType[\"RESET\"] = 1] = \"RESET\";\n})(NativeUpdateDataType || (NativeUpdateDataType = {}));\n//# sourceMappingURL=lifecycleConstant.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { componentAtIndexFactory, enqueueComponentFactory, gRecycleMap, gSignMap } from './list.js';\nimport { CHILDREN } from './renderToOpcodes/constants.js';\nimport { SnapshotInstance } from './snapshot.js';\nvar Opcode;\n(function (Opcode) {\n    Opcode[Opcode[\"Begin\"] = 0] = \"Begin\";\n    Opcode[Opcode[\"End\"] = 1] = \"End\";\n    Opcode[Opcode[\"Attr\"] = 2] = \"Attr\";\n    Opcode[Opcode[\"Text\"] = 3] = \"Text\";\n})(Opcode || (Opcode = {}));\nexport function ssrHydrateByOpcodes(opcodes, into, refMap) {\n    let top = into;\n    const stack = [into];\n    for (let i = 0; i < opcodes.length;) {\n        const opcode = opcodes[i];\n        switch (opcode) {\n            case Opcode.Begin: {\n                const p = top;\n                const [type, __id, elements] = opcodes[i + 1];\n                top = new SnapshotInstance(type, __id);\n                top.__pendingElements = elements;\n                p.insertBefore(top);\n                stack.push(top);\n                i += 2;\n                break;\n            }\n            case Opcode.End: {\n                // @ts-ignore\n                top[CHILDREN] = undefined;\n                top.__elements = top.__pendingElements.map(({ ssrID }) => refMap[ssrID]);\n                top.__element_root = top.__elements[0];\n                delete top.__pendingElements;\n                if (top.__snapshot_def.isListHolder) {\n                    const listElement = top.__element_root;\n                    const listElementUniqueID = __GetElementUniqueID(listElement);\n                    const signMap = gSignMap[listElementUniqueID] = new Map();\n                    gRecycleMap[listElementUniqueID] = new Map();\n                    const enqueueFunc = enqueueComponentFactory();\n                    const componentAtIndex = componentAtIndexFactory(top.childNodes);\n                    for (const child of top.childNodes) {\n                        if (child.__element_root) {\n                            const childElementUniqueID = __GetElementUniqueID(child.__element_root);\n                            signMap.set(childElementUniqueID, child);\n                            enqueueFunc(listElement, listElementUniqueID, childElementUniqueID);\n                        }\n                    }\n                    __UpdateListCallbacks(listElement, componentAtIndex, enqueueFunc);\n                }\n                stack.pop();\n                const p = stack[stack.length - 1];\n                top = p;\n                i += 1;\n                break;\n            }\n            case Opcode.Attr: {\n                const key = opcodes[i + 1];\n                const value = opcodes[i + 2];\n                top.setAttribute(key, value);\n                i += 3;\n                break;\n            }\n            case Opcode.Text: {\n                const [[type, __id, elements], text] = opcodes[i + 1];\n                const s = new SnapshotInstance(type, __id);\n                s.setAttribute(0, text);\n                top.insertBefore(s);\n                s.__elements = elements.map(({ ssrID }) => refMap[ssrID]);\n                s.__element_root = s.__elements[0];\n                i += 2;\n                break;\n            }\n        }\n    }\n}\nexport function renderOpcodesInto(opcodes, into) {\n    let top = into;\n    const stack = [into];\n    for (let i = 0; i < opcodes.length;) {\n        const opcode = opcodes[i];\n        switch (opcode) {\n            case Opcode.Begin: {\n                const p = top;\n                top = opcodes[i + 1];\n                // @ts-ignore\n                if (top.__parent) {\n                    // already inserted\n                    top = new SnapshotInstance(top.type);\n                    opcodes[i + 1] = top;\n                }\n                p.insertBefore(top);\n                stack.push(top);\n                i += 2;\n                break;\n            }\n            case Opcode.End: {\n                // @ts-ignore\n                top[CHILDREN] = undefined;\n                stack.pop();\n                const p = stack[stack.length - 1];\n                top = p;\n                i += 1;\n                break;\n            }\n            case Opcode.Attr: {\n                const key = opcodes[i + 1];\n                const value = opcodes[i + 2];\n                top.setAttribute(key, value);\n                i += 3;\n                break;\n            }\n            case Opcode.Text: {\n                const text = opcodes[i + 1];\n                const s = new SnapshotInstance(null);\n                if (__ENABLE_SSR__) {\n                    // We need store the just created SnapshotInstance, or it will be lost when we leave the function\n                    opcodes[i + 1] = [s, text];\n                }\n                s.setAttribute(0, text);\n                top.insertBefore(s);\n                i += 2;\n                break;\n            }\n        }\n    }\n}\n//# sourceMappingURL=opcodes.js.map","export var GestureTypeInner;\n(function (GestureTypeInner) {\n    GestureTypeInner[GestureTypeInner[\"COMPOSED\"] = -1] = \"COMPOSED\";\n    GestureTypeInner[GestureTypeInner[\"PAN\"] = 0] = \"PAN\";\n    GestureTypeInner[GestureTypeInner[\"FLING\"] = 1] = \"FLING\";\n    GestureTypeInner[GestureTypeInner[\"DEFAULT\"] = 2] = \"DEFAULT\";\n    GestureTypeInner[GestureTypeInner[\"TAP\"] = 3] = \"TAP\";\n    GestureTypeInner[GestureTypeInner[\"LONGPRESS\"] = 4] = \"LONGPRESS\";\n    GestureTypeInner[GestureTypeInner[\"ROTATION\"] = 5] = \"ROTATION\";\n    GestureTypeInner[GestureTypeInner[\"PINCH\"] = 6] = \"PINCH\";\n    GestureTypeInner[GestureTypeInner[\"NATIVE\"] = 7] = \"NATIVE\";\n})(GestureTypeInner || (GestureTypeInner = {}));\n//# sourceMappingURL=types.js.map","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nvar MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nvar MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nvar INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nvar MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nvar RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\nvar EMPTY_OBJ = /** @type {any} */{};\nvar EMPTY_ARR = [];\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\nvar isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nfunction assign(obj, props) {\n  // @ts-expect-error We change the type of `obj` to be `O & P`\n  for (var i in props) obj[i] = props[i];\n  return /** @type {O & P} */obj;\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nfunction removeNode(node) {\n  if (node && node.parentNode) node.parentNode.removeChild(node);\n}\nvar slice = EMPTY_ARR.slice;\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nfunction _catchError(error, vnode, oldVNode, errorInfo) {\n  /** @type {Component} */\n  var component, /** @type {ComponentType} */\n    ctor, /** @type {boolean} */\n    handled;\n  for (; vnode = vnode.__;) {\n    if ((component = vnode.__c) && !component.__) {\n      try {\n        ctor = component.constructor;\n        if (ctor && ctor.getDerivedStateFromError != null) {\n          component.setState(ctor.getDerivedStateFromError(error));\n          handled = component.__d;\n        }\n        if (component.componentDidCatch != null) {\n          component.componentDidCatch(error, errorInfo || {});\n          handled = component.__d;\n        }\n\n        // This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n        if (handled) {\n          return component.__E = component;\n        }\n      } catch (e) {\n        error = e;\n      }\n    }\n  }\n  throw error;\n}\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nvar options = {\n  __e: _catchError\n};\n\nvar vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nfunction createElement(type, props, children) {\n  var normalizedProps = {},\n    key,\n    ref,\n    i;\n  for (i in props) {\n    if (i == 'key') key = props[i];else if (i == 'ref') ref = props[i];else normalizedProps[i] = props[i];\n  }\n  if (arguments.length > 2) {\n    normalizedProps.children = arguments.length > 3 ? slice.call(arguments, 2) : children;\n  }\n\n  // If a Component VNode, check for and apply defaultProps\n  // Note: type may be undefined in development, must never error here.\n  if (typeof type == 'function' && type.defaultProps != null) {\n    for (i in type.defaultProps) {\n      if (normalizedProps[i] === undefined) {\n        normalizedProps[i] = type.defaultProps[i];\n      }\n    }\n  }\n  return createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nfunction createVNode(type, props, key, ref, original) {\n  // V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n  // Do not inline into createElement and coerceToVNode!\n  /** @type {VNode} */\n  var vnode = {\n    type: type,\n    props: props,\n    key: key,\n    ref: ref,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    // _nextDom must be initialized to undefined b/c it will eventually\n    // be set to dom.nextSibling which can return `null` and it is important\n    // to be able to distinguish between an uninitialized _nextDom and\n    // a _nextDom that has been set to `null`\n    __d: undefined,\n    __c: null,\n    constructor: undefined,\n    __v: original == null ? ++vnodeId : original,\n    __i: -1,\n    __u: 0\n  };\n\n  // Only invoke the vnode hook if this was *not* a direct copy:\n  if (original == null && options.vnode != null) options.vnode(vnode);\n  return vnode;\n}\nfunction createRef() {\n  return {\n    current: null\n  };\n}\nfunction Fragment(props) {\n  return props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nvar isValidElement = function isValidElement(vnode) {\n  return vnode != null && vnode.constructor == undefined;\n};\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nfunction BaseComponent(props, context) {\n  this.props = props;\n  this.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n  // only clone state when copying to nextState the first time.\n  var s;\n  if (this.__s != null && this.__s !== this.state) {\n    s = this.__s;\n  } else {\n    s = this.__s = assign({}, this.state);\n  }\n  if (typeof update == 'function') {\n    // Some libraries like `immer` mark the current state as readonly,\n    // preventing us from mutating it, so we need to clone it. See #2716\n    update = update(assign({}, s), this.props);\n  }\n  if (update) {\n    assign(s, update);\n  }\n\n  // Skip update if updater function returned null\n  if (update == null) return;\n  if (this.__v) {\n    if (callback) {\n      this._sb.push(callback);\n    }\n    enqueueRender(this);\n  }\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n  if (this.__v) {\n    // Set render mode so that we can differentiate where the render request\n    // is coming from. We need this because forceUpdate should never call\n    // shouldComponentUpdate\n    this.__e = true;\n    if (callback) this.__h.push(callback);\n    enqueueRender(this);\n  }\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nfunction getDomSibling(vnode, childIndex) {\n  if (childIndex == null) {\n    // Use childIndex==null as a signal to resume the search from the vnode's sibling\n    return vnode.__ ? getDomSibling(vnode.__, vnode.__i + 1) : null;\n  }\n  var sibling;\n  for (; childIndex < vnode.__k.length; childIndex++) {\n    sibling = vnode.__k[childIndex];\n    if (sibling != null && sibling.__e != null) {\n      // Since updateParentDomPointers keeps _dom pointer correct,\n      // we can rely on _dom to tell us if this subtree contains a\n      // rendered DOM node, and what the first rendered DOM node is\n      return sibling.__e;\n    }\n  }\n\n  // If we get here, we have not found a DOM node in this vnode's children.\n  // We must resume from this vnode's sibling (in it's parent _children array)\n  // Only climb up and search the parent if we aren't searching through a DOM\n  // VNode (meaning we reached the DOM parent of the original vnode that began\n  // the search)\n  return typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n  var oldVNode = component.__v,\n    oldDom = oldVNode.__e,\n    commitQueue = [],\n    refQueue = [];\n  if (component.__P) {\n    var newVNode = assign({}, oldVNode);\n    newVNode.__v = oldVNode.__v + 1;\n    if (options.vnode) options.vnode(newVNode);\n    diff(component.__P, newVNode, oldVNode, component.__n, component.__P.namespaceURI, oldVNode.__u & MODE_HYDRATE ? [oldDom] : null, commitQueue, oldDom == null ? getDomSibling(oldVNode) : oldDom, !!(oldVNode.__u & MODE_HYDRATE), refQueue);\n    newVNode.__v = oldVNode.__v;\n    newVNode.__.__k[newVNode.__i] = newVNode;\n    commitRoot(commitQueue, newVNode, refQueue);\n    if (newVNode.__e != oldDom) {\n      updateParentDomPointers(newVNode);\n    }\n  }\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n  if ((vnode = vnode.__) != null && vnode.__c != null) {\n    vnode.__e = vnode.__c.base = null;\n    for (var i = 0; i < vnode.__k.length; i++) {\n      var child = vnode.__k[i];\n      if (child != null && child.__e != null) {\n        vnode.__e = vnode.__c.base = child.__e;\n        break;\n      }\n    }\n    return updateParentDomPointers(vnode);\n  }\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nvar rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nvar prevDebounce;\nvar defer = typeof Promise == 'function' ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nfunction enqueueRender(c) {\n  if (!c.__d && (c.__d = true) && rerenderQueue.push(c) && !process.__r++ || prevDebounce !== options.debounceRendering) {\n    prevDebounce = options.debounceRendering;\n    (prevDebounce || defer)(process);\n  }\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nvar depthSort = function depthSort(a, b) {\n  return a.__v.__b - b.__v.__b;\n};\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n  var c;\n  rerenderQueue.sort(depthSort);\n  // Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n  // process() calls from getting scheduled while `queue` is still being consumed.\n  while (c = rerenderQueue.shift()) {\n    if (c.__d) {\n      var renderQueueLength = rerenderQueue.length;\n      renderComponent(c);\n      if (rerenderQueue.length > renderQueueLength) {\n        // When i.e. rerendering a provider additional new items can be injected, we want to\n        // keep the order from top to bottom with those new items so we can handle them in a\n        // single pass\n        rerenderQueue.sort(depthSort);\n      }\n    }\n  }\n  process.__r = 0;\n}\nprocess.__r = 0;\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nfunction diffChildren(parentDom, renderResult, newParentVNode, oldParentVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue) {\n  var i, /** @type {VNode} */\n    oldVNode, /** @type {VNode} */\n    childVNode, /** @type {PreactElement} */\n    newDom, /** @type {PreactElement} */\n    firstChildDom;\n\n  // This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n  // as EMPTY_OBJ._children should be `undefined`.\n  /** @type {VNode[]} */\n  var oldChildren = oldParentVNode && oldParentVNode.__k || EMPTY_ARR;\n  var newChildrenLength = renderResult.length;\n  newParentVNode.__d = oldDom;\n  constructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n  oldDom = newParentVNode.__d;\n  for (i = 0; i < newChildrenLength; i++) {\n    childVNode = newParentVNode.__k[i];\n    if (childVNode == null) continue;\n\n    // At this point, constructNewChildrenArray has assigned _index to be the\n    // matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n    if (childVNode.__i === -1) {\n      oldVNode = EMPTY_OBJ;\n    } else {\n      oldVNode = oldChildren[childVNode.__i] || EMPTY_OBJ;\n    }\n\n    // Update childVNode._index to its final index\n    childVNode.__i = i;\n\n    // Morph the old element into the new one, but don't append it to the dom yet\n    diff(parentDom, childVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue);\n\n    // Adjust DOM nodes\n    newDom = childVNode.__e;\n    if (childVNode.ref && oldVNode.ref != childVNode.ref) {\n      if (oldVNode.ref) {\n        applyRef(oldVNode.ref, null, childVNode);\n      }\n      refQueue.push(childVNode.ref, childVNode.__c || newDom, childVNode);\n    }\n    if (firstChildDom == null && newDom != null) {\n      firstChildDom = newDom;\n    }\n    if (childVNode.__u & INSERT_VNODE || oldVNode.__k === childVNode.__k) {\n      oldDom = insert(childVNode, oldDom, parentDom);\n    } else if (typeof childVNode.type == 'function' && childVNode.__d !== undefined) {\n      // Since Fragments or components that return Fragment like VNodes can\n      // contain multiple DOM nodes as the same level, continue the diff from\n      // the sibling of last DOM child of this child VNode\n      oldDom = childVNode.__d;\n    } else if (newDom) {\n      oldDom = newDom.nextSibling;\n    }\n\n    // Eagerly cleanup _nextDom. We don't need to persist the value because it\n    // is only used by `diffChildren` to determine where to resume the diff\n    // after diffing Components and Fragments. Once we store it the nextDOM\n    // local var, we can clean up the property. Also prevents us hanging on to\n    // DOM nodes that may have been unmounted.\n    childVNode.__d = undefined;\n\n    // Unset diffing flags\n    childVNode.__u &= ~(INSERT_VNODE | MATCHED);\n  }\n\n  // TODO: With new child diffing algo, consider alt ways to diff Fragments.\n  // Such as dropping oldDom and moving fragments in place\n  //\n  // Because the newParentVNode is Fragment-like, we need to set it's\n  // _nextDom property to the nextSibling of its last child DOM node.\n  //\n  // `oldDom` contains the correct value here because if the last child\n  // is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n  // If the last child is a DOM VNode, then oldDom will be set to that DOM\n  // node's nextSibling.\n  newParentVNode.__d = oldDom;\n  newParentVNode.__e = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n  /** @type {number} */\n  var i;\n  /** @type {VNode} */\n  var childVNode;\n  /** @type {VNode} */\n  var oldVNode;\n  var newChildrenLength = renderResult.length;\n  var oldChildrenLength = oldChildren.length,\n    remainingOldChildren = oldChildrenLength;\n  var skew = 0;\n  newParentVNode.__k = [];\n  for (i = 0; i < newChildrenLength; i++) {\n    // @ts-expect-error We are reusing the childVNode variable to hold both the\n    // pre and post normalized childVNode\n    childVNode = renderResult[i];\n    if (childVNode == null || typeof childVNode == 'boolean' || typeof childVNode == 'function') {\n      childVNode = newParentVNode.__k[i] = null;\n      continue;\n    }\n    // If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n    // or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n    // it's own DOM & etc. pointers\n    else if (typeof childVNode == 'string' || typeof childVNode == 'number' ||\n    // eslint-disable-next-line valid-typeof\n    typeof childVNode == 'bigint' || childVNode.constructor == String) {\n      childVNode = newParentVNode.__k[i] = createVNode(null, childVNode, null, null, null);\n    } else if (isArray(childVNode)) {\n      childVNode = newParentVNode.__k[i] = createVNode(Fragment, {\n        children: childVNode\n      }, null, null, null);\n    } else if (childVNode.constructor === undefined && childVNode.__b > 0) {\n      // VNode is already in use, clone it. This can happen in the following\n      // scenario:\n      //   const reuse = <div />\n      //   <div>{reuse}<span />{reuse}</div>\n      childVNode = newParentVNode.__k[i] = createVNode(childVNode.type, childVNode.props, childVNode.key, childVNode.ref ? childVNode.ref : null, childVNode.__v);\n    } else {\n      childVNode = newParentVNode.__k[i] = childVNode;\n    }\n    var skewedIndex = i + skew;\n    childVNode.__ = newParentVNode;\n    childVNode.__b = newParentVNode.__b + 1;\n\n    // Temporarily store the matchingIndex on the _index property so we can pull\n    // out the oldVNode in diffChildren. We'll override this to the VNode's\n    // final index after using this property to get the oldVNode\n    var matchingIndex = childVNode.__i = findMatchingIndex(childVNode, oldChildren, skewedIndex, remainingOldChildren);\n    oldVNode = null;\n    if (matchingIndex !== -1) {\n      oldVNode = oldChildren[matchingIndex];\n      remainingOldChildren--;\n      if (oldVNode) {\n        oldVNode.__u |= MATCHED;\n      }\n    }\n\n    // Here, we define isMounting for the purposes of the skew diffing\n    // algorithm. Nodes that are unsuspending are considered mounting and we detect\n    // this by checking if oldVNode._original === null\n    var isMounting = oldVNode == null || oldVNode.__v === null;\n    if (isMounting) {\n      if (matchingIndex == -1) {\n        skew--;\n      }\n\n      // If we are mounting a DOM VNode, mark it for insertion\n      if (typeof childVNode.type != 'function') {\n        childVNode.__u |= INSERT_VNODE;\n      }\n    } else if (matchingIndex !== skewedIndex) {\n      // When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n      // --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n      //     we set the skew to 1 as we found an offset.\n      // --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n      //     this makes us increase the skew again.\n      // --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n      //\n      // this becomes an optimization question where currently we see a 1 element offset as an insertion\n      // or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n      // while a more than 1 offset we see as a swap.\n      // We could probably build heuristics for having an optimized course of action here as well, but\n      // might go at the cost of some bytes.\n      //\n      // If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n      // only the first item be a re-scouting and all the others fall in their skewed counter-part.\n      // We could also further optimize for swaps\n      if (matchingIndex == skewedIndex - 1) {\n        skew--;\n      } else if (matchingIndex == skewedIndex + 1) {\n        skew++;\n      } else {\n        if (matchingIndex > skewedIndex) {\n          skew--;\n        } else {\n          skew++;\n        }\n\n        // Move this VNode's DOM if the original index (matchingIndex) doesn't\n        // match the new skew index (i + new skew)\n        // In the former two branches we know that it matches after skewing\n        childVNode.__u |= INSERT_VNODE;\n      }\n    }\n  }\n\n  // Remove remaining oldChildren if there are any. Loop forwards so that as we\n  // unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n  // point to the next child, which needs to be the first DOM node that won't be\n  // unmounted.\n  if (remainingOldChildren) {\n    for (i = 0; i < oldChildrenLength; i++) {\n      oldVNode = oldChildren[i];\n      if (oldVNode != null && (oldVNode.__u & MATCHED) === 0) {\n        if (oldVNode.__e == newParentVNode.__d) {\n          newParentVNode.__d = getDomSibling(oldVNode);\n        }\n        unmount(oldVNode, oldVNode);\n      }\n    }\n  }\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n  // Note: VNodes in nested suspended trees may be missing _children.\n\n  if (typeof parentVNode.type == 'function') {\n    var children = parentVNode.__k;\n    for (var i = 0; children && i < children.length; i++) {\n      if (children[i]) {\n        // If we enter this code path on sCU bailout, where we copy\n        // oldVNode._children to newVNode._children, we need to update the old\n        // children's _parent pointer to point to the newVNode (parentVNode\n        // here).\n        children[i].__ = parentVNode;\n        oldDom = insert(children[i], oldDom, parentDom);\n      }\n    }\n    return oldDom;\n  } else if (parentVNode.__e != oldDom) {\n    if (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n      oldDom = getDomSibling(parentVNode);\n    }\n    parentDom.insertBefore(parentVNode.__e, oldDom || null);\n    oldDom = parentVNode.__e;\n  }\n  do {\n    oldDom = oldDom && oldDom.nextSibling;\n  } while (oldDom != null && oldDom.nodeType === 8);\n  return oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nfunction toChildArray(children, out) {\n  out = out || [];\n  if (children == null || typeof children == 'boolean') ; else if (isArray(children)) {\n    children.some(function (child) {\n      toChildArray(child, out);\n    });\n  } else {\n    out.push(children);\n  }\n  return out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(childVNode, oldChildren, skewedIndex, remainingOldChildren) {\n  var key = childVNode.key;\n  var type = childVNode.type;\n  var x = skewedIndex - 1;\n  var y = skewedIndex + 1;\n  var oldVNode = oldChildren[skewedIndex];\n\n  // We only need to perform a search if there are more children\n  // (remainingOldChildren) to search. However, if the oldVNode we just looked\n  // at skewedIndex was not already used in this diff, then there must be at\n  // least 1 other (so greater than 1) remainingOldChildren to attempt to match\n  // against. So the following condition checks that ensuring\n  // remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n  // if the oldVNode was null or matched, then there could needs to be at least\n  // 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n  var shouldSearch = remainingOldChildren > (oldVNode != null && (oldVNode.__u & MATCHED) === 0 ? 1 : 0);\n  if (oldVNode === null || oldVNode && key == oldVNode.key && type === oldVNode.type && (oldVNode.__u & MATCHED) === 0) {\n    return skewedIndex;\n  } else if (shouldSearch) {\n    while (x >= 0 || y < oldChildren.length) {\n      if (x >= 0) {\n        oldVNode = oldChildren[x];\n        if (oldVNode && (oldVNode.__u & MATCHED) === 0 && key == oldVNode.key && type === oldVNode.type) {\n          return x;\n        }\n        x--;\n      }\n      if (y < oldChildren.length) {\n        oldVNode = oldChildren[y];\n        if (oldVNode && (oldVNode.__u & MATCHED) === 0 && key == oldVNode.key && type === oldVNode.type) {\n          return y;\n        }\n        y++;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction setStyle(style, key, value) {\n  if (key[0] === '-') {\n    style.setProperty(key, value == null ? '' : value);\n  } else if (value == null) {\n    style[key] = '';\n  } else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n    style[key] = value;\n  } else {\n    style[key] = value + 'px';\n  }\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nvar eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nfunction setProperty(dom, name, value, oldValue, namespace) {\n  var useCapture;\n  o: if (name === 'style') {\n    if (typeof value == 'string') {\n      dom.style.cssText = value;\n    } else {\n      if (typeof oldValue == 'string') {\n        dom.style.cssText = oldValue = '';\n      }\n      if (oldValue) {\n        for (name in oldValue) {\n          if (!(value && name in value)) {\n            setStyle(dom.style, name, '');\n          }\n        }\n      }\n      if (value) {\n        for (name in value) {\n          if (!oldValue || value[name] !== oldValue[name]) {\n            setStyle(dom.style, name, value[name]);\n          }\n        }\n      }\n    }\n  }\n  // Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n  else if (name[0] === 'o' && name[1] === 'n') {\n    useCapture = name !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n    // Infer correct casing for DOM built-in events:\n    if (name.toLowerCase() in dom || name === 'onFocusOut' || name === 'onFocusIn') name = name.toLowerCase().slice(2);else name = name.slice(2);\n    if (!dom.l) dom.l = {};\n    dom.l[name + useCapture] = value;\n    if (value) {\n      if (!oldValue) {\n        value._attached = eventClock;\n        dom.addEventListener(name, useCapture ? eventProxyCapture : eventProxy, useCapture);\n      } else {\n        value._attached = oldValue._attached;\n      }\n    } else {\n      dom.removeEventListener(name, useCapture ? eventProxyCapture : eventProxy, useCapture);\n    }\n  } else {\n    if (namespace == 'http://www.w3.org/2000/svg') {\n      // Normalize incorrect prop usage for SVG:\n      // - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n      // - className --> class\n      name = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n    } else if (name != 'width' && name != 'height' && name != 'href' && name != 'list' && name != 'form' &&\n    // Default value in browsers is `-1` and an empty string is\n    // cast to `0` instead\n    name != 'tabIndex' && name != 'download' && name != 'rowSpan' && name != 'colSpan' && name != 'role' && name != 'popover' && name in dom) {\n      try {\n        dom[name] = value == null ? '' : value;\n        // labelled break is 1b smaller here than a return statement (sorry)\n        break o;\n      } catch (e) {}\n    }\n\n    // aria- and data- attributes have no boolean representation.\n    // A `false` value is different from the attribute not being\n    // present, so we can't remove it. For non-boolean aria\n    // attributes we could treat false as a removal, but the\n    // amount of exceptions would cost too many bytes. On top of\n    // that other frameworks generally stringify `false`.\n\n    if (typeof value == 'function') ; else if (value != null && (value !== false || name[4] === '-')) {\n      dom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n    } else {\n      dom.removeAttribute(name);\n    }\n  }\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n  /**\n   * Proxy an event to hooked event handlers\n   * @param {PreactEvent} e The event object from the browser\n   * @private\n   */\n  return function (e) {\n    if (this.l) {\n      var eventHandler = this.l[e.type + useCapture];\n      if (e._dispatched == null) {\n        e._dispatched = eventClock++;\n\n        // When `e._dispatched` is smaller than the time when the targeted event\n        // handler was attached we know we have bubbled up to an element that was added\n        // during patching the DOM.\n      } else if (e._dispatched < eventHandler._attached) {\n        return;\n      }\n      return eventHandler(options.event ? options.event(e) : e);\n    }\n  };\n}\nvar eventProxy = createEventProxy(false);\nvar eventProxyCapture = createEventProxy(true);\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nfunction diff(parentDom, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue) {\n  /** @type {any} */\n  var tmp,\n    newType = newVNode.type;\n\n  // When passing through createElement it assigns the object\n  // constructor as undefined. This to prevent JSON-injection.\n  if (newVNode.constructor !== undefined) return null;\n\n  // If the previous diff bailed out, resume creating/hydrating.\n  if (oldVNode.__u & MODE_SUSPENDED) {\n    isHydrating = !!(oldVNode.__u & MODE_HYDRATE);\n    oldDom = newVNode.__e = oldVNode.__e;\n    excessDomChildren = [oldDom];\n  }\n  if (tmp = options.__b) tmp(newVNode);\n  outer: if (typeof newType == 'function') {\n    try {\n      var c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n      var newProps = newVNode.props;\n      var isClassComponent = 'prototype' in newType && newType.prototype.render;\n\n      // Necessary for createContext api. Setting this property will pass\n      // the context value as `this.context` just for this component.\n      tmp = newType.contextType;\n      var provider = tmp && globalContext[tmp.__c];\n      var componentContext = tmp ? provider ? provider.props.value : tmp.__ : globalContext;\n\n      // Get component and set it to `c`\n      if (oldVNode.__c) {\n        c = newVNode.__c = oldVNode.__c;\n        clearProcessingException = c.__ = c.__E;\n      } else {\n        // Instantiate the new component\n        if (isClassComponent) {\n          // @ts-expect-error The check above verifies that newType is suppose to be constructed\n          newVNode.__c = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n        } else {\n          // @ts-expect-error Trust me, Component implements the interface we want\n          newVNode.__c = c = new BaseComponent(newProps, componentContext);\n          c.constructor = newType;\n          c.render = doRender;\n        }\n        if (provider) provider.sub(c);\n        c.props = newProps;\n        if (!c.state) c.state = {};\n        c.context = componentContext;\n        c.__n = globalContext;\n        isNew = c.__d = true;\n        c.__h = [];\n        c._sb = [];\n      }\n\n      // Invoke getDerivedStateFromProps\n      if (isClassComponent && c.__s == null) {\n        c.__s = c.state;\n      }\n      if (isClassComponent && newType.getDerivedStateFromProps != null) {\n        if (c.__s == c.state) {\n          c.__s = assign({}, c.__s);\n        }\n        assign(c.__s, newType.getDerivedStateFromProps(newProps, c.__s));\n      }\n      oldProps = c.props;\n      oldState = c.state;\n      c.__v = newVNode;\n\n      // Invoke pre-render lifecycle methods\n      if (isNew) {\n        if (isClassComponent && newType.getDerivedStateFromProps == null && c.componentWillMount != null) {\n          c.componentWillMount();\n        }\n        if (isClassComponent && c.componentDidMount != null) {\n          c.__h.push(c.componentDidMount);\n        }\n      } else {\n        if (isClassComponent && newType.getDerivedStateFromProps == null && newProps !== oldProps && c.componentWillReceiveProps != null) {\n          c.componentWillReceiveProps(newProps, componentContext);\n        }\n        if (!c.__e && (c.shouldComponentUpdate != null && c.shouldComponentUpdate(newProps, c.__s, componentContext) === false || newVNode.__v === oldVNode.__v)) {\n          // More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n          if (newVNode.__v !== oldVNode.__v) {\n            // When we are dealing with a bail because of sCU we have to update\n            // the props, state and dirty-state.\n            // when we are dealing with strict-equality we don't as the child could still\n            // be dirtied see #3883\n            c.props = newProps;\n            c.state = c.__s;\n            c.__d = false;\n          }\n          newVNode.__e = oldVNode.__e;\n          newVNode.__k = oldVNode.__k;\n          newVNode.__k.some(function (vnode) {\n            if (vnode) vnode.__ = newVNode;\n          });\n          for (var i = 0; i < c._sb.length; i++) {\n            c.__h.push(c._sb[i]);\n          }\n          c._sb = [];\n          if (c.__h.length) {\n            commitQueue.push(c);\n          }\n          break outer;\n        }\n        if (c.componentWillUpdate != null) {\n          c.componentWillUpdate(newProps, c.__s, componentContext);\n        }\n        if (isClassComponent && c.componentDidUpdate != null) {\n          c.__h.push(function () {\n            c.componentDidUpdate(oldProps, oldState, snapshot);\n          });\n        }\n      }\n      c.context = componentContext;\n      c.props = newProps;\n      c.__P = parentDom;\n      c.__e = false;\n      var renderHook = options.__r,\n        count = 0;\n      if (isClassComponent) {\n        c.state = c.__s;\n        c.__d = false;\n        if (renderHook) renderHook(newVNode);\n        tmp = c.render(c.props, c.state, c.context);\n        for (var _i = 0; _i < c._sb.length; _i++) {\n          c.__h.push(c._sb[_i]);\n        }\n        c._sb = [];\n      } else {\n        do {\n          c.__d = false;\n          if (renderHook) renderHook(newVNode);\n          tmp = c.render(c.props, c.state, c.context);\n\n          // Handle setState called in render, see #2553\n          c.state = c.__s;\n        } while (c.__d && ++count < 25);\n      }\n\n      // Handle setState called in render, see #2553\n      c.state = c.__s;\n      if (c.getChildContext != null) {\n        globalContext = assign(assign({}, globalContext), c.getChildContext());\n      }\n      if (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n        snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n      }\n      var isTopLevelFragment = tmp != null && tmp.type === Fragment && tmp.key == null;\n      var renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n      diffChildren(parentDom, isArray(renderResult) ? renderResult : [renderResult], newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue);\n      c.base = newVNode.__e;\n\n      // We successfully rendered this VNode, unset any stored hydration/bailout state:\n      newVNode.__u &= RESET_MODE;\n      if (c.__h.length) {\n        commitQueue.push(c);\n      }\n      if (clearProcessingException) {\n        c.__E = c.__ = null;\n      }\n    } catch (e) {\n      newVNode.__v = null;\n      // if hydrating or creating initial tree, bailout preserves DOM:\n      if (isHydrating || excessDomChildren != null) {\n        newVNode.__u |= isHydrating ? MODE_HYDRATE | MODE_SUSPENDED : MODE_HYDRATE;\n        while (oldDom && oldDom.nodeType === 8 && oldDom.nextSibling) {\n          oldDom = oldDom.nextSibling;\n        }\n        excessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n        newVNode.__e = oldDom;\n      } else {\n        newVNode.__e = oldVNode.__e;\n        newVNode.__k = oldVNode.__k;\n      }\n      options.__e(e, newVNode, oldVNode);\n    }\n  } else if (excessDomChildren == null && newVNode.__v === oldVNode.__v) {\n    newVNode.__k = oldVNode.__k;\n    newVNode.__e = oldVNode.__e;\n  } else {\n    newVNode.__e = diffElementNodes(oldVNode.__e, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, isHydrating, refQueue);\n  }\n  if (tmp = options.diffed) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nfunction commitRoot(commitQueue, root, refQueue) {\n  root.__d = undefined;\n  for (var i = 0; i < refQueue.length; i++) {\n    applyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n  }\n  if (options.__c) options.__c(root, commitQueue);\n  commitQueue.some(function (c) {\n    try {\n      // @ts-expect-error Reuse the commitQueue variable here so the type changes\n      commitQueue = c.__h;\n      c.__h = [];\n      commitQueue.some(function (cb) {\n        // @ts-expect-error See above comment on commitQueue\n        cb.call(c);\n      });\n    } catch (e) {\n      options.__e(e, c.__v);\n    }\n  });\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(dom, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, isHydrating, refQueue) {\n  var oldProps = oldVNode.props;\n  var newProps = newVNode.props;\n  var nodeType = /** @type {string} */newVNode.type;\n  /** @type {any} */\n  var i;\n  /** @type {{ __html?: string }} */\n  var newHtml;\n  /** @type {{ __html?: string }} */\n  var oldHtml;\n  /** @type {ComponentChildren} */\n  var newChildren;\n  var value;\n  var inputValue;\n  var checked;\n\n  // Tracks entering and exiting namespaces when descending through the tree.\n  if (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';else if (nodeType === 'math') namespace = 'http://www.w3.org/1998/Math/MathML';else if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n  if (excessDomChildren != null) {\n    for (i = 0; i < excessDomChildren.length; i++) {\n      value = excessDomChildren[i];\n\n      // if newVNode matches an element in excessDomChildren or the `dom`\n      // argument matches an element in excessDomChildren, remove it from\n      // excessDomChildren so it isn't later removed in diffChildren\n      if (value && 'setAttribute' in value === !!nodeType && (nodeType ? value.localName === nodeType : value.nodeType === 3)) {\n        dom = value;\n        excessDomChildren[i] = null;\n        break;\n      }\n    }\n  }\n  if (dom == null) {\n    if (nodeType === null) {\n      return options.document.createTextNode(newProps);\n    }\n    dom = options.document.createElementNS(namespace, nodeType, newProps.is && newProps);\n\n    // we are creating a new node, so we can assume this is a new subtree (in\n    // case we are hydrating), this deopts the hydrate\n    if (isHydrating) {\n      if (options.__m) options.__m(newVNode, excessDomChildren);\n      isHydrating = false;\n    }\n    // we created a new parent, so none of the previously attached children can be reused:\n    excessDomChildren = null;\n  }\n  if (nodeType === null) {\n    // During hydration, we still have to split merged text from SSR'd HTML.\n    if (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n      dom.data = newProps;\n    }\n  } else {\n    // If excessDomChildren was not null, repopulate it with the current element's children:\n    excessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n    oldProps = oldVNode.props || EMPTY_OBJ;\n\n    // If we are in a situation where we are not hydrating but are using\n    // existing DOM (e.g. replaceNode) we should read the existing DOM\n    // attributes to diff them\n    if (!isHydrating && excessDomChildren != null) {\n      oldProps = {};\n      for (i = 0; i < dom.attributes.length; i++) {\n        value = dom.attributes[i];\n        oldProps[value.name] = value.value;\n      }\n    }\n    for (i in oldProps) {\n      value = oldProps[i];\n      if (i == 'children') ; else if (i == 'dangerouslySetInnerHTML') {\n        oldHtml = value;\n      } else if (!(i in newProps)) {\n        if (i == 'value' && 'defaultValue' in newProps || i == 'checked' && 'defaultChecked' in newProps) {\n          continue;\n        }\n        setProperty(dom, i, null, value, namespace);\n      }\n    }\n\n    // During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n    // @TODO we should warn in debug mode when props don't match here.\n    for (i in newProps) {\n      value = newProps[i];\n      if (i == 'children') {\n        newChildren = value;\n      } else if (i == 'dangerouslySetInnerHTML') {\n        newHtml = value;\n      } else if (i == 'value') {\n        inputValue = value;\n      } else if (i == 'checked') {\n        checked = value;\n      } else if ((!isHydrating || typeof value == 'function') && oldProps[i] !== value) {\n        setProperty(dom, i, value, oldProps[i], namespace);\n      }\n    }\n\n    // If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n    if (newHtml) {\n      // Avoid re-applying the same '__html' if it did not changed between re-render\n      if (!isHydrating && (!oldHtml || newHtml.__html !== oldHtml.__html && newHtml.__html !== dom.innerHTML)) {\n        dom.innerHTML = newHtml.__html;\n      }\n      newVNode.__k = [];\n    } else {\n      if (oldHtml) dom.innerHTML = '';\n      diffChildren(dom, isArray(newChildren) ? newChildren : [newChildren], newVNode, oldVNode, globalContext, nodeType === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : namespace, excessDomChildren, commitQueue, excessDomChildren ? excessDomChildren[0] : oldVNode.__k && getDomSibling(oldVNode, 0), isHydrating, refQueue);\n\n      // Remove children that are not part of any vnode.\n      if (excessDomChildren != null) {\n        for (i = excessDomChildren.length; i--;) {\n          removeNode(excessDomChildren[i]);\n        }\n      }\n    }\n\n    // As above, don't diff props during hydration\n    if (!isHydrating) {\n      i = 'value';\n      if (nodeType === 'progress' && inputValue == null) {\n        dom.removeAttribute('value');\n      } else if (inputValue !== undefined && (\n      // #2756 For the <progress>-element the initial value is 0,\n      // despite the attribute not being present. When the attribute\n      // is missing the progress bar is treated as indeterminate.\n      // To fix that we'll always update it when it is 0 for progress elements\n      inputValue !== dom[i] || nodeType === 'progress' && !inputValue ||\n      // This is only for IE 11 to fix <select> value not being updated.\n      // To avoid a stale select value we need to set the option.value\n      // again, which triggers IE11 to re-evaluate the select value\n      nodeType === 'option' && inputValue !== oldProps[i])) {\n        setProperty(dom, i, inputValue, oldProps[i], namespace);\n      }\n      i = 'checked';\n      if (checked !== undefined && checked !== dom[i]) {\n        setProperty(dom, i, checked, oldProps[i], namespace);\n      }\n    }\n  }\n  return dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nfunction applyRef(ref, value, vnode) {\n  try {\n    if (typeof ref == 'function') {\n      var hasRefUnmount = typeof ref.__u == 'function';\n      if (hasRefUnmount) {\n        // @ts-ignore TS doesn't like moving narrowing checks into variables\n        ref.__u();\n      }\n      if (!hasRefUnmount || value != null) {\n        // Store the cleanup function on the function\n        // instance object itself to avoid shape\n        // transitioning vnode\n        ref.__u = ref(value);\n      }\n    } else ref.current = value;\n  } catch (e) {\n    options.__e(e, vnode);\n  }\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nfunction unmount(vnode, parentVNode, skipRemove) {\n  var r;\n  if (options.unmount) options.unmount(vnode);\n  if (r = vnode.ref) {\n    if (!r.current || r.current === vnode.__e) {\n      applyRef(r, null, parentVNode);\n    }\n  }\n  if ((r = vnode.__c) != null) {\n    if (r.componentWillUnmount) {\n      try {\n        r.componentWillUnmount();\n      } catch (e) {\n        options.__e(e, parentVNode);\n      }\n    }\n    r.base = r.__P = null;\n  }\n  if (r = vnode.__k) {\n    for (var i = 0; i < r.length; i++) {\n      if (r[i]) {\n        unmount(r[i], parentVNode, skipRemove || typeof vnode.type != 'function');\n      }\n    }\n  }\n  if (!skipRemove) {\n    removeNode(vnode.__e);\n  }\n\n  // Must be set to `undefined` to properly clean up `_nextDom`\n  // for which `null` is a valid value. See comment in `create-element.js`\n  vnode.__c = vnode.__ = vnode.__e = vnode.__d = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n  return this.constructor(props, context);\n}\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nfunction render(vnode, parentDom, replaceNode) {\n  if (options.__) options.__(vnode, parentDom);\n\n  // We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n  // hydration mode or not by passing the `hydrate` function instead of a DOM\n  // element..\n  var isHydrating = typeof replaceNode == 'function';\n\n  // To be able to support calling `render()` multiple times on the same\n  // DOM node, we need to obtain a reference to the previous tree. We do\n  // this by assigning a new `_children` property to DOM nodes which points\n  // to the last rendered tree. By default this property is not present, which\n  // means that we are mounting a new tree for the first time.\n  var oldVNode = isHydrating ? null : replaceNode && replaceNode.__k || parentDom.__k;\n  vnode = (!isHydrating && replaceNode || parentDom).__k = createElement(Fragment, null, [vnode]);\n\n  // List of effects that need to be called after diffing.\n  var commitQueue = [],\n    refQueue = [];\n  diff(parentDom,\n  // Determine the new vnode tree and store it on the DOM element on\n  // our custom `_children` property.\n  vnode, oldVNode || EMPTY_OBJ, EMPTY_OBJ, parentDom.namespaceURI, !isHydrating && replaceNode ? [replaceNode] : oldVNode ? null : parentDom.firstChild ? slice.call(parentDom.childNodes) : null, commitQueue, !isHydrating && replaceNode ? replaceNode : oldVNode ? oldVNode.__e : parentDom.firstChild, isHydrating, refQueue);\n\n  // Flush all queued effects\n  commitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nfunction hydrate(vnode, parentDom) {\n  render(vnode, parentDom, hydrate);\n}\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nfunction cloneElement(vnode, props, children) {\n  var normalizedProps = assign({}, vnode.props),\n    key,\n    ref,\n    i;\n  var defaultProps;\n  if (vnode.type && vnode.type.defaultProps) {\n    defaultProps = vnode.type.defaultProps;\n  }\n  for (i in props) {\n    if (i == 'key') key = props[i];else if (i == 'ref') ref = props[i];else if (props[i] === undefined && defaultProps !== undefined) {\n      normalizedProps[i] = defaultProps[i];\n    } else {\n      normalizedProps[i] = props[i];\n    }\n  }\n  if (arguments.length > 2) {\n    normalizedProps.children = arguments.length > 3 ? slice.call(arguments, 2) : children;\n  }\n  return createVNode(vnode.type, normalizedProps, key || vnode.key, ref || vnode.ref, null);\n}\n\nvar i = 0;\nfunction createContext(defaultValue, contextId) {\n  contextId = '__cC' + i++;\n  var context = {\n    __c: contextId,\n    __: defaultValue,\n    /** @type {FunctionComponent} */Consumer: function Consumer(props, contextValue) {\n      // return props.children(\n      // \tcontext[contextId] ? context[contextId].props.value : defaultValue\n      // );\n      return props.children(contextValue);\n    },\n    /** @type {FunctionComponent} */Provider: function Provider(props) {\n      if (!this.getChildContext) {\n        /** @type {Component[] | null} */\n        var subs = [];\n        var ctx = {};\n        ctx[contextId] = this;\n        this.getChildContext = function () {\n          return ctx;\n        };\n        this.componentWillUnmount = function () {\n          subs = null;\n        };\n        this.shouldComponentUpdate = function (_props) {\n          if (this.props.value !== _props.value) {\n            subs.some(function (c) {\n              c.__e = true;\n              enqueueRender(c);\n            });\n          }\n        };\n        this.sub = function (c) {\n          subs.push(c);\n          var old = c.componentWillUnmount;\n          c.componentWillUnmount = function () {\n            if (subs) {\n              subs.splice(subs.indexOf(c), 1);\n            }\n            if (old) old.call(c);\n          };\n        };\n      }\n      return props.children;\n    }\n  };\n\n  // Devtools needs access to the context object when it\n  // encounters a Provider. This is necessary to support\n  // setting `displayName` on the context object instead\n  // of on the component itself. See:\n  // https://reactjs.org/docs/context.html#contextdisplayname\n\n  return context.Provider.__ = context.Consumer.contextType = context;\n}\n\nexport { BaseComponent as Component, Fragment, cloneElement, createContext, createElement, createRef, createElement as h, hydrate, isValidElement, options, render, toChildArray };\n//# sourceMappingURL=preact.module.js.map\n","import { options as options$1 } from 'preact';\n\n/** @type {number} */\nvar currentIndex;\n\n/** @type {import('./internal').Component} */\nvar currentComponent;\n\n/** @type {import('./internal').Component} */\nvar previousComponent;\n\n/** @type {number} */\nvar currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nvar afterPaintEffects = [];\n\n// Cast to use internal Options type\nvar options = /** @type {import('./internal').Options} */options$1;\nvar oldBeforeDiff = options.__b;\nvar oldBeforeRender = options.__r;\nvar oldAfterDiff = options.diffed;\nvar oldCommit = options.__c;\nvar oldBeforeUnmount = options.unmount;\nvar oldRoot = options.__;\nvar RAF_TIMEOUT = 100;\nvar prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.__b = function (vnode) {\n  currentComponent = null;\n  if (oldBeforeDiff) oldBeforeDiff(vnode);\n};\noptions.__ = function (vnode, parentDom) {\n  if (vnode && parentDom.__k && parentDom.__k.__m) {\n    vnode.__m = parentDom.__k.__m;\n  }\n  if (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.__r = function (vnode) {\n  if (oldBeforeRender) oldBeforeRender(vnode);\n  currentComponent = vnode.__c;\n  currentIndex = 0;\n  var hooks = currentComponent.__H;\n  if (hooks) {\n    if (previousComponent === currentComponent) {\n      hooks.__h = [];\n      currentComponent.__h = [];\n      hooks.__.forEach(function (hookItem) {\n        if (hookItem.__N) {\n          hookItem.__ = hookItem.__N;\n        }\n        hookItem._pendingArgs = hookItem.__N = undefined;\n      });\n    } else {\n      hooks.__h.forEach(invokeCleanup);\n      hooks.__h.forEach(invokeEffect);\n      hooks.__h = [];\n      currentIndex = 0;\n    }\n  }\n  previousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n  if (oldAfterDiff) oldAfterDiff(vnode);\n  var c = vnode.__c;\n  if (c && c.__H) {\n    if (c.__H.__h.length) afterPaint(afterPaintEffects.push(c));\n    c.__H.__.forEach(function (hookItem) {\n      if (hookItem._pendingArgs) {\n        hookItem.__H = hookItem._pendingArgs;\n      }\n      hookItem._pendingArgs = undefined;\n    });\n  }\n  previousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions.__c = function (vnode, commitQueue) {\n  commitQueue.some(function (component) {\n    try {\n      component.__h.forEach(invokeCleanup);\n      component.__h = component.__h.filter(function (cb) {\n        return cb.__ ? invokeEffect(cb) : true;\n      });\n    } catch (e) {\n      commitQueue.some(function (c) {\n        if (c.__h) c.__h = [];\n      });\n      commitQueue = [];\n      options.__e(e, component.__v);\n    }\n  });\n  if (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = function (vnode) {\n  if (oldBeforeUnmount) oldBeforeUnmount(vnode);\n  var c = vnode.__c;\n  if (c && c.__H) {\n    var hasErrored;\n    c.__H.__.forEach(function (s) {\n      try {\n        invokeCleanup(s);\n      } catch (e) {\n        hasErrored = e;\n      }\n    });\n    c.__H = undefined;\n    if (hasErrored) options.__e(hasErrored, c.__v);\n  }\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n  if (options.__h) {\n    options.__h(currentComponent, index, currentHook || type);\n  }\n  currentHook = 0;\n\n  // Largely inspired by:\n  // * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n  // * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n  // Other implementations to look at:\n  // * https://codesandbox.io/s/mnox05qp8\n  var hooks = currentComponent.__H || (currentComponent.__H = {\n    __: [],\n    __h: []\n  });\n  if (index >= hooks.__.length) {\n    hooks.__.push({});\n  }\n  return hooks.__[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nfunction useState(initialState) {\n  currentHook = 1;\n  return useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nfunction useReducer(reducer, initialState, init) {\n  /** @type {import('./internal').ReducerHookState} */\n  var hookState = getHookState(currentIndex++, 2);\n  hookState._reducer = reducer;\n  if (!hookState.__c) {\n    hookState.__ = [!init ? invokeOrReturn(undefined, initialState) : init(initialState), function (action) {\n      var currentValue = hookState.__N ? hookState.__N[0] : hookState.__[0];\n      var nextValue = hookState._reducer(currentValue, action);\n      if (currentValue !== nextValue) {\n        hookState.__N = [nextValue, hookState.__[1]];\n        hookState.__c.setState({});\n      }\n    }];\n    hookState.__c = currentComponent;\n    if (!currentComponent._hasScuFromHooks) {\n      // This SCU has the purpose of bailing out after repeated updates\n      // to stateful hooks.\n      // we store the next value in _nextValue[0] and keep doing that for all\n      // state setters, if we have next states and\n      // all next states within a component end up being equal to their original state\n      // we are safe to bail out for this specific component.\n      /**\n       *\n       * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n       */\n      // @ts-ignore - We don't use TS to downtranspile\n      // eslint-disable-next-line no-inner-declarations\n      var updateHookState = function updateHookState(p, s, c) {\n        if (!hookState.__c.__H) return true;\n\n        /** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n        var isStateHook = function isStateHook(x) {\n          return !!x.__c;\n        };\n        var stateHooks = hookState.__c.__H.__.filter(isStateHook);\n        var allHooksEmpty = stateHooks.every(function (x) {\n          return !x.__N;\n        });\n        // When we have no updated hooks in the component we invoke the previous SCU or\n        // traverse the VDOM tree further.\n        if (allHooksEmpty) {\n          return prevScu ? prevScu.call(this, p, s, c) : true;\n        }\n\n        // We check whether we have components with a nextValue set that\n        // have values that aren't equal to one another this pushes\n        // us to update further down the tree\n        var shouldUpdate = false;\n        stateHooks.forEach(function (hookItem) {\n          if (hookItem.__N) {\n            var currentValue = hookItem.__[0];\n            hookItem.__ = hookItem.__N;\n            hookItem.__N = undefined;\n            if (currentValue !== hookItem.__[0]) shouldUpdate = true;\n          }\n        });\n        return shouldUpdate || hookState.__c.props !== p ? prevScu ? prevScu.call(this, p, s, c) : true : false;\n      };\n      currentComponent._hasScuFromHooks = true;\n      var prevScu = currentComponent.shouldComponentUpdate;\n      var prevCWU = currentComponent.componentWillUpdate;\n\n      // If we're dealing with a forced update `shouldComponentUpdate` will\n      // not be called. But we use that to update the hook values, so we\n      // need to call it.\n      currentComponent.componentWillUpdate = function (p, s, c) {\n        if (this.__e) {\n          var tmp = prevScu;\n          // Clear to avoid other sCU hooks from being called\n          prevScu = undefined;\n          updateHookState(p, s, c);\n          prevScu = tmp;\n        }\n        if (prevCWU) prevCWU.call(this, p, s, c);\n      };\n      currentComponent.shouldComponentUpdate = updateHookState;\n    }\n  }\n  return hookState.__N || hookState.__;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useEffect(callback, args) {\n  /** @type {import('./internal').EffectHookState} */\n  var state = getHookState(currentIndex++, 3);\n  if (!options.__s && argsChanged(state.__H, args)) {\n    state.__ = callback;\n    state._pendingArgs = args;\n    currentComponent.__H.__h.push(state);\n  }\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useLayoutEffect(callback, args) {\n  /** @type {import('./internal').EffectHookState} */\n  var state = getHookState(currentIndex++, 4);\n  if (!options.__s && argsChanged(state.__H, args)) {\n    state.__ = callback;\n    state._pendingArgs = args;\n    currentComponent.__h.push(state);\n  }\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nfunction useRef(initialValue) {\n  currentHook = 5;\n  return useMemo(function () {\n    return {\n      current: initialValue\n    };\n  }, []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useImperativeHandle(ref, createHandle, args) {\n  currentHook = 6;\n  useLayoutEffect(function () {\n    if (typeof ref == 'function') {\n      ref(createHandle());\n      return function () {\n        return ref(null);\n      };\n    } else if (ref) {\n      ref.current = createHandle();\n      return function () {\n        return ref.current = null;\n      };\n    }\n  }, args == null ? args : args.concat(ref));\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nfunction useMemo(factory, args) {\n  /** @type {import('./internal').MemoHookState<T>} */\n  var state = getHookState(currentIndex++, 7);\n  if (argsChanged(state.__H, args)) {\n    state.__ = factory();\n    state.__H = args;\n    state.__h = factory;\n  }\n  return state.__;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nfunction useCallback(callback, args) {\n  currentHook = 8;\n  return useMemo(function () {\n    return callback;\n  }, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nfunction useContext(context) {\n  var provider = currentComponent.context[context.__c];\n  // We could skip this call here, but than we'd not call\n  // `options._hook`. We need to do that in order to make\n  // the devtools aware of this hook.\n  /** @type {import('./internal').ContextHookState} */\n  var state = getHookState(currentIndex++, 9);\n  // The devtools needs access to the context object to\n  // be able to pull of the default value when no provider\n  // is present in the tree.\n  state.c = context;\n  if (!provider) return context.__;\n  // This is probably not safe to convert to \"!\"\n  if (state.__ == null) {\n    state.__ = true;\n    provider.sub(currentComponent);\n  }\n  return provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nfunction useDebugValue(value, formatter) {\n  if (options.useDebugValue) {\n    options.useDebugValue(formatter ? formatter(value) : ( /** @type {any}*/value));\n  }\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nfunction useErrorBoundary(cb) {\n  /** @type {import('./internal').ErrorBoundaryHookState} */\n  var state = getHookState(currentIndex++, 10);\n  var errState = useState();\n  state.__ = cb;\n  if (!currentComponent.componentDidCatch) {\n    currentComponent.componentDidCatch = function (err, errorInfo) {\n      if (state.__) state.__(err, errorInfo);\n      errState[1](err);\n    };\n  }\n  return [errState[0], function () {\n    errState[1](undefined);\n  }];\n}\n\n/** @type {() => string} */\nfunction useId() {\n  /** @type {import('./internal').IdHookState} */\n  var state = getHookState(currentIndex++, 11);\n  if (!state.__) {\n    // Grab either the root node or the nearest async boundary node.\n    /** @type {import('./internal.d').VNode} */\n    var root = currentComponent.__v;\n    while (root !== null && !root.__m && root.__ !== null) {\n      root = root.__;\n    }\n    var mask = root.__m || (root.__m = [0, 0]);\n    state.__ = 'P' + mask[0] + '-' + mask[1]++;\n  }\n  return state.__;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n  var component;\n  while (component = afterPaintEffects.shift()) {\n    if (!component.__P || !component.__H) continue;\n    try {\n      component.__H.__h.forEach(invokeCleanup);\n      component.__H.__h.forEach(invokeEffect);\n      component.__H.__h = [];\n    } catch (e) {\n      component.__H.__h = [];\n      options.__e(e, component.__v);\n    }\n  }\n}\nvar HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n  var done = function done() {\n    clearTimeout(timeout);\n    if (HAS_RAF) cancelAnimationFrame(raf);\n    setTimeout(callback);\n  };\n  var timeout = setTimeout(done, RAF_TIMEOUT);\n  var raf;\n  if (HAS_RAF) {\n    raf = requestAnimationFrame(done);\n  }\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n  if (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n    prevRaf = options.requestAnimationFrame;\n    (prevRaf || afterNextFrame)(flushAfterPaintEffects);\n  }\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n  // A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n  // and move the currentComponent away.\n  var comp = currentComponent;\n  var cleanup = hook.__c;\n  if (typeof cleanup == 'function') {\n    hook.__c = undefined;\n    cleanup();\n  }\n  currentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n  // A hook call can introduce a call to render which creates a new root, this will call options.vnode\n  // and move the currentComponent away.\n  var comp = currentComponent;\n  hook.__c = hook.__();\n  currentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n  return !oldArgs || oldArgs.length !== newArgs.length || newArgs.some(function (arg, index) {\n    return arg !== oldArgs[index];\n  });\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n  return typeof f == 'function' ? f(arg) : f;\n}\n\nexport { useCallback, useContext, useDebugValue, useEffect, useErrorBoundary, useId, useImperativeHandle, useLayoutEffect, useMemo, useReducer, useRef, useState };\n//# sourceMappingURL=hooks.module.js.map\n","import { Component, createElement, options, toChildArray, Fragment, render as render$1, hydrate as hydrate$1, createContext, createRef, cloneElement as cloneElement$1 } from 'preact';\nexport { Component, Fragment, createContext, createElement, createRef } from 'preact';\nimport { useCallback, useContext, useDebugValue, useEffect, useId, useImperativeHandle, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'preact/hooks';\nexport * from 'preact/hooks';\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nfunction assign(obj, props) {\n  for (var i in props) obj[i] = props[i];\n  return /** @type {O & P} */obj;\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nfunction shallowDiffers(a, b) {\n  for (var i in a) if (i !== '__source' && !(i in b)) return true;\n  for (var _i in b) if (_i !== '__source' && a[_i] !== b[_i]) return true;\n  return false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nfunction PureComponent(p, c) {\n  this.props = p;\n  this.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n  return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nfunction memo(c, comparer) {\n  function shouldUpdate(nextProps) {\n    var ref = this.props.ref;\n    var updateRef = ref == nextProps.ref;\n    if (!updateRef && ref) {\n      ref.call ? ref(null) : ref.current = null;\n    }\n    if (!comparer) {\n      return shallowDiffers(this.props, nextProps);\n    }\n    return !comparer(this.props, nextProps) || !updateRef;\n  }\n  function Memoed(props) {\n    this.shouldComponentUpdate = shouldUpdate;\n    return createElement(c, props);\n  }\n  Memoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n  Memoed.prototype.isReactComponent = true;\n  Memoed.__f = true;\n  return Memoed;\n}\n\nvar oldDiffHook = options.__b;\noptions.__b = function (vnode) {\n  if (vnode.type && vnode.type.__f && vnode.ref) {\n    vnode.props.ref = vnode.ref;\n    vnode.ref = null;\n  }\n  if (oldDiffHook) oldDiffHook(vnode);\n};\nvar REACT_FORWARD_SYMBOL = typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.forward_ref') || 0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nfunction forwardRef(fn) {\n  function Forwarded(props) {\n    var clone = assign({}, props);\n    delete clone.ref;\n    return fn(clone, props.ref || null);\n  }\n\n  // mobx-react checks for this being present\n  Forwarded.$$typeof = REACT_FORWARD_SYMBOL;\n  // mobx-react heavily relies on implementation details.\n  // It expects an object here with a `render` property,\n  // and prototype.render will fail. Without this\n  // mobx-react throws.\n  Forwarded.render = Forwarded;\n  Forwarded.prototype.isReactComponent = Forwarded.__f = true;\n  Forwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n  return Forwarded;\n}\n\nvar mapFn = function mapFn(children, fn) {\n  if (children == null) return null;\n  return toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nvar Children = {\n  map: mapFn,\n  forEach: mapFn,\n  count: function count(children) {\n    return children ? toChildArray(children).length : 0;\n  },\n  only: function only(children) {\n    var normalized = toChildArray(children);\n    if (normalized.length !== 1) throw 'Children.only';\n    return normalized[0];\n  },\n  toArray: toChildArray\n};\n\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nvar MODE_HYDRATE = 1 << 5;\n\nvar oldCatchError = options.__e;\noptions.__e = function (error, newVNode, oldVNode, errorInfo) {\n  if (error.then) {\n    /** @type {import('./internal').Component} */\n    var component;\n    var vnode = newVNode;\n    for (; vnode = vnode.__;) {\n      if ((component = vnode.__c) && component.__c) {\n        if (newVNode.__e == null) {\n          newVNode.__e = oldVNode.__e;\n          newVNode.__k = oldVNode.__k;\n        }\n        // Don't call oldCatchError if we found a Suspense\n        return component.__c(error, newVNode);\n      }\n    }\n  }\n  oldCatchError(error, newVNode, oldVNode, errorInfo);\n};\nvar oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n  /** @type {import('./internal').Component} */\n  var component = vnode.__c;\n  if (component && component.__R) {\n    component.__R();\n  }\n\n  // if the component is still hydrating\n  // most likely it is because the component is suspended\n  // we set the vnode.type as `null` so that it is not a typeof function\n  // so the unmount will remove the vnode._dom\n  if (component && vnode.__u & MODE_HYDRATE) {\n    vnode.type = null;\n  }\n  if (oldUnmount) oldUnmount(vnode);\n};\nfunction detachedClone(vnode, detachedParent, parentDom) {\n  if (vnode) {\n    if (vnode.__c && vnode.__c.__H) {\n      vnode.__c.__H.__.forEach(function (effect) {\n        if (typeof effect.__c == 'function') effect.__c();\n      });\n      vnode.__c.__H = null;\n    }\n    vnode = assign({}, vnode);\n    if (vnode.__c != null) {\n      if (vnode.__c.__P === parentDom) {\n        vnode.__c.__P = detachedParent;\n      }\n      vnode.__c = null;\n    }\n    vnode.__k = vnode.__k && vnode.__k.map(function (child) {\n      return detachedClone(child, detachedParent, parentDom);\n    });\n  }\n  return vnode;\n}\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n  if (vnode && originalParent) {\n    vnode.__v = null;\n    vnode.__k = vnode.__k && vnode.__k.map(function (child) {\n      return removeOriginal(child, detachedParent, originalParent);\n    });\n    if (vnode.__c) {\n      if (vnode.__c.__P === detachedParent) {\n        if (vnode.__e) {\n          originalParent.appendChild(vnode.__e);\n        }\n        vnode.__c.__e = true;\n        vnode.__c.__P = originalParent;\n      }\n    }\n  }\n  return vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nfunction Suspense() {\n  // we do not call super here to golf some bytes...\n  this.__u = 0;\n  this._suspenders = null;\n  this.__b = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype.__c = function (promise, suspendingVNode) {\n  var suspendingComponent = suspendingVNode.__c;\n\n  /** @type {import('./internal').SuspenseComponent} */\n  var c = this;\n  if (c._suspenders == null) {\n    c._suspenders = [];\n  }\n  c._suspenders.push(suspendingComponent);\n  var resolve = suspended(c.__v);\n  var resolved = false;\n  var onResolved = function onResolved() {\n    if (resolved) return;\n    resolved = true;\n    suspendingComponent.__R = null;\n    if (resolve) {\n      resolve(onSuspensionComplete);\n    } else {\n      onSuspensionComplete();\n    }\n  };\n  suspendingComponent.__R = onResolved;\n  var onSuspensionComplete = function onSuspensionComplete() {\n    if (! --c.__u) {\n      // If the suspension was during hydration we don't need to restore the\n      // suspended children into the _children array\n      if (c.state.__a) {\n        var suspendedVNode = c.state.__a;\n        c.__v.__k[0] = removeOriginal(suspendedVNode, suspendedVNode.__c.__P, suspendedVNode.__c.__O);\n      }\n      c.setState({\n        __a: c.__b = null\n      });\n      var _suspended;\n      while (_suspended = c._suspenders.pop()) {\n        _suspended.forceUpdate();\n      }\n    }\n  };\n\n  /**\n   * We do not set `suspended: true` during hydration because we want the actual markup\n   * to remain on screen and hydrate it when the suspense actually gets resolved.\n   * While in non-hydration cases the usual fallback -> component flow would occour.\n   */\n  if (!c.__u++ && !(suspendingVNode.__u & MODE_HYDRATE)) {\n    c.setState({\n      __a: c.__b = c.__v.__k[0]\n    });\n  }\n  promise.then(onResolved, onResolved);\n};\nSuspense.prototype.componentWillUnmount = function () {\n  this._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n  if (this.__b) {\n    // When the Suspense's _vnode was created by a call to createVNode\n    // (i.e. due to a setState further up in the tree)\n    // it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n    if (this.__v.__k) {\n      var detachedParent = options.document.createElement('div');\n      var detachedComponent = this.__v.__k[0].__c;\n      this.__v.__k[0] = detachedClone(this.__b, detachedParent, detachedComponent.__O = detachedComponent.__P);\n    }\n    this.__b = null;\n  }\n\n  // Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n  /** @type {import('./internal').VNode} */\n  var fallback = state.__a && createElement(Fragment, null, props.fallback);\n  if (fallback) fallback.__u &= ~MODE_HYDRATE;\n  return [createElement(Fragment, null, state.__a ? null : props.children), fallback];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nfunction suspended(vnode) {\n  /** @type {import('./internal').Component} */\n  var component = vnode.__.__c;\n  return component && component.__a && component.__a(vnode);\n}\nfunction lazy(loader) {\n  var prom;\n  var component;\n  var error;\n  function Lazy(props) {\n    if (!prom) {\n      prom = loader();\n      prom.then(function (exports) {\n        component = exports.default || exports;\n      }, function (e) {\n        error = e;\n      });\n    }\n    if (error) {\n      throw error;\n    }\n    if (!component) {\n      throw prom;\n    }\n    return createElement(component, props);\n  }\n  Lazy.displayName = 'Lazy';\n  Lazy.__f = true;\n  return Lazy;\n}\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nvar SUSPENDED_COUNT = 0;\nvar RESOLVED_COUNT = 1;\nvar NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nfunction SuspenseList() {\n  this._next = null;\n  this._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nvar resolve = function resolve(list, child, node) {\n  if (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n    // The number a child (or any of its descendants) has been suspended\n    // matches the number of times it's been resolved. Therefore we\n    // mark the child as completely resolved by deleting it from ._map.\n    // This is used to figure out when *all* children have been completely\n    // resolved when revealOrder is 'together'.\n    list._map.delete(child);\n  }\n\n  // If revealOrder is falsy then we can do an early exit, as the\n  // callbacks won't get queued in the node anyway.\n  // If revealOrder is 'together' then also do an early exit\n  // if all suspended descendants have not yet been resolved.\n  if (!list.props.revealOrder || list.props.revealOrder[0] === 't' && list._map.size) {\n    return;\n  }\n\n  // Walk the currently suspended children in order, calling their\n  // stored callbacks on the way. Stop if we encounter a child that\n  // has not been completely resolved yet.\n  node = list._next;\n  while (node) {\n    while (node.length > 3) {\n      node.pop()();\n    }\n    if (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n      break;\n    }\n    list._next = node = node[NEXT_NODE];\n  }\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\nSuspenseList.prototype.__a = function (child) {\n  var list = this;\n  var delegated = suspended(list.__v);\n  var node = list._map.get(child);\n  node[SUSPENDED_COUNT]++;\n  return function (unsuspend) {\n    var wrappedUnsuspend = function wrappedUnsuspend() {\n      if (!list.props.revealOrder) {\n        // Special case the undefined (falsy) revealOrder, as there\n        // is no need to coordinate a specific order or unsuspends.\n        unsuspend();\n      } else {\n        node.push(unsuspend);\n        resolve(list, child, node);\n      }\n    };\n    if (delegated) {\n      delegated(wrappedUnsuspend);\n    } else {\n      wrappedUnsuspend();\n    }\n  };\n};\nSuspenseList.prototype.render = function (props) {\n  this._next = null;\n  this._map = new Map();\n  var children = toChildArray(props.children);\n  if (props.revealOrder && props.revealOrder[0] === 'b') {\n    // If order === 'backwards' (or, well, anything starting with a 'b')\n    // then flip the child list around so that the last child will be\n    // the first in the linked list.\n    children.reverse();\n  }\n  // Build the linked list. Iterate through the children in reverse order\n  // so that `_next` points to the first linked list node to be resolved.\n  for (var i = children.length; i--;) {\n    // Create a new linked list node as an array of form:\n    // \t[suspended_count, resolved_count, next_node]\n    // where suspended_count and resolved_count are numeric counters for\n    // keeping track how many times a node has been suspended and resolved.\n    //\n    // Note that suspended_count starts from 1 instead of 0, so we can block\n    // processing callbacks until componentDidMount has been called. In a sense\n    // node is suspended at least until componentDidMount gets called!\n    //\n    // Pending callbacks are added to the end of the node:\n    // \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n    this._map.set(children[i], this._next = [1, 0, this._next]);\n  }\n  return props.children;\n};\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function () {\n  var _this = this;\n  // Iterate through all children after mounting for two reasons:\n  // 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n  //    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n  //    The nodes can now be completely consumed from the linked list.\n  // 2. Handle nodes that might have gotten resolved between render and\n  //    componentDidMount.\n  this._map.forEach(function (node, child) {\n    resolve(_this, child, node);\n  });\n};\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n  this.getChildContext = function () {\n    return props.context;\n  };\n  return props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n  var _this = this;\n  var container = props._container;\n  _this.componentWillUnmount = function () {\n    render$1(null, _this._temp);\n    _this._temp = null;\n    _this._container = null;\n  };\n\n  // When we change container we should clear our old container and\n  // indicate a new mount.\n  if (_this._container && _this._container !== container) {\n    _this.componentWillUnmount();\n  }\n  if (!_this._temp) {\n    _this._container = container;\n\n    // Create a fake DOM parent node that manages a subset of `container`'s children:\n    _this._temp = {\n      nodeType: 1,\n      parentNode: container,\n      childNodes: [],\n      contains: function contains() {\n        return true;\n      },\n      appendChild: function appendChild(child) {\n        this.childNodes.push(child);\n        _this._container.appendChild(child);\n      },\n      insertBefore: function insertBefore(child, before) {\n        this.childNodes.push(child);\n        _this._container.appendChild(child);\n      },\n      removeChild: function removeChild(child) {\n        this.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n        _this._container.removeChild(child);\n      }\n    };\n  }\n\n  // Render our wrapping element into temp.\n  render$1(createElement(ContextProvider, {\n    context: _this.context\n  }, props.__v), _this._temp);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nfunction createPortal(vnode, container) {\n  var el = createElement(Portal, {\n    __v: vnode,\n    _container: container\n  });\n  el.containerInfo = container;\n  return el;\n}\n\nvar REACT_ELEMENT_TYPE = typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\nvar oldVNodeHook = options.vnode;\noptions.vnode = function (vnode) {\n  vnode.$$typeof = REACT_ELEMENT_TYPE;\n  if (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n['componentWillMount', 'componentWillReceiveProps', 'componentWillUpdate'].forEach(function (key) {\n  Object.defineProperty(Component.prototype, key, {\n    configurable: true,\n    get: function get() {\n      return this['UNSAFE_' + key];\n    },\n    set: function set(v) {\n      Object.defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        value: v\n      });\n    }\n  });\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nfunction render(vnode, parent, callback) {\n  // React destroys any existing DOM nodes, see #1727\n  // ...but only on the first render, see #1828\n  if (parent.__k == null) {\n    parent.textContent = '';\n  }\n  render$1(vnode, parent);\n  if (typeof callback == 'function') callback();\n  return vnode ? vnode.__c : null;\n}\nfunction hydrate(vnode, parent, callback) {\n  hydrate$1(vnode, parent);\n  if (typeof callback == 'function') callback();\n  return vnode ? vnode.__c : null;\n}\nvar oldEventHook = options.event;\noptions.event = function (e) {\n  if (oldEventHook) e = oldEventHook(e);\n  e.persist = empty;\n  e.isPropagationStopped = isPropagationStopped;\n  e.isDefaultPrevented = isDefaultPrevented;\n  return e.nativeEvent = e;\n};\nfunction empty() {}\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nvar __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n  ReactCurrentDispatcher: {\n    current: {\n      useCallback: useCallback,\n      useContext: useContext,\n      useDebugValue: useDebugValue,\n      useDeferredValue: useDeferredValue,\n      useEffect: useEffect,\n      useId: useId,\n      useImperativeHandle: useImperativeHandle,\n      useInsertionEffect: useInsertionEffect,\n      useLayoutEffect: useLayoutEffect,\n      useMemo: useMemo,\n      // useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n      useReducer: useReducer,\n      useRef: useRef,\n      useState: useState,\n      useSyncExternalStore: useSyncExternalStore,\n      useTransition: useTransition\n    }\n  }\n};\n\nvar version = '18.3.1'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n  return createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n  return !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n  return isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n  return !!element && !!element.displayName && (typeof element.displayName === 'string' || element.displayName instanceof String) && element.displayName.startsWith('Memo(');\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n  if (!isValidElement(element)) return element;\n  return cloneElement$1.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n  if (container.__k) {\n    render$1(null, container);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n  return component && (component.base || component.nodeType === 1 && component) || null;\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nvar unstable_batchedUpdates = function unstable_batchedUpdates(callback, arg) {\n  return callback(arg);\n};\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nvar flushSync = function flushSync(callback, arg) {\n  return callback(arg);\n};\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nvar StrictMode = Fragment;\nfunction startTransition(cb) {\n  cb();\n}\nfunction useDeferredValue(val) {\n  return val;\n}\nfunction useTransition() {\n  return [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nvar useInsertionEffect = useLayoutEffect;\n\n// compat to react-is\nvar isElement = isValidElement;\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nfunction useSyncExternalStore(subscribe, getSnapshot) {\n  var value = getSnapshot();\n\n  /**\n   * @typedef {{ _instance: Store }} StoreRef\n   * @type {[StoreRef, (store: StoreRef) => void]}\n   */\n  var _useState = useState({\n      _instance: {\n        __: value,\n        _getSnapshot: getSnapshot\n      }\n    }),\n    _instance = _useState[0]._instance,\n    forceUpdate = _useState[1];\n  useLayoutEffect(function () {\n    _instance.__ = value;\n    _instance._getSnapshot = getSnapshot;\n    if (didSnapshotChange(_instance)) {\n      forceUpdate({\n        _instance: _instance\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    if (didSnapshotChange(_instance)) {\n      forceUpdate({\n        _instance: _instance\n      });\n    }\n    return subscribe(function () {\n      if (didSnapshotChange(_instance)) {\n        forceUpdate({\n          _instance: _instance\n        });\n      }\n    });\n  }, [subscribe]);\n  return value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n  var latestGetSnapshot = inst._getSnapshot;\n  var prevValue = inst.__;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\n// React copies the named exports to the default one.\nvar index = {\n  useState: useState,\n  useId: useId,\n  useReducer: useReducer,\n  useEffect: useEffect,\n  useLayoutEffect: useLayoutEffect,\n  useInsertionEffect: useInsertionEffect,\n  useTransition: useTransition,\n  useDeferredValue: useDeferredValue,\n  useSyncExternalStore: useSyncExternalStore,\n  startTransition: startTransition,\n  useRef: useRef,\n  useImperativeHandle: useImperativeHandle,\n  useMemo: useMemo,\n  useCallback: useCallback,\n  useContext: useContext,\n  useDebugValue: useDebugValue,\n  version: version,\n  Children: Children,\n  render: render,\n  hydrate: hydrate,\n  unmountComponentAtNode: unmountComponentAtNode,\n  createPortal: createPortal,\n  createElement: createElement,\n  createContext: createContext,\n  createFactory: createFactory,\n  cloneElement: cloneElement,\n  createRef: createRef,\n  Fragment: Fragment,\n  isValidElement: isValidElement,\n  isElement: isElement,\n  isFragment: isFragment,\n  isMemo: isMemo,\n  findDOMNode: findDOMNode,\n  Component: Component,\n  PureComponent: PureComponent,\n  memo: memo,\n  forwardRef: forwardRef,\n  flushSync: flushSync,\n  unstable_batchedUpdates: unstable_batchedUpdates,\n  StrictMode: StrictMode,\n  Suspense: Suspense,\n  SuspenseList: SuspenseList,\n  lazy: lazy,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\nexport { Children, PureComponent, StrictMode, Suspense, SuspenseList, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, cloneElement, createFactory, createPortal, index as default, findDOMNode, flushSync, forwardRef, hydrate, isElement, isFragment, isMemo, isValidElement, lazy, memo, render, startTransition, unmountComponentAtNode, unstable_batchedUpdates, useDeferredValue, useInsertionEffect, useSyncExternalStore, useTransition, version };\n//# sourceMappingURL=compat.module.js.map\n","import { nextCommitTaskId } from '../lifecycle/patch/commit.js';\nimport { SnapshotInstance, backgroundSnapshotInstanceManager } from '../snapshot.js';\nimport { workletUnRef } from './workletRef.js';\nlet globalRefPatch = {};\nconst globalRefsToRemove = /* @__PURE__ */ new Map();\nconst globalRefsToSet = /* @__PURE__ */ new Map();\nlet nextRefId = 1;\nfunction unref(snapshot, recursive) {\n    snapshot.__ref_set?.forEach(v => {\n        globalRefPatch[v] = null;\n    });\n    snapshot.__ref_set?.clear();\n    snapshot.__worklet_ref_set?.forEach(v => {\n        if (v) {\n            workletUnRef(v);\n        }\n    });\n    snapshot.__worklet_ref_set?.clear();\n    if (recursive) {\n        snapshot.childNodes.forEach(it => {\n            unref(it, recursive);\n        });\n    }\n}\nfunction applyRef(ref, value) {\n    // TODO: ref: exceptions thrown in user functions should be able to be caught by an Error Boundary\n    if (typeof ref == 'function') {\n        const hasRefUnmount = typeof ref._unmount == 'function';\n        if (hasRefUnmount) {\n            // @ts-ignore TS doesn't like moving narrowing checks into variables\n            ref._unmount();\n        }\n        if (!hasRefUnmount || value != null) {\n            // Store the cleanup function on the function\n            // instance object itself to avoid shape\n            // transitioning vnode\n            ref._unmount = ref(value);\n        }\n    }\n    else\n        ref.current = value;\n}\nfunction updateBackgroundRefs(commitId) {\n    const oldRefMap = globalRefsToRemove.get(commitId);\n    if (oldRefMap) {\n        globalRefsToRemove.delete(commitId);\n        for (const ref of oldRefMap.values()) {\n            applyRef(ref, null);\n        }\n    }\n    const newRefMap = globalRefsToSet.get(commitId);\n    if (newRefMap) {\n        globalRefsToSet.delete(commitId);\n        for (const sign in newRefMap) {\n            const ref = backgroundSnapshotInstanceManager.getValueBySign(sign);\n            if (ref) {\n                // TODO: ref: support __REF_FIRE_IMMEDIATELY__\n                const v = newRefMap[sign] && lynx.createSelectorQuery().selectUniqueID(newRefMap[sign]);\n                applyRef(ref, v);\n            }\n        }\n    }\n}\nfunction updateRef(snapshot, expIndex, oldValue, elementIndex, spreadKey) {\n    const value = snapshot.__values[expIndex];\n    let ref;\n    if (!value) {\n        ref = undefined;\n    }\n    else if (typeof value === 'string') {\n        ref = value;\n    }\n    else {\n        ref = `${snapshot.__id}:${expIndex}:${spreadKey}`;\n    }\n    snapshot.__values[expIndex] = ref;\n    if (snapshot.__elements && ref) {\n        __SetAttribute(snapshot.__elements[elementIndex], 'has-react-ref', true);\n        const uid = __GetElementUniqueID(snapshot.__elements[elementIndex]);\n        globalRefPatch[ref] = uid;\n        snapshot.__ref_set ??= new Set();\n        snapshot.__ref_set.add(ref);\n    }\n    if (oldValue !== ref) {\n        snapshot.__ref_set?.delete(oldValue);\n    }\n}\nfunction takeGlobalRefPatchMap() {\n    const patch = globalRefPatch;\n    globalRefPatch = {};\n    return patch;\n}\nfunction transformRef(ref) {\n    if (ref === undefined || ref === null) {\n        return ref;\n    }\n    if (typeof ref === 'function' || (typeof ref === 'object' && 'current' in ref)) {\n        if ('__ref' in ref) {\n            return ref;\n        }\n        return Object.defineProperty(ref, '__ref', { value: nextRefId++ });\n    }\n    throw new Error(`Elements' \"ref\" property should be a function, or an object created `\n        + `by createRef(), but got [${typeof ref}] instead`);\n}\nfunction markRefToRemove(sign, ref) {\n    if (!ref) {\n        return;\n    }\n    let oldRefs = globalRefsToRemove.get(nextCommitTaskId);\n    if (!oldRefs) {\n        oldRefs = new Map();\n        globalRefsToRemove.set(nextCommitTaskId, oldRefs);\n    }\n    oldRefs.set(sign, ref);\n}\nexport { updateRef, takeGlobalRefPatchMap, updateBackgroundRefs, unref, transformRef, globalRefsToRemove, globalRefsToSet, markRefToRemove, };\n//# sourceMappingURL=ref.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { runWorkletCtx, updateWorkletRef as update, } from '@lynx-js/react/worklet-runtime/bindings';\nimport { SnapshotInstance } from '../snapshot.js';\nfunction workletUnRef(value) {\n    if ('_wvid' in value) {\n        update(value, null);\n    }\n    else if ('_wkltId' in value) {\n        if (typeof value._unmount == 'function') {\n            value._unmount();\n        }\n        else {\n            runWorkletCtx(value, [null]);\n        }\n    }\n}\nfunction updateWorkletRef(snapshot, expIndex, oldValue, elementIndex, _workletType) {\n    if (!snapshot.__elements) {\n        return;\n    }\n    if (oldValue && snapshot.__worklet_ref_set?.has(oldValue)) {\n        workletUnRef(oldValue);\n        snapshot.__worklet_ref_set?.delete(oldValue);\n    }\n    const value = snapshot.__values[expIndex];\n    if (value === null || value === undefined) {\n        // do nothing\n    }\n    else if (value._wvid) {\n        update(value, snapshot.__elements[elementIndex]);\n    }\n    else if (value._wkltId) {\n        // @ts-ignore\n        value._unmount = runWorkletCtx(value, [{ elementRefptr: snapshot.__elements[elementIndex] }]);\n    }\n    else if (value._type === '__LEPUS__' || value._lepusWorkletHash) {\n        // During the initial render, we will not update the WorkletRef because the background thread is not ready yet.\n    }\n    else {\n        throw new Error('MainThreadRef: main-thread:ref must be of type MainThreadRef or main-thread function.');\n    }\n    if (value) {\n        snapshot.__worklet_ref_set ??= new Set();\n        snapshot.__worklet_ref_set.add(value);\n    }\n    // Add an arbitrary attribute to avoid this element being layout-only\n    __SetAttribute(snapshot.__elements[elementIndex], 'has-react-ref', true);\n}\nexport { updateWorkletRef, workletUnRef };\n//# sourceMappingURL=workletRef.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\n/**\n * Register a worklet function to the `jsFunctionLifecycleManager`.\n * This function mast be called when a worklet context is updated.\n *\n * @param worklet - The worklet to be updated\n * @param element - The element associated with the worklet\n * @internal\n */\nfunction onWorkletCtxUpdate(worklet, element) {\n    globalThis.lynxWorkletImpl?._jsFunctionLifecycleManager?.addRef(worklet._execId, worklet);\n    globalThis.lynxWorkletImpl?._eventDelayImpl.runDelayedWorklet(worklet, element);\n}\n/**\n * Executes the worklet ctx.\n * @param worklet - The Worklet ctx to run.\n * @param params - An array as parameters of the worklet run.\n */\nfunction runWorkletCtx(worklet, params) {\n    return globalThis.runWorklet?.(worklet, params);\n}\n/**\n * Save an element to a `WorkletRef`.\n *\n * @param workletRef - The `WorkletRef` to be updated.\n * @param element - The element.\n * @internal\n */\nfunction updateWorkletRef(workletRef, element) {\n    globalThis.lynxWorkletImpl?._refImpl.updateWorkletRef(workletRef, element);\n}\n/**\n * Update the initial value of the `WorkletRef`.\n *\n * @param patch - An array containing the index and new value of the worklet value.\n */\nfunction updateWorkletRefInitValueChanges(patch) {\n    if (patch) {\n        globalThis.lynxWorkletImpl?._refImpl.updateWorkletRefInitValueChanges(patch);\n    }\n}\n/**\n * Clear all delayed worklets to run.\n *\n * @internal\n */\nfunction clearDelayedWorklets() {\n    globalThis.lynxWorkletImpl?._eventDelayImpl.clearDelayedWorklets();\n}\n/**\n * Register a worklet.\n *\n * @internal\n */\nfunction registerWorklet(type, id, worklet) {\n    globalThis.registerWorklet(type, id, worklet);\n}\nexport { onWorkletCtxUpdate, runWorkletCtx, updateWorkletRef, updateWorkletRefInitValueChanges, clearDelayedWorklets, registerWorklet, };\n//# sourceMappingURL=bindings.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport function isDirectOrDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a == 'object' && a !== null && typeof b == 'object' && b !== null && JSON.stringify(a) === JSON.stringify(b)) {\n        return true;\n    }\n    return false;\n}\nexport function isEmptyObject(obj) {\n    for (var _ in obj)\n        return false;\n    return true;\n}\nexport function isSdkVersionGt(major, minor) {\n    const lynxSdkVersion = SystemInfo.lynxSdkVersion || '1.0';\n    const version = lynxSdkVersion.split('.');\n    return Number(version[0]) > major || (Number(version[0]) == major && Number(version[1]) > minor);\n}\nexport function pick(obj, keys) {\n    const result = {};\n    for (const key of keys) {\n        if (key in obj) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=utils.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { __pendingListUpdates, componentAtIndexFactory, enqueueComponentFactory } from './list.js';\nimport { unref } from './snapshot/ref.js';\nimport { DynamicPartType, SnapshotInstance } from './snapshot.js';\nimport { isEmptyObject } from './utils.js';\nexport function isEmptyDiffResult(diffResult) {\n    const hasChanged = !isEmptyObject(diffResult.i)\n        || !isEmptyObject(diffResult.m) || diffResult.r.length > 0;\n    return !hasChanged;\n}\nexport function diffArrayLepus(before, after, isSameType, onDiffChildren) {\n    let lastPlacedIndex = 0;\n    const result = {\n        $$diff: true,\n        i: {},\n        r: [],\n        m: {},\n    };\n    const beforeMap = {};\n    for (let i = 0; i < before.length; i++) {\n        const node = before[i];\n        (beforeMap[node.type] ??= new Set()).add([node, i]);\n    }\n    for (let i = 0; i < after.length; i++) {\n        const afterNode = after[i];\n        const beforeNodes = beforeMap[afterNode.type];\n        let beforeNode;\n        if (beforeNodes\n            && beforeNodes.size > 0\n            // @ts-expect-error TS does not know about iterator :)\n            && (([beforeNode] = beforeNodes), beforeNode)\n            && isSameType(beforeNode[0], afterNode)) {\n            // Reuse old node\n            beforeNodes.delete(beforeNode);\n            const oldIndex = beforeNode[1];\n            onDiffChildren(beforeNode[0], afterNode, oldIndex, i);\n            if (oldIndex < lastPlacedIndex) {\n                result.m[oldIndex] = i;\n                continue;\n            }\n            else {\n                lastPlacedIndex = oldIndex;\n            }\n        }\n        else {\n            // Create new node\n            result.i[i] = afterNode;\n        }\n    }\n    // Delete\n    for (const k in beforeMap) {\n        for (const [, i] of beforeMap[k]) {\n            result.r.push(i);\n        }\n    }\n    return result;\n}\n// export function diffIterableLepus<A extends Typed, B extends Typed>(\n//   before: A[],\n//   after: Iterable<B>,\n//   isSameType: (a: A, b: B) => boolean,\n//   onDiffChildren: (a: A, b: B) => void\n// ): DiffResult<B> {\n//   let returnResult = EMPTY_DIFF_RESULT as DiffResult<B>;\n//   let lastPlacedIndex = 0;\n//   const result: DiffResult<B> = {\n//     $$diff: true,\n//     i: {},\n//     r: [],\n//     m: {},\n//   };\n//   const beforeMap: Record<string, Set<[A, number]>> = {};\n//   for (let i = 0; i < before.length; i++) {\n//     let node = before[i];\n//     (beforeMap[node.type] ??= new Set()).add([node, i]);\n//   }\n//   let i = 0;\n//   for (const afterNode of after) {\n//     const beforeNodes = beforeMap[afterNode.type];\n//     let beforeNode: [A, number];\n//     if (beforeNodes && (([beforeNode] = beforeNodes), beforeNode) && isSameType(beforeNode[0], afterNode)) {\n//       // Reuse old node\n//       beforeNodes.delete(beforeNode);\n//       const oldIndex = beforeNode[1];\n//       onDiffChildren(beforeNode[0], afterNode);\n//       if (oldIndex < lastPlacedIndex) {\n//         result.m[oldIndex] = i;\n//         returnResult = result;\n//         i++;\n//         continue;\n//       } else {\n//         lastPlacedIndex = oldIndex;\n//       }\n//     } else {\n//       // Create new node\n//       result.i[i] = afterNode;\n//       returnResult = result;\n//     }\n//     i++;\n//   }\n//   // delete\n//   for (const k in beforeMap) {\n//     for (const [, i] of beforeMap[k]) {\n//       result.r.push(i);\n//       returnResult = result;\n//     }\n//   }\n//   return result;\n// }\nexport function diffArrayAction(before, diffResult, onInsert, onRemove, onMove) {\n    if (isEmptyDiffResult(diffResult)) {\n        return before;\n    }\n    const deleteSet = new Set(diffResult.r);\n    const { i: insertMap, m: placementMap } = diffResult;\n    const moveTempMap = new Map();\n    let old;\n    let k = 0;\n    old = before[k];\n    // let current: T | null | undefined = null;\n    const result = [];\n    let i = 0; // index of the old list\n    let j = 0; // index of the new list\n    let remain = Object.keys(insertMap).length;\n    while (old || remain > 0) {\n        let keep = false;\n        if (old && deleteSet.has(j)) {\n            // delete\n            onRemove(old);\n        }\n        else if (old && placementMap[j] !== undefined) {\n            // save node to re-use\n            moveTempMap.set(placementMap[j], old);\n            remain++;\n        }\n        else {\n            // insert node\n            let newNode = old;\n            if (moveTempMap.has(i)) {\n                // insert re-used node\n                newNode = moveTempMap.get(i);\n                keep = true;\n                onMove(newNode, old);\n                remain--;\n            }\n            else if (insertMap[i] !== undefined) {\n                // insert new node\n                newNode = onInsert(insertMap[i], old);\n                keep = true;\n                remain--;\n            }\n            result.push(newNode);\n            i++;\n        }\n        if (old && !keep) {\n            old = before[++k];\n            j++;\n        }\n    }\n    return result;\n}\nexport function hydrate(before, after, options) {\n    after.__elements = before.__elements;\n    after.__element_root = before.__element_root;\n    if (!(options?.skipUnRef)) {\n        unref(before, false);\n    }\n    let swap;\n    if (swap = options?.swap) {\n        swap[before.__id] = after.__id;\n    }\n    after.__values?.forEach((value, index) => {\n        const old = before.__values[index];\n        if (value !== old) {\n            after.__values[index] = old;\n            after.setAttribute(index, value);\n        }\n    });\n    const { slot } = after.__snapshot_def;\n    if (!slot) {\n        return;\n    }\n    const beforeChildNodes = before.childNodes;\n    const afterChildNodes = after.childNodes;\n    slot.forEach(([type, elementIndex], index) => {\n        switch (type) {\n            case DynamicPartType.Slot:\n            case DynamicPartType.MultiChildren: {\n                // TODO: the following null assertions are not 100% safe\n                const v1 = beforeChildNodes[index];\n                const v2 = afterChildNodes[index];\n                hydrate(v1, v2, options);\n                break;\n            }\n            case DynamicPartType.Children: {\n                const diffResult = diffArrayLepus(beforeChildNodes, afterChildNodes, (a, b) => a.type === b.type, (a, b) => {\n                    hydrate(a, b, options);\n                });\n                diffArrayAction(beforeChildNodes, diffResult, (node, target) => {\n                    node.ensureElements();\n                    __InsertElementBefore(before.__elements[elementIndex], node.__element_root, target?.__element_root);\n                    return node;\n                }, node => {\n                    __RemoveElement(before.__elements[elementIndex], node.__element_root);\n                }, (node, target) => {\n                    __RemoveElement(before.__elements[elementIndex], node.__element_root);\n                    __InsertElementBefore(before.__elements[elementIndex], node.__element_root, target?.__element_root);\n                });\n                break;\n            }\n            case DynamicPartType.ListChildren: {\n                const removals = [];\n                const insertions = [];\n                const updateAction = [];\n                const diffResult = diffArrayLepus(beforeChildNodes, afterChildNodes, (a, b) => a.type === b.type, (a, b, oldIndex, newIndex) => {\n                    if (JSON.stringify(a.__listItemPlatformInfo)\n                        !== JSON.stringify(b.__listItemPlatformInfo)) {\n                        updateAction.push({\n                            ...b.__listItemPlatformInfo,\n                            from: newIndex,\n                            to: newIndex,\n                            // no flush\n                            flush: false,\n                        });\n                    }\n                    // Mark list-item which is rendered (has `__elements`) as DELETE\n                    // so list platform will call `enqueueComponent` on it\n                    // and will call `componentAtIndex` on the inserted one\n                    // In this way:\n                    //  1. we make sure `<list/>` for hydrate is like a leaf node\n                    //  2. we avoid hydrate so modifying recycleMap can be avoid\n                    //  3. the delete list-item is recycled for later use, so no waste\n                    if (a.__elements) {\n                        removals.push(oldIndex);\n                        insertions.push(newIndex);\n                    }\n                });\n                for (const i of diffResult.r) {\n                    removals.push(i);\n                }\n                for (const i in diffResult.i) {\n                    insertions.push(Number(i));\n                }\n                for (const i in diffResult.m) {\n                    removals.push(Number(i));\n                    insertions.push(diffResult.m[i]);\n                }\n                insertions.sort((a, b) => a - b);\n                removals.sort((a, b) => a - b);\n                const info = {\n                    insertAction: insertions.map((it) => ({\n                        position: it,\n                        type: afterChildNodes[it].type,\n                        ...afterChildNodes[it].__listItemPlatformInfo,\n                    })),\n                    removeAction: removals,\n                    updateAction,\n                };\n                const listElement = before.__elements[elementIndex];\n                __SetAttribute(listElement, 'update-list-info', info);\n                __UpdateListCallbacks(listElement, componentAtIndexFactory(afterChildNodes), enqueueComponentFactory());\n                // The `before` & `after` target to the same list element, so we need to\n                // avoid the newly created list's (behind snapshot instance `after`) \"update-list-info\" being recorded.\n                delete __pendingListUpdates.values[after.__id];\n            }\n        }\n    });\n}\n//# sourceMappingURL=hydrate.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { hydrate } from './hydrate.js';\nimport { commitMainThreadPatchUpdate } from './lifecycle/patch/updateMainThread.js';\n// class ListUpdateInfoDiffing implements ListUpdateInfo {\n//   private oldChildNodes: SnapshotInstance[];\n//   constructor(private list: SnapshotInstance) {\n//     this.oldChildNodes = list.childNodes;\n//   }\n//   flush(): void {\n//     Object.defineProperty(SnapshotInstance.prototype, \"key\", {\n//       get: function () {\n//         return this.values[0][\"item-key\"];\n//       },\n//     });\n//   }\n//   onInsertBefore(newNode: SnapshotInstance, existingNode?: SnapshotInstance | undefined): void {}\n//   onRemoveChild(child: SnapshotInstance): void {}\n//   onSetAttribute(child: SnapshotInstance, attr: any): void {\n//     throw new Error(\"Method not implemented.\");\n//   }\n// }\nexport class ListUpdateInfoRecording {\n    list;\n    constructor(list) {\n        this.list = list;\n        this.oldChildNodes = list.childNodes;\n        // this.oldChildNodesSet = new Set(this.oldChildNodes);\n    }\n    // private __commitAndReset() {\n    //   (this.__pendingAttributes ??= []).push(this.__toAttribute());\n    //   this.oldChildNodes = this.list.childNodes;\n    //   this.oldChildNodesSet = new Set(this.oldChildNodes);\n    //   this.removeChild1.clear();\n    //   this.removeChild2.clear();\n    //   this.insertBefore.clear();\n    //   this.appendChild.length = 0;\n    //   this.platformInfoUpdate.clear();\n    // }\n    flush() {\n        const elementIndex = this.list.__snapshot_def.slot[0][1];\n        const listElement = this.list.__elements[elementIndex];\n        // this.__pendingAttributes?.forEach(pendingAttribute => {\n        //   __SetAttribute(listElement, \"update-list-info\", pendingAttribute);\n        //   __FlushElementTree(listElement);\n        // });\n        __SetAttribute(listElement, 'update-list-info', this.__toAttribute());\n        __UpdateListCallbacks(listElement, componentAtIndexFactory(this.list.childNodes), enqueueComponentFactory());\n    }\n    oldChildNodes;\n    // private oldChildNodesSet: Set<SnapshotInstance>;\n    removeChild = new Set();\n    insertBefore = new Map(); // insert V before K\n    appendChild = [];\n    platformInfoUpdate = new Map();\n    onInsertBefore(newNode, existingNode) {\n        // @ts-ignore\n        if (newNode.__parent) {\n            // if (!this.oldChildNodesSet.has(newNode)) {\n            //   this.__commitAndReset();\n            // }\n            this.removeChild.add(newNode);\n        }\n        if (existingNode) {\n            // if (!this.oldChildNodesSet.has(existingNode)) {\n            //   this.__commitAndReset();\n            // }\n            const newChildren = this.insertBefore.get(existingNode) ?? [];\n            newChildren.push(newNode);\n            this.insertBefore.set(existingNode, newChildren);\n        }\n        else {\n            this.appendChild.push(newNode);\n        }\n    }\n    onRemoveChild(child) {\n        // if (!this.oldChildNodesSet.has(child)) {\n        //   this.__commitAndReset();\n        // }\n        this.removeChild.add(child);\n    }\n    onSetAttribute(child, attr, _oldAttr) {\n        this.platformInfoUpdate.set(child, attr);\n    }\n    __toAttribute() {\n        const { removeChild, insertBefore, appendChild, platformInfoUpdate } = this;\n        const removals = [];\n        const insertions = [];\n        const updates = [];\n        let j = 0;\n        for (let i = 0; i < this.oldChildNodes.length; i++, j++) {\n            const child = this.oldChildNodes[i];\n            if (platformInfoUpdate.has(child)) {\n                updates.push({\n                    ...platformInfoUpdate.get(child),\n                    from: +j,\n                    to: +j,\n                    // no flush\n                    flush: false,\n                    type: child.type,\n                });\n            }\n            if (insertBefore.has(child)) {\n                const children = insertBefore.get(child);\n                children.forEach(c => {\n                    insertions.push({\n                        position: j,\n                        type: c.type,\n                        ...c.__listItemPlatformInfo,\n                    });\n                    j++;\n                });\n            }\n            if (removeChild.has(child)) {\n                removals.push(i);\n                removeChild.delete(child);\n                j--;\n            }\n        }\n        for (let i = 0; i < appendChild.length; i++) {\n            const child = appendChild[i];\n            insertions.push({\n                position: j + i,\n                type: child.type,\n                ...child.__listItemPlatformInfo,\n            });\n        }\n        insertions.sort((a, b) => a.position - b.position);\n        removals.sort((a, b) => a - b);\n        if (SystemInfo.lynxSdkVersion === '2.14'\n            || SystemInfo.lynxSdkVersion === '2.15'\n            || SystemInfo.lynxSdkVersion === '2.16'\n            || SystemInfo.lynxSdkVersion === '2.17'\n            || SystemInfo.lynxSdkVersion === '2.18') {\n            const elementIndex = this.list.__snapshot_def.slot[0][1];\n            const listElement = this.list.__elements[elementIndex];\n            // `__GetAttributeByName` is avaiable since Lynx 2.14\n            if (__GetAttributeByName(listElement, 'custom-list-name') === 'list-container') {\n                // `updateAction` must be full (not incremental) when Lynx version <= 2.18 and\n                // when `custom-list-name` is `list-container` (avaiable when Lynx version >= 2.14) is true,\n                updates.length = 0;\n                this.list.childNodes.forEach((child, index) => {\n                    updates.push({\n                        ...child.__listItemPlatformInfo,\n                        from: index,\n                        to: index,\n                        // no flush\n                        flush: false,\n                        type: child.type,\n                    });\n                });\n            }\n        }\n        return {\n            insertAction: insertions,\n            removeAction: removals,\n            updateAction: updates,\n        };\n    }\n    toJSON() {\n        // if (this.__pendingAttributes) {\n        //   return [...this.__pendingAttributes, this.__toAttribute()];\n        // } else {\n        //   return [this.__toAttribute()];\n        // }\n        return [this.__toAttribute()];\n    }\n}\nexport const __pendingListUpdates = {\n    values: {},\n    clear() {\n        this.values = {};\n    },\n    flush() {\n        Object.values(this.values).forEach(update => {\n            update.flush();\n        });\n        this.clear();\n    },\n};\nexport const gSignMap = {};\nexport const gRecycleMap = {};\nexport function clearListGlobal() {\n    for (const key in gSignMap) {\n        delete gSignMap[key];\n    }\n    for (const key in gRecycleMap) {\n        delete gRecycleMap[key];\n    }\n}\nexport function componentAtIndexFactory(ctx) {\n    const componentAtIndex = (list, listID, cellIndex, operationID, enableReuseNotification) => {\n        const signMap = gSignMap[listID];\n        const recycleMap = gRecycleMap[listID];\n        if (!signMap || !recycleMap) {\n            throw new Error('componentAtIndex called on removed list');\n        }\n        const childCtx = ctx[cellIndex];\n        if (!childCtx) {\n            throw new Error('childCtx not found');\n        }\n        const platformInfo = childCtx.__listItemPlatformInfo || {};\n        const uniqID = childCtx.type + (platformInfo['reuse-identifier'] ?? '');\n        const recycleSignMap = recycleMap.get(uniqID);\n        if (childCtx.__elements) {\n            /**\n             * If this situation is encountered, there might be two cases:\n             * 1. Reusing with itself\n             *    In this case, enqueueComponent will be triggered first, followed by componentAtIndex.\n             * 2. Moving\n             *    In this case, the trigger order is uncertain; componentAtIndex might be triggered first, or enqueueComponent might be triggered first.\n             *\n             * When enqueueComponent is triggered first, there must be an item in the reuse pool with the same sign as here, which can be returned directly.\n             * When componentAtIndex is triggered first, a clone needs to be made first, then follow the logic for adding or reusing. The cloned item will enter the reuse pool in the subsequent enqueueComponent.\n             */\n            const root = childCtx.__elements[0];\n            const sign = __GetElementUniqueID(root);\n            if (recycleSignMap?.has(sign)) {\n                signMap.set(sign, childCtx);\n                recycleSignMap.delete(sign);\n                __FlushElementTree(root, { triggerLayout: true, operationID, elementID: sign, listID });\n                return sign;\n            }\n            else {\n                const newCtx = childCtx.takeElements();\n                signMap.set(sign, newCtx);\n            }\n        }\n        if (recycleSignMap && recycleSignMap.size > 0) {\n            const [first] = recycleSignMap;\n            const [sign, oldCtx] = first;\n            recycleSignMap.delete(sign);\n            hydrate(oldCtx, childCtx);\n            oldCtx.unRenderElements();\n            const root = childCtx.__element_root;\n            if (enableReuseNotification) {\n                __FlushElementTree(root, {\n                    triggerLayout: true,\n                    operationID,\n                    elementID: sign,\n                    listID,\n                    listReuseNotification: {\n                        listElement: list,\n                        itemKey: platformInfo['item-key'],\n                    },\n                });\n            }\n            else {\n                __FlushElementTree(root, {\n                    triggerLayout: true,\n                    operationID,\n                    elementID: sign,\n                    listID,\n                });\n            }\n            signMap.set(sign, childCtx);\n            commitMainThreadPatchUpdate(undefined);\n            return sign;\n        }\n        childCtx.ensureElements();\n        const root = childCtx.__element_root;\n        __AppendElement(list, root);\n        const sign = __GetElementUniqueID(root);\n        __FlushElementTree(root, {\n            triggerLayout: true,\n            operationID,\n            elementID: sign,\n            listID,\n        });\n        signMap.set(sign, childCtx);\n        commitMainThreadPatchUpdate(undefined);\n        return sign;\n    };\n    return componentAtIndex;\n}\nexport function enqueueComponentFactory() {\n    const enqueueComponent = (_, listID, sign) => {\n        const signMap = gSignMap[listID];\n        const recycleMap = gRecycleMap[listID];\n        if (!signMap || !recycleMap) {\n            throw new Error('enqueueComponent called on removed list');\n        }\n        const childCtx = signMap.get(sign);\n        if (!childCtx) {\n            return;\n        }\n        const platformInfo = childCtx.__listItemPlatformInfo || {};\n        const uniqID = childCtx.type + (platformInfo['reuse-identifier'] ?? '');\n        if (!recycleMap.has(uniqID)) {\n            recycleMap.set(uniqID, new Map());\n        }\n        recycleMap.get(uniqID).set(sign, childCtx);\n    };\n    return enqueueComponent;\n}\nexport function snapshotCreateList(pageId, _ctx, _expIndex) {\n    const signMap = new Map();\n    const recycleMap = new Map();\n    const list = __CreateList(pageId, componentAtIndexFactory([]), enqueueComponentFactory(), {});\n    const listID = __GetElementUniqueID(list);\n    gSignMap[listID] = signMap;\n    gRecycleMap[listID] = recycleMap;\n    return list;\n}\nexport function snapshotDestroyList(si) {\n    const [, elementIndex] = si.__snapshot_def.slot[0];\n    const list = si.__elements[elementIndex];\n    const listID = __GetElementUniqueID(list);\n    delete gSignMap[listID];\n    delete gRecycleMap[listID];\n}\n//# sourceMappingURL=list.js.map","import { SnapshotOperation } from './snapshotPatch.js';\nimport { SnapshotInstance, createSnapshot, snapshotInstanceManager, snapshotManager } from '../../snapshot.js';\nfunction reportCtxNotFound() {\n    lynx.reportError(new Error(`snapshotPatchApply failed: ctx not found`));\n}\nexport function snapshotPatchApply(snapshotPatch) {\n    const length = snapshotPatch.length;\n    for (let i = 0; i < length; ++i) {\n        switch (snapshotPatch[i]) {\n            case SnapshotOperation.CreateElement: {\n                const type = snapshotPatch[++i];\n                const id = snapshotPatch[++i];\n                new SnapshotInstance(type, id);\n                break;\n            }\n            case SnapshotOperation.InsertBefore: {\n                const parentId = snapshotPatch[++i];\n                const childId = snapshotPatch[++i];\n                const beforeId = snapshotPatch[++i];\n                const parent = snapshotInstanceManager.values.get(parentId);\n                const child = snapshotInstanceManager.values.get(childId);\n                const existingNode = snapshotInstanceManager.values.get(beforeId);\n                if (!parent || !child) {\n                    reportCtxNotFound();\n                }\n                else {\n                    parent.insertBefore(child, existingNode);\n                }\n                break;\n            }\n            case SnapshotOperation.RemoveChild: {\n                const parentId = snapshotPatch[++i];\n                const childId = snapshotPatch[++i];\n                const parent = snapshotInstanceManager.values.get(parentId);\n                const child = snapshotInstanceManager.values.get(childId);\n                if (!parent || !child) {\n                    reportCtxNotFound();\n                }\n                else {\n                    parent.removeChild(child);\n                }\n                break;\n            }\n            case SnapshotOperation.SetAttribute: {\n                const id = snapshotPatch[++i];\n                const dynamicPartIndex = snapshotPatch[++i];\n                const value = snapshotPatch[++i];\n                const si = snapshotInstanceManager.values.get(id);\n                if (si) {\n                    si.setAttribute(dynamicPartIndex, value);\n                }\n                else {\n                    reportCtxNotFound();\n                }\n                break;\n            }\n            case SnapshotOperation.SetAttributes: {\n                const id = snapshotPatch[++i];\n                const values = snapshotPatch[++i];\n                const si = snapshotInstanceManager.values.get(id);\n                if (si) {\n                    si.setAttribute('values', values);\n                }\n                else {\n                    reportCtxNotFound();\n                }\n                break;\n            }\n            case SnapshotOperation.DEV_ONLY_AddSnapshot: {\n                if (__DEV__) {\n                    const uniqID = snapshotPatch[++i];\n                    const create = snapshotPatch[++i];\n                    const update = snapshotPatch[++i];\n                    const slot = snapshotPatch[++i];\n                    const cssId = snapshotPatch[++i] ?? 0;\n                    const entryName = snapshotPatch[++i];\n                    if (!snapshotManager.values.has(uniqID)) {\n                        // HMR-related\n                        // Update the evaluated snapshots from JS.\n                        createSnapshot(uniqID, evaluate(create), update.map(evaluate), slot, cssId, entryName);\n                    }\n                }\n                break;\n            }\n            case SnapshotOperation.DEV_ONLY_RegisterWorklet: {\n                // HMR-related\n                if (__DEV__) {\n                    const hash = snapshotPatch[++i];\n                    const fnStr = snapshotPatch[++i];\n                    const fn = evaluate(fnStr);\n                    registerWorklet('main-thread', hash, fn);\n                }\n                break;\n            }\n        }\n    }\n}\n/**\n * Given an expression string, return the evaluated result with ReactLynx runtime injected.\n *\n * @param code - The code to be evaluated\n * @returns the evaluated expression\n */\nfunction evaluate(code) {\n    return new Function(`return ${code}`)();\n}\n//# sourceMappingURL=snapshotPatchApply.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nlet reloadVersion = 0;\nfunction getReloadVersion() {\n    return reloadVersion;\n}\nfunction increaseReloadVersion() {\n    return ++reloadVersion;\n}\nexport { getReloadVersion, increaseReloadVersion };\n//# sourceMappingURL=pass.js.map","// Copyright 2025 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { clearDelayedWorklets, updateWorkletRefInitValueChanges } from '@lynx-js/react/worklet-runtime/bindings';\nimport { snapshotPatchApply } from './snapshotPatchApply.js';\nimport { LifecycleConstant } from '../../lifecycleConstant.js';\nimport { __pendingListUpdates } from '../../list.js';\nimport { PerformanceTimingKeys, markTiming, setPipeline } from '../../lynx/performance.js';\nimport { takeGlobalRefPatchMap } from '../../snapshot/ref.js';\nimport { __page } from '../../snapshot.js';\nimport { isEmptyObject } from '../../utils.js';\nimport { getReloadVersion } from '../pass.js';\nfunction updateMainThread({ data, patchOptions }) {\n    if ((patchOptions.reloadVersion) < getReloadVersion()) {\n        return;\n    }\n    setPipeline(patchOptions.pipelineOptions);\n    markTiming(PerformanceTimingKeys.parse_changes_start);\n    const { patchList, flushOptions = {} } = JSON.parse(data);\n    markTiming(PerformanceTimingKeys.parse_changes_end);\n    markTiming(PerformanceTimingKeys.patch_changes_start);\n    for (const { snapshotPatch, workletRefInitValuePatch, id } of patchList) {\n        updateWorkletRefInitValueChanges(workletRefInitValuePatch);\n        __pendingListUpdates.clear();\n        if (snapshotPatch) {\n            snapshotPatchApply(snapshotPatch);\n        }\n        __pendingListUpdates.flush();\n        // console.debug('********** Lepus updatePatch:');\n        // printSnapshotInstance(snapshotInstanceManager.values.get(-1)!);\n        commitMainThreadPatchUpdate(id);\n    }\n    markTiming(PerformanceTimingKeys.patch_changes_end);\n    if (patchOptions.isHydration) {\n        clearDelayedWorklets();\n    }\n    if (patchOptions.pipelineOptions) {\n        flushOptions.pipelineOptions = patchOptions.pipelineOptions;\n    }\n    // TODO: triggerDataUpdated?\n    __FlushElementTree(__page, flushOptions);\n}\nfunction injectUpdateMainThread() {\n    Object.assign(globalThis, { [LifecycleConstant.patchUpdate]: updateMainThread });\n}\nfunction commitMainThreadPatchUpdate(commitTaskId) {\n    const refPatch = takeGlobalRefPatchMap();\n    if (!isEmptyObject(refPatch)) {\n        __OnLifecycleEvent([LifecycleConstant.ref, { commitTaskId, refPatch: JSON.stringify(refPatch) }]);\n    }\n}\n/**\n * @internal\n */\nexport { commitMainThreadPatchUpdate, injectUpdateMainThread };\n//# sourceMappingURL=updateMainThread.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport const DIFF = '__b';\nexport const RENDER = '__r';\nexport const DIFFED = 'diffed';\nexport const COMMIT = '__c';\nexport const SKIP_EFFECTS = '__s';\nexport const CATCH_ERROR = '__e';\n// VNode properties\nexport const COMPONENT = '__c';\nexport const CHILDREN = '__k';\nexport const PARENT = '__';\nexport const MASK = '__m';\n// Component properties\nexport const VNODE = '__v';\nexport const DIRTY = '__d';\nexport const FORCE = '__e';\nexport const NEXT_STATE = '__s';\nexport const CHILD_DID_SUSPEND = '__c';\nexport const RENDER_CALLBACKS = '__h';\nexport const HOOK = '__h';\n//# sourceMappingURL=constants.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { render } from 'preact';\nimport { renderOpcodesInto } from '../opcodes.js';\nimport { render as renderToString } from '../renderToOpcodes/index.js';\nimport { __root } from '../root.js';\nimport { commitToMainThread } from './patch/commit.js';\nfunction renderMainThread() {\n    /* v8 ignore start */\n    if (process.env['NODE_ENV'] === 'test' && typeof __TESTING_FORCE_RENDER_TO_OPCODE__ !== 'undefined'\n        && !__TESTING_FORCE_RENDER_TO_OPCODE__) {\n        render(__root.__jsx, __root);\n    }\n    else {\n        let opcodes;\n        try {\n            if (__PROFILE__) {\n                console.profile('renderToString');\n            }\n            // @ts-ignore\n            opcodes = renderToString(__root.__jsx);\n        }\n        catch (e) {\n            lynx.reportError(e);\n            opcodes = [];\n        }\n        finally {\n            if (__PROFILE__) {\n                console.profileEnd();\n            }\n        }\n        if (__PROFILE__) {\n            console.profile('renderOpcodesInto');\n        }\n        renderOpcodesInto(opcodes, __root);\n        if (__ENABLE_SSR__) {\n            __root.__opcodes = opcodes;\n        }\n        if (__PROFILE__) {\n            console.profileEnd();\n        }\n    }\n    /* v8 ignore stop */\n}\nfunction renderBackground(vnode, parent) {\n    render(vnode, parent);\n    void commitToMainThread();\n}\nexport { renderMainThread, renderBackground };\n//# sourceMappingURL=render.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { isMtsEnabled } from './functionality.js';\nlet initValuePatch = [];\nconst initValueIdSet = /*#__PURE__*/ new Set();\n/**\n * @internal\n */\nexport function addWorkletRefInitValue(id, value) {\n    if (!isMtsEnabled()) {\n        return;\n    }\n    initValueIdSet.add(id);\n    initValuePatch.push([id, value]);\n}\n/**\n * @internal\n */\nexport function takeWorkletRefInitValuePatch() {\n    const res = initValuePatch;\n    initValuePatch = [];\n    return res;\n}\n//# sourceMappingURL=workletRefPool.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { takeWorkletRefInitValuePatch } from './workletRefPool.js';\nexport const destroyTasks = [];\nexport function destroyWorklet() {\n    takeWorkletRefInitValuePatch();\n    for (const task of destroyTasks) {\n        task();\n    }\n    destroyTasks.length = 0;\n}\n//# sourceMappingURL=destroy.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { SnapshotInstance } from '../snapshot.js';\nfunction updateEvent(snapshot, expIndex, _oldValue, elementIndex, eventType, eventName, spreadKey) {\n    const value = snapshot.__values[expIndex];\n    let event;\n    if (!value) {\n        event = undefined;\n    }\n    else if (typeof value === 'string') {\n        event = value;\n    }\n    else {\n        event = `${snapshot.__id}:${expIndex}:${spreadKey}`;\n    }\n    // todo: reuseId?\n    snapshot.__values[expIndex] = event;\n    if (snapshot.__elements) {\n        __AddEvent(snapshot.__elements[elementIndex], eventType, eventName, event);\n    }\n}\nexport { updateEvent };\n//# sourceMappingURL=event.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\n// to make sure preact's hooks to register earlier than ours\nimport './hooks/react.js';\nimport { initProfileHook } from './debug/profile.js';\nimport { document, setupBackgroundDocument } from './document.js';\nimport { initDelayUnmount } from './lifecycle/delayUnmount.js';\nimport { replaceCommitHook, replaceRequestAnimationFrame } from './lifecycle/patch/commit.js';\nimport { injectUpdateMainThread } from './lifecycle/patch/updateMainThread.js';\nimport { injectCalledByNative } from './lynx/calledByNative.js';\nimport { setupLynxEnv } from './lynx/env.js';\nimport { injectLepusMethods } from './lynx/injectLepusMethods.js';\nimport { initTimingAPI } from './lynx/performance.js';\nimport { injectTt } from './lynx/tt.js';\n// @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature\nif (__LEPUS__ && typeof globalThis.processEvalResult === 'undefined') {\n    // @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature\n    globalThis.processEvalResult = (result, schema) => {\n        return result?.(schema);\n    };\n}\nif (__LEPUS__) {\n    injectCalledByNative();\n    injectUpdateMainThread();\n    if (__DEV__) {\n        injectLepusMethods();\n    }\n}\n// TODO: replace this with __PROFILE__\nif (__PROFILE__) {\n    // We are profiling both main-thread and background.\n    initProfileHook();\n}\nif (__JS__) {\n    options.document = document;\n    setupBackgroundDocument();\n    injectTt();\n    if (process.env['NODE_ENV'] === 'test') { }\n    else {\n        replaceCommitHook();\n        replaceRequestAnimationFrame();\n        initTimingAPI();\n        initDelayUnmount();\n    }\n}\nsetupLynxEnv();\n//# sourceMappingURL=lynx.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { hydrate } from '../hydrate.js';\nimport { isJSReady, jsReady, jsReadyEventIdSwap, resetJSReady } from '../lifecycle/event/jsReady.js';\nimport { reloadMainThread } from '../lifecycle/reload.js';\nimport { renderMainThread } from '../lifecycle/render.js';\nimport { LifecycleConstant } from '../lifecycleConstant.js';\nimport { __pendingListUpdates } from '../list.js';\nimport { ssrHydrateByOpcodes } from '../opcodes.js';\nimport { __root, setRoot } from '../root.js';\nimport { takeGlobalRefPatchMap } from '../snapshot/ref.js';\nimport { SnapshotInstance, __page, setupPage } from '../snapshot.js';\nimport { isEmptyObject } from '../utils.js';\nimport { PerformanceTimingKeys, markTiming, setPipeline } from './performance.js';\nfunction ssrEncode() {\n    const { __opcodes } = __root;\n    delete __root.__opcodes;\n    const oldToJSON = SnapshotInstance.prototype.toJSON;\n    SnapshotInstance.prototype.toJSON = function () {\n        return [\n            this.type,\n            this.__id,\n            this.__elements,\n        ];\n    };\n    try {\n        return JSON.stringify({ __opcodes, __root_values: __root.__values });\n    }\n    finally {\n        SnapshotInstance.prototype.toJSON = oldToJSON;\n    }\n}\nfunction ssrHydrate(info) {\n    const nativePage = __GetPageElement();\n    if (!nativePage) {\n        throw new Error('SSR Hydration Failed! Please check if the SSR content loaded successfully!');\n    }\n    const refsMap = __GetTemplateParts(nativePage);\n    const { __opcodes, __root_values } = JSON.parse(info);\n    __root_values && __root.setAttribute('values', __root_values);\n    ssrHydrateByOpcodes(__opcodes, __root, refsMap);\n    __root.__elements = [nativePage];\n    __root.__element_root = nativePage;\n}\nfunction injectCalledByNative() {\n    if (process.env['NODE_ENV'] !== 'test' && __FIRST_SCREEN_SYNC_TIMING__ !== 'jsReady' && __ENABLE_SSR__) {\n        throw new Error('`firstScreenSyncTiming` must be `jsReady` when SSR is enabled');\n    }\n    const calledByNative = {\n        renderPage,\n        updatePage,\n        updateGlobalProps,\n        getPageData: function () {\n            return null;\n        },\n        removeComponents: function () { },\n        ...(__ENABLE_SSR__ ? { ssrEncode, ssrHydrate } : {}),\n    };\n    Object.assign(globalThis, calledByNative);\n    Object.assign(globalThis, {\n        [LifecycleConstant.jsReady]: jsReady,\n    });\n}\nfunction renderPage(data) {\n    // reset `jsReady` state\n    resetJSReady();\n    lynx.__initData = data || {};\n    setupPage(__CreatePage('0', 0));\n    __root.ensureElements();\n    renderMainThread();\n    // always call this before `__FlushElementTree`\n    // (There is an implict `__FlushElementTree` in `renderPage`)\n    __pendingListUpdates.flush();\n    if (__FIRST_SCREEN_SYNC_TIMING__ === 'immediately') {\n        jsReady();\n    }\n}\nfunction updatePage(data, options) {\n    if (options?.reloadTemplate) {\n        reloadMainThread(data, options);\n        return;\n    }\n    if (options?.resetPageData) {\n        lynx.__initData = {};\n    }\n    if (typeof data == 'object' && !isEmptyObject(data)) {\n        lynx.__initData ??= {};\n        Object.assign(lynx.__initData, data);\n    }\n    if (!isJSReady) {\n        const oldRoot = __root;\n        setRoot(new SnapshotInstance('root'));\n        __root.__jsx = oldRoot.__jsx;\n        setPipeline(options?.pipelineOptions);\n        markTiming(PerformanceTimingKeys.update_diff_vdom_start);\n        {\n            __pendingListUpdates.clear();\n            // ignore ref & unref before jsReady\n            takeGlobalRefPatchMap();\n            renderMainThread();\n            // As said by codename `jsReadyEventIdSwap`, this swap will only be used for event remap,\n            // because ref & unref cause by previous render will be ignored\n            hydrate(oldRoot, __root, { skipUnRef: true, swap: jsReadyEventIdSwap });\n            // always call this before `__FlushElementTree`\n            __pendingListUpdates.flush();\n        }\n        markTiming(PerformanceTimingKeys.update_diff_vdom_end);\n    }\n    if (options) {\n        __FlushElementTree(__page, options);\n    }\n    else {\n        __FlushElementTree();\n    }\n}\nfunction updateGlobalProps(_data, options) {\n    if (options) {\n        __FlushElementTree(__page, options);\n    }\n    else {\n        __FlushElementTree();\n    }\n}\n/**\n * @internal\n */\nexport { injectCalledByNative };\n//# sourceMappingURL=calledByNative.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { hydrate } from '../hydrate.js';\nimport { LifecycleConstant } from '../lifecycleConstant.js';\nimport { __pendingListUpdates } from '../list.js';\nimport { __root, setRoot } from '../root.js';\nimport { takeGlobalRefPatchMap } from '../snapshot/ref.js';\nimport { SnapshotInstance, __page, snapshotInstanceManager } from '../snapshot.js';\nimport { isEmptyObject } from '../utils.js';\nimport { destroyBackground } from './destroy.js';\nimport { destroyWorklet } from '../worklet/destroy.js';\nimport { clearJSReadyEventIdSwap, isJSReady } from './event/jsReady.js';\nimport { increaseReloadVersion } from './pass.js';\nimport { deinitGlobalSnapshotPatch } from './patch/snapshotPatch.js';\nimport { renderBackground, renderMainThread } from './render.js';\nfunction reloadMainThread(data, options) {\n    if (__PROFILE__) {\n        console.profile('reloadTemplate');\n    }\n    increaseReloadVersion();\n    if (typeof data == 'object' && !isEmptyObject(data)) {\n        Object.assign(lynx.__initData, data);\n    }\n    destroyWorklet();\n    snapshotInstanceManager.clear();\n    __pendingListUpdates.clear();\n    clearJSReadyEventIdSwap();\n    const oldRoot = __root;\n    setRoot(new SnapshotInstance('root'));\n    __root.__jsx = oldRoot.__jsx;\n    renderMainThread();\n    hydrate(oldRoot, __root, {\n        skipUnRef: true,\n    });\n    // always call this before `__FlushElementTree`\n    __pendingListUpdates.flush();\n    if (isJSReady) {\n        __OnLifecycleEvent([\n            LifecycleConstant.firstScreen, /* FIRST_SCREEN */\n            {\n                root: JSON.stringify(__root),\n                refPatch: JSON.stringify(takeGlobalRefPatchMap()),\n            },\n        ]);\n    }\n    __FlushElementTree(__page, options);\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n    return;\n}\nfunction reloadBackground(updateData) {\n    if (__PROFILE__) {\n        console.profile('reload');\n    }\n    deinitGlobalSnapshotPatch();\n    destroyBackground();\n    increaseReloadVersion();\n    // COW when modify `lynx.__initData` to make sure Provider & Consumer works\n    lynx.__initData = Object.assign({}, lynx.__initData, updateData);\n    renderBackground(__root.__jsx, __root);\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n}\nexport { reloadBackground, reloadMainThread };\n//# sourceMappingURL=reload.js.map","export function setupLynxEnv() {\n    if (!__LEPUS__) {\n        const { initData, updateData } = lynxCoreInject.tt._params;\n        // @ts-ignore\n        lynx.__initData = { ...initData, ...updateData };\n        lynx.registerDataProcessors = function () { };\n    }\n    if (__LEPUS__) {\n        // @ts-ignore\n        lynx.__initData = {\n        /* available only in renderPage */\n        };\n        // @ts-ignore\n        globalThis.SystemInfo = lynx.SystemInfo || {};\n        lynx.reportError = function (e) {\n            _ReportError(e, {\n                errorCode: 1101, // ErrCode::LYNX_ERROR_CODE_LEPUS in Lynx/base/debug/error_code.h\n            });\n        };\n        lynx.triggerGlobalEventFromLepus = function (eventName, params) {\n            __OnLifecycleEvent(['globalEventFromLepus', [eventName, params]]);\n        };\n        {\n            function __name(empty) {\n                return `Native${empty}Modules`;\n            }\n            // TODO(hongzhiyuan.hzy): make sure this is run before any other code (especially code access `NativeModules`)\n            // @ts-ignore\n            if (typeof globalThis[__name('')] === 'undefined') {\n                // @ts-ignore\n                globalThis[__name('')] = undefined;\n            }\n        }\n        lynx.registerDataProcessors = function (dataProcessorDefinition) {\n            let hasDefaultDataProcessorExecuted = false;\n            // @ts-ignore\n            globalThis.processData = (data, processorName) => {\n                if (__PROFILE__) {\n                    console.profile('processData');\n                }\n                let r;\n                try {\n                    if (processorName) {\n                        r = dataProcessorDefinition?.dataProcessors?.[processorName]?.(data)\n                            ?? data;\n                    }\n                    else {\n                        r = dataProcessorDefinition?.defaultDataProcessor?.(data) ?? data;\n                    }\n                }\n                catch (e) {\n                    lynx.reportError(e);\n                    // when there is an error\n                    // we should perform like dataProcessor returns nothing\n                    // so use `{}` rather than `data`\n                    r = {};\n                }\n                if (__PROFILE__) {\n                    console.profileEnd();\n                }\n                if (hasDefaultDataProcessorExecuted === false) {\n                    // @ts-ignore\n                    if (globalThis.__I18N_RESOURCE_TRANSLATION__) {\n                        r = {\n                            ...r,\n                            // @ts-ignore\n                            __I18N_RESOURCE_TRANSLATION__: globalThis.__I18N_RESOURCE_TRANSLATION__,\n                        };\n                    }\n                    // @ts-ignore\n                    if (__EXTRACT_STR__) {\n                        r = {\n                            ...r,\n                            // @ts-ignore\n                            _EXTRACT_STR: __EXTRACT_STR_IDENT_FLAG__,\n                        };\n                    }\n                }\n                if (processorName) { }\n                else {\n                    hasDefaultDataProcessorExecuted = true;\n                }\n                return r;\n                // TODO\n            };\n        };\n        // register empty DataProcessors to make sure `globalThis.processData` is set\n        lynx.registerDataProcessors();\n    }\n}\n//# sourceMappingURL=env.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { Suspense, createElement, lazy } from 'preact/compat';\nimport './lynx.js';\nimport { factory as factory2 } from './compat/componentIs.js';\nimport { useMemo } from './hooks/react.js';\nimport { snapshotCreateList } from './list.js';\nimport { loadLazyBundle } from './lynx/lazy-bundle.js';\nimport { __root } from './root.js';\nimport { DynamicPartType, SnapshotInstance, __page, __pageId, createSnapshot, snapshotManager } from './snapshot.js';\nexport { __page, __pageId, __root };\nexport { SnapshotInstance, snapshotCreateList, createSnapshot, snapshotManager };\nexport const __DynamicPartSlot = DynamicPartType.Slot;\nexport const __DynamicPartMultiChildren = DynamicPartType.MultiChildren;\nexport const __DynamicPartChildren = DynamicPartType.Children;\nexport const __DynamicPartListChildren = DynamicPartType.ListChildren;\nexport const __DynamicPartChildren_0 = [[DynamicPartType.Children, 0]];\nexport { updateSpread } from './snapshot/spread.js';\nexport { updateEvent } from './snapshot/event.js';\nexport { updateRef, transformRef } from './snapshot/ref.js';\nexport { updateWorkletEvent } from './snapshot/workletEvent.js';\nexport { updateWorkletRef } from './snapshot/workletRef.js';\nexport { updateGesture } from './snapshot/gesture.js';\nexport { updateListItemPlatformInfo } from './snapshot/platformInfo.js';\nexport { options, \n// Component is not an internal API, but refresh needs it from 'react/internal'\nComponent, } from 'preact';\nexport { loadDynamicJS, __dynamicImport } from './lynx/dynamic-js.js';\nexport { withInitDataInState } from './compat/initData.js';\nexport { wrapWithLynxComponent } from './compat/lynxComponent.js';\n/**\n * @internal a polyfill for <component is=? />\n */\nexport const __ComponentIsPolyfill = /* @__PURE__ */ factory2(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n{ Suspense, lazy, createElement, useMemo }, loadLazyBundle);\nexport { loadLazyBundle } from './lynx/lazy-bundle.js';\nexport { transformToWorklet } from './worklet/transformToWorklet.js';\nexport { registerWorkletOnBackground } from './worklet/hmr.js';\nexport { loadWorkletRuntime } from '@lynx-js/react/worklet-runtime/bindings';\n//# sourceMappingURL=internal.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { SnapshotInstance } from '@lynx-js/react/internal';\n\nfunction createVNode(type, props, _key) {\n  if (typeof type === 'string') {\n    const r = new SnapshotInstance(type);\n\n    r.props = props;\n\n    r.__k = null;\n    r.__ = null;\n    r.__b = 0;\n    r.__e = null;\n    r.__d = undefined;\n    r.__c = null;\n    // r.__v = --vnodeId;\n    r.__i = -1;\n    r.__u = 0;\n\n    return r;\n  } else if (typeof type === 'function') {\n    let normalizedProps = props;\n\n    // let ref;\n    if ('ref' in normalizedProps) {\n      normalizedProps = {};\n      for (let i in props) {\n        if (i == 'ref') {\n          // ref = props[i];\n        } else {\n          normalizedProps[i] = props[i];\n        }\n      }\n    }\n\n    let defaultProps;\n    if ((defaultProps = type.defaultProps)) {\n      for (let i in defaultProps) {\n        if (typeof normalizedProps[i] === 'undefined') {\n          normalizedProps[i] = defaultProps[i];\n        }\n      }\n    }\n\n    return {\n      type,\n      props: normalizedProps,\n\n      __k: null,\n      __: null,\n      __b: 0,\n      __e: null,\n      __d: void 0,\n      __c: null,\n      constructor: void 0,\n      // __v: --vnodeId,\n      __i: -1,\n      __u: 0,\n    };\n  }\n}\n\nexport { createVNode as jsx, createVNode as jsxs, createVNode as jsxDEV };\nexport { Fragment } from 'preact';\n","import { useCallback } from '@lynx-js/react'\n\nimport './App.css'\nimport arrow from './assets/arrow.png'\nimport reactLynxLogo from './assets/react-logo.png'\n\nif (__BACKGROUND__) {\n  const app = (lynx as any).getApp()\n  const originalHandleError = app.handleError;\n  app.handleError = function(error: Error, originError?: Error, errorLevel?: any) {\n    console.log('error received in handleError: ', error, originError, errorLevel)\n    originalHandleError.call(app, error, originError, errorLevel)\n  }\n}\n\nexport function App() {\n  const onTap = useCallback(() => {\n    throw new Error('test error')\n  }, [])\n  return (\n    <view>\n      <view className='Background' />\n      <view className='App'>\n        <view className='Banner'>\n          <view className='Logo' bindtap={onTap}>\n            <image src={reactLynxLogo} className='Logo--react' />\n          </view>\n          <text className='Title'>React</text>\n          <text className='Subtitle'>on Lynx</text>\n        </view>\n        <view className='Content'>\n          <image src={arrow} className='Arrow' />\n          <Button text=\"Send exception\" onTap={onTap} />\n        </view>\n        <view style={{ flex: 1 }}></view>\n      </view>\n    </view>\n  )\n}\n\nexport function Button({ text, onTap }: { text: string, onTap: () => void }) {\n  return (\n    <view className=\"button\" bindtap={onTap}>\n      <text>{text}</text>\n    </view>\n  );\n}","import { root } from '@lynx-js/react';\nimport * as Sentry from \"@sentry/browser\";\nimport { App } from './App.js';\n\n// Create a wrapper around lynx.fetch to match the expected fetch signature\nconst fetchWrapper = (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n  // Cast the result to Promise<Response> to satisfy TypeScript\n  return lynx.fetch(input as RequestInfo, init) as unknown as Promise<Response>;\n};\n\nif (__MAIN_THREAD__ && __BACKGROUND__) {\n// Use the wrapper instead of lynx.fetch directly\nSentry.WINDOW.fetch = fetchWrapper;\n\nSentry.init({\n  dsn: 'https://e85b375ffb9f43cf8bdf9787768149e0@o447951.ingest.sentry.io/5428562',\n  integrations: [Sentry.rewriteFramesIntegration({\n    iteratee: (frame) => {\n      frame.filename = '/test/main.lynx.bundle'\n      frame.abs_path = '/test/main.lynx.bundle'\n      return frame;\n    }\n  })],\n  defaultIntegrations: false,\n  debug: true,\n  release: 'rel124'\n});\n}\n\n\nroot.render(<App />);\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n}\n\n\n","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { createContext, createElement } from 'preact/compat';\nimport { useState } from 'preact/hooks';\nimport { factory, withInitDataInState } from './compat/initData.js';\nimport { useLynxGlobalEventListener } from './hooks/useLynxGlobalEventListener.js';\nimport { renderBackground } from './lifecycle/render.js';\nimport { LifecycleConstant } from './lifecycleConstant.js';\nimport { flushDelayedLifecycleEvents } from './lynx/tt.js';\nimport { __root } from './root.js';\n/**\n * The default and only root of ReactLynx for you to render JSX\n * @example\n * ```ts\n * import { root } from \"@lynx-js/react\"\n * ```\n *\n * @public\n */\nexport const root = {\n    render: (jsx) => {\n        if (__LEPUS__) {\n            __root.__jsx = jsx;\n        }\n        else {\n            __root.__jsx = jsx;\n            renderBackground(jsx, __root);\n            if (__FIRST_SCREEN_SYNC_TIMING__ === 'immediately') { }\n            else {\n                lynx.getNativeApp().callLepusMethod(LifecycleConstant.jsReady, {});\n            }\n            flushDelayedLifecycleEvents();\n        }\n    },\n    registerDataProcessors: (dataProcessorDefinition) => {\n        lynx.registerDataProcessors(dataProcessorDefinition);\n    },\n};\nconst _InitData = /* @__PURE__ */ factory({\n    createContext,\n    useState,\n    createElement,\n    useLynxGlobalEventListener,\n}, '__initData', 'onDataChanged');\n/**\n * The {@link https://react.dev/reference/react/createContext#provider | Provider} Component that provide `initData`,\n * you must wrap your JSX inside it\n * @group Components\n *\n * @example\n *\n * ```ts\n * import { root } from \"@lynx-js/react\"\n *\n * function App() {\n *   return (\n *     <InitDataConsumer children={(initData) => <view>...</view>}/>\n *   )\n * }\n *\n * root.render(\n *   <InitDataProvider>\n *      <App/>\n *   </InitDataProvider>\n * );\n *\n * ```\n *\n * @public\n */\nexport const InitDataProvider = /* @__PURE__ */ _InitData.Provider();\n/**\n * The {@link https://react.dev/reference/react/createContext#consumer | Consumer} Component that provide `initData`.\n * This should be used with {@link InitDataProvider}\n * @group Components\n * @public\n */\nexport const InitDataConsumer = /* @__PURE__ */ _InitData.Consumer();\n/**\n * A React Hooks for you to get `initData`.\n * If `initData` is changed, a re-render will be triggered automatically.\n *\n * @example\n *\n * ```ts\n * function App() {\n *   const initData = useInitData();\n *\n *   initData.someProperty // use it\n * }\n * ```\n *\n * @public\n */\nexport const useInitData = /* @__PURE__ */ _InitData.use();\n/**\n * A React Hooks for you to get notified when `initData` changed.\n *\n * @example\n * ```ts\n * function App() {\n *   useInitDataChanged((data) => {\n *     data.someProperty // can use it\n *   })\n * }\n * ```\n * @public\n */\nexport const useInitDataChanged = /* @__PURE__ */ _InitData.useChanged();\nexport { withInitDataInState };\nexport { runOnMainThread } from './worklet/runOnMainThread.js';\nexport { runOnBackground } from './worklet/runOnBackground.js';\nexport { MainThreadRef, useMainThreadRef } from './worklet/workletRef.js';\nexport { useLynxGlobalEventListener } from './hooks/useLynxGlobalEventListener.js';\n//# sourceMappingURL=lynx-api.js.map"],"names":["__page","isJSReady","jsReadyEventIdSwap","beforeDiff","afterDiff","ummountHook","WorkletEvents","SnapshotOperation","NativeUpdateDataType","PerformanceTimingKeys","DynamicPartType","Opcode","GestureTypeInner","prevDebounce","currentIndex","currentComponent","previousComponent","prevRaf","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","isArray","Array","obj","props","i","removeNode","node","slice","error","vnode","oldVNode","errorInfo","component","ctor","handled","e","vnodeId","type","children","key","ref","normalizedProps","arguments","undefined","createVNode","original","BaseComponent","context","getDomSibling","childIndex","sibling","update","callback","s","enqueueRender","rerenderQueue","defer","Promise","setTimeout","c","process","a","b","renderQueueLength","renderComponent","oldDom","commitQueue","refQueue","newVNode","diff","commitRoot","root","applyRef","cb","updateParentDomPointers","child","diffChildren","parentDom","renderResult","newParentVNode","oldParentVNode","globalContext","namespace","excessDomChildren","isHydrating","childVNode","newDom","firstChildDom","oldChildren","newChildrenLength","constructNewChildrenArray","oldChildrenLength","remainingOldChildren","skew","String","skewedIndex","matchingIndex","findMatchingIndex","x","y","shouldSearch","unmount","parentVNode","skipRemove","r","insert","setStyle","style","value","eventClock","setProperty","dom","name","oldValue","useCapture","o","eventProxyCapture","eventProxy","createEventProxy","eventHandler","isNew","oldProps","oldState","snapshot","clearProcessingException","tmp","newType","outer","newProps","isClassComponent","provider","componentContext","doRender","renderHook","count","_i","isTopLevelFragment","MODE_HYDRATE","diffElementNodes","newHtml","oldHtml","newChildren","inputValue","checked","nodeType","hasRefUnmount","state","currentHook","afterPaintEffects","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","flushAfterPaintEffects","invokeCleanup","invokeEffect","hooks","hookItem","newQueueLength","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","requestAnimationFrame","hasErrored","hook","comp","cleanup","shallowDiffers","p","oldDiffHook","Symbol","oldCatchError","oldUnmount","suspended","SuspenseList","promise","suspendingVNode","suspendingComponent","resolve","resolved","onResolved","onSuspensionComplete","_suspended","suspendedVNode","removeOriginal","detachedParent","originalParent","detachedComponent","detachedClone","effect","fallback","list","delegated","unsuspend","wrappedUnsuspend","Map","out","_this","REACT_ELEMENT_TYPE","oldVNodeHook","Object","v","oldEventHook","isPropagationStopped","isDefaultPrevented","timestampKey","force","globalRefPatch","unref","recursive","workletUnRef","params","it","takeGlobalRefPatchMap","patch","_","diffArrayLepus","before","after","isSameType","onDiffChildren","lastPlacedIndex","result","beforeMap","Set","beforeNode","afterNode","beforeNodes","oldIndex","k","options","swap","index","old","slot","beforeChildNodes","afterChildNodes","elementIndex","diffResult","diffArrayAction","onInsert","onRemove","onMove","deleteSet","insertMap","placementMap","moveTempMap","j","remain","keep","newNode","target","__InsertElementBefore","__RemoveElement","removals","insertions","updateAction","newIndex","JSON","Number","info","listElement","__SetAttribute","__UpdateListCallbacks","existingNode","attr","_oldAttr","removeChild","insertBefore","appendChild","platformInfoUpdate","updates","SystemInfo","__GetAttributeByName","ctx","listID","cellIndex","operationID","enableReuseNotification","signMap","recycleMap","Error","childCtx","platformInfo","uniqID","recycleSignMap","sign","__GetElementUniqueID","__FlushElementTree","newCtx","first","oldCtx","commitMainThreadPatchUpdate","__AppendElement","__pageId","snapshotManager","__CreateWrapperElement","__CreateElement","createSnapshot","create","cssId","entryName","DEFAULT_ENTRY_NAME","isListHolder","elements","__SetCSSId","values","__ReplaceElement","__GetTag","nodes","__snapshot_def","shouldRemove","__elements","parent","traverseSnapshotInstance","si","vv","snapshotDestroyList","helper","newValue","oldValues","id","reportCtxNotFound","lynx","reloadVersion","commitTaskId","refPatch","__OnLifecycleEvent","jsReady","markAsDirty","previousSkipEffects","opcodes","_renderToString","isSvgMode","selectValue","cctx","contextType","rendered","renderMainThread","renderOpcodesInto","into","top","stack","text","initValuePatch","expIndex","_oldValue","eventType","eventName","spreadKey","event","__AddEvent","globalThis","schema","renderPage","data","page","__CreatePage","updatePage","reloadMainThread","destroyWorklet","task","takeWorkletRefInitValuePatch","res","oldRoot","updateGlobalProps","_data","patchOptions","patchList","flushOptions","snapshotPatch","workletRefInitValuePatch","updateWorkletRefInitValueChanges","snapshotPatchApply","length","parentId","childId","beforeId","dynamicPartIndex","clearDelayedWorklets","setupLynxEnv","__name","empty","_ReportError","dataProcessorDefinition","hasDefaultDataProcessorExecuted","processorName","__DynamicPartChildren","_key","defaultProps","Button","onTap","jsx","args","factory","oldArgs","newArgs","arg"],"mappings":"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"}
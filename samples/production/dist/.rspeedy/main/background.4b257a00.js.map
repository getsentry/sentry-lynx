{"version":3,"file":".rspeedy/main/background.4b257a00.js","sources":["file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/patch/snapshotPatch.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/performance.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/functionality.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/delayUnmount.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/runOnBackground.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/root.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/tt.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/worklet-runtime/lib/bindings/events.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycleConstant.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/gesture/types.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/opcodes.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/dist/preact.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/hooks/dist/hooks.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/jsx-runtime/dist/jsxRuntime.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_async_to_generator.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_object_spread.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_define_property.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/renderToOpcodes/constants.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/utils.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/workletRefPool.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/pass.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/patch/commit.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_object_spread_props.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot/ref.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/snapshot/spread.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/destroy.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/indexMap.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/execMap.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/worklet/ctx.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/gesture/processGestureBagkround.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/backgroundSnapshot.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/document.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/render.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/destroy.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lifecycle/reload.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/hydrate.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_object_without_properties.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@swc/helpers/esm/_object_without_properties_loose.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/env.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx/component.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/preact/compat/dist/compat.mjs","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/internal.js","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/src/App.tsx","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/src/index.tsx","file:///Users/giancarlobuenaflor/Desktop/SentryProjects/sentry-lynx/samples/production/node_modules/@lynx-js/react/runtime/lib/lynx-api.js"],"sourcesContent":["// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport var SnapshotOperation;\n(function (SnapshotOperation) {\n    SnapshotOperation[SnapshotOperation[\"CreateElement\"] = 0] = \"CreateElement\";\n    SnapshotOperation[SnapshotOperation[\"InsertBefore\"] = 1] = \"InsertBefore\";\n    SnapshotOperation[SnapshotOperation[\"RemoveChild\"] = 2] = \"RemoveChild\";\n    SnapshotOperation[SnapshotOperation[\"SetAttribute\"] = 3] = \"SetAttribute\";\n    SnapshotOperation[SnapshotOperation[\"SetAttributes\"] = 4] = \"SetAttributes\";\n    SnapshotOperation[SnapshotOperation[\"DEV_ONLY_AddSnapshot\"] = 100] = \"DEV_ONLY_AddSnapshot\";\n    SnapshotOperation[SnapshotOperation[\"DEV_ONLY_RegisterWorklet\"] = 101] = \"DEV_ONLY_RegisterWorklet\";\n})(SnapshotOperation || (SnapshotOperation = {}));\nexport let __globalSnapshotPatch;\nexport function takeGlobalSnapshotPatch() {\n    if (__globalSnapshotPatch) {\n        const list = __globalSnapshotPatch;\n        __globalSnapshotPatch = [];\n        return list;\n    }\n    else {\n        return undefined;\n    }\n}\nexport function initGlobalSnapshotPatch() {\n    __globalSnapshotPatch = [];\n}\nexport function deinitGlobalSnapshotPatch() {\n    __globalSnapshotPatch = undefined;\n}\n//# sourceMappingURL=snapshotPatch.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\nimport { DIFF } from '../renderToOpcodes/constants.js';\nimport { __globalSnapshotPatch } from '../lifecycle/patch/snapshotPatch.js';\nvar PerformanceTimingKeys;\n(function (PerformanceTimingKeys) {\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_set_state_trigger\"] = 0] = \"update_set_state_trigger\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_diff_vdom_start\"] = 1] = \"update_diff_vdom_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"update_diff_vdom_end\"] = 2] = \"update_diff_vdom_end\";\n    // update_set_state_trigger, update_diff_vdom_start and update_diff_vdom_end is deprecated\n    PerformanceTimingKeys[PerformanceTimingKeys[\"diff_vdom_start\"] = 3] = \"diff_vdom_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"diff_vdom_end\"] = 4] = \"diff_vdom_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"pack_changes_start\"] = 5] = \"pack_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"pack_changes_end\"] = 6] = \"pack_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"parse_changes_start\"] = 7] = \"parse_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"parse_changes_end\"] = 8] = \"parse_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"patch_changes_start\"] = 9] = \"patch_changes_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"patch_changes_end\"] = 10] = \"patch_changes_end\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"hydrate_parse_snapshot_start\"] = 11] = \"hydrate_parse_snapshot_start\";\n    PerformanceTimingKeys[PerformanceTimingKeys[\"hydrate_parse_snapshot_end\"] = 12] = \"hydrate_parse_snapshot_end\";\n})(PerformanceTimingKeys || (PerformanceTimingKeys = {}));\n/**\n * @deprecated used by old timing api(setState timing flag)\n */\nconst PerfSpecificKey = '__lynx_timing_flag';\nlet timingFlag;\nlet shouldMarkDiffVdomStart = false;\nlet shouldMarkDiffVdomEnd = false;\nlet globalPipelineOptions;\n/**\n * @deprecated used by old timing api(setState timing flag)\n */\nfunction markTimingLegacy(key, timingFlag_) {\n    switch (key) {\n        case PerformanceTimingKeys.update_set_state_trigger: {\n            shouldMarkDiffVdomStart = true;\n            shouldMarkDiffVdomEnd = true;\n            timingFlag = timingFlag_;\n            break;\n        }\n        case PerformanceTimingKeys.update_diff_vdom_start: {\n            /* v8 ignore start */\n            if (!shouldMarkDiffVdomStart) {\n                return;\n            }\n            /* v8 ignore stop */\n            shouldMarkDiffVdomStart = false;\n            break;\n        }\n        case PerformanceTimingKeys.update_diff_vdom_end: {\n            if (!shouldMarkDiffVdomEnd) {\n                return;\n            }\n            shouldMarkDiffVdomEnd = false;\n            break;\n        }\n    }\n    lynx.getNativeApp().markTiming?.(timingFlag, PerformanceTimingKeys[key]);\n}\nfunction beginPipeline(needTimestamps, timingFlag) {\n    globalPipelineOptions = lynx.performance?._generatePipelineOptions?.();\n    if (globalPipelineOptions) {\n        globalPipelineOptions.needTimestamps = needTimestamps;\n        lynx.performance?._onPipelineStart?.(globalPipelineOptions.pipelineID);\n        if (timingFlag) {\n            lynx.performance?._bindPipelineIdWithTimingFlag?.(globalPipelineOptions.pipelineID, timingFlag);\n        }\n    }\n}\nfunction setPipeline(pipeline) {\n    globalPipelineOptions = pipeline;\n}\nfunction markTiming(timestampKey, force) {\n    if (globalPipelineOptions && (force || globalPipelineOptions.needTimestamps)) {\n        lynx.performance?._markTiming?.(globalPipelineOptions.pipelineID, PerformanceTimingKeys[timestampKey]);\n    }\n}\nfunction initTimingAPI() {\n    const oldDiff = options[DIFF];\n    options[DIFF] = (vnode) => {\n        // check `__globalSnapshotPatch` to make sure this only runs after hydrate\n        if (__JS__ && __globalSnapshotPatch) {\n            if (!globalPipelineOptions) {\n                beginPipeline(false);\n                markTiming(PerformanceTimingKeys.diff_vdom_start, true);\n            }\n            if (shouldMarkDiffVdomStart) {\n                markTimingLegacy(PerformanceTimingKeys.update_diff_vdom_start);\n            }\n        }\n        oldDiff?.(vnode);\n    };\n}\n/**\n * @internal\n */\nexport { PerformanceTimingKeys, PerfSpecificKey, markTimingLegacy, initTimingAPI, beginPipeline, markTiming, setPipeline, globalPipelineOptions, };\n//# sourceMappingURL=performance.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { isSdkVersionGt } from '../utils.js';\nlet mtsEnabled;\nlet runOnBackgroundEnabled;\n/**\n * @internal\n */\nfunction isMtsEnabled() {\n    if (mtsEnabled === undefined) {\n        mtsEnabled = isSdkVersionGt(2, 13);\n    }\n    return mtsEnabled;\n}\n/**\n * @internal\n */\nfunction isRunOnBackgroundEnabled() {\n    if (runOnBackgroundEnabled === undefined) {\n        runOnBackgroundEnabled = isSdkVersionGt(2, 15);\n    }\n    return runOnBackgroundEnabled;\n}\nfunction clearConfigCacheForTesting() {\n    mtsEnabled = undefined;\n    runOnBackgroundEnabled = undefined;\n}\nexport { isMtsEnabled, isRunOnBackgroundEnabled, clearConfigCacheForTesting };\n//# sourceMappingURL=functionality.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\nimport { CATCH_ERROR, COMPONENT, DIFF, VNODE } from '../renderToOpcodes/constants.js';\nlet delayedUnmounts = [];\nlet parentVNode;\nfunction takeDelayedUnmounts() {\n    const ret = delayedUnmounts;\n    delayedUnmounts = [];\n    // not clearing `parentVNode` here, which would be cleared before next diff in `options[DIFF]`\n    return ret;\n}\nfunction runDelayedUnmounts(delayedUnmounts) {\n    for (const fn of delayedUnmounts) {\n        fn();\n    }\n}\n/**\n * Delay `componentWillUnmount` until main thread patching finishes.\n */\nfunction initDelayUnmount() {\n    const oldUnmount = options.unmount;\n    options.unmount = (vnode) => {\n        if (!parentVNode) {\n            // `parentVNode` is the first vnode to unmount,\n            // which is needed to find proper error boundary when running `componentWillUnmount`.\n            // Shallow copy vnode to prevent modification to vnode in preact unmounting process.\n            parentVNode = { ...vnode };\n            const oldDiff = options[DIFF];\n            options[DIFF] = (vnode) => {\n                // A new diff indicates that the unmounting process of parentVNode is finished.\n                parentVNode = undefined;\n                options[DIFF] = oldDiff;\n                oldDiff?.(vnode);\n            };\n        }\n        const component = vnode[COMPONENT];\n        if (component) {\n            if (oldUnmount) {\n                const vnode_clone = { ...vnode };\n                delayedUnmounts.push(() => {\n                    const v = vnode_clone[COMPONENT][VNODE];\n                    vnode_clone[COMPONENT][VNODE] = vnode_clone;\n                    oldUnmount?.(vnode_clone);\n                    vnode_clone[COMPONENT][VNODE] = v;\n                });\n            }\n            if (component.componentWillUnmount) {\n                const unmount = component.componentWillUnmount;\n                // @ts-ignore\n                component.componentWillUnmount = undefined;\n                const parentVNode_ = parentVNode;\n                delayedUnmounts.push(() => {\n                    try {\n                        component.componentWillUnmount = unmount;\n                        component.componentWillUnmount();\n                    }\n                    catch (e) {\n                        options[CATCH_ERROR](e, parentVNode_);\n                    }\n                });\n            }\n        }\n    };\n}\nexport { initDelayUnmount, takeDelayedUnmounts, runDelayedUnmounts };\n//# sourceMappingURL=delayUnmount.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { WorkletEvents } from '@lynx-js/react/worklet-runtime/bindings';\nimport { destroyTasks } from './destroy.js';\nimport { WorkletExecIdMap } from './execMap.js';\nimport { isRunOnBackgroundEnabled } from './functionality.js';\nimport { onFunctionCall } from './functionCall.js';\nlet execIdMap;\nfunction init() {\n    'background only';\n    if (execIdMap) {\n        return;\n    }\n    execIdMap = new WorkletExecIdMap();\n    lynx.getCoreContext().addEventListener(WorkletEvents.runOnBackground, runJSFunction);\n    lynx.getCoreContext().addEventListener(WorkletEvents.releaseBackgroundWorkletCtx, releaseBackgroundWorkletCtx);\n    destroyTasks.push(() => {\n        lynx.getCoreContext().removeEventListener(WorkletEvents.runOnBackground, runJSFunction);\n        lynx.getCoreContext().removeEventListener(WorkletEvents.releaseBackgroundWorkletCtx, releaseBackgroundWorkletCtx);\n        execIdMap = undefined;\n    });\n}\n/**\n * @internal\n */\nfunction runJSFunction(event) {\n    'background only';\n    const data = JSON.parse(event.data);\n    const obj = execIdMap.findJsFnHandle(data.obj._execId, data.obj._jsFnId);\n    const f = obj?._fn;\n    if (!f) {\n        throw new Error('runOnBackground: JS function not found: ' + JSON.stringify(data.obj));\n    }\n    const returnValue = f(...data.params);\n    lynx.getCoreContext().dispatchEvent({\n        type: WorkletEvents.FunctionCallRet,\n        data: JSON.stringify({\n            resolveId: data.resolveId,\n            returnValue,\n        }),\n    });\n}\nfunction releaseBackgroundWorkletCtx(event) {\n    'background only';\n    for (const id of event.data) {\n        execIdMap.remove(id);\n    }\n}\n/**\n * @internal\n */\nfunction registerWorkletCtx(ctx) {\n    'background only';\n    init();\n    execIdMap.add(ctx);\n}\n/**\n * `runOnBackground` allows triggering js functions on the background thread asynchronously.\n * @param f - The js function to be called.\n * @returns A function. Calling which with the arguments to be passed to the js function to trigger it on the background thread. This function returns a promise that resolves to the return value of the js function.\n * @example\n * ```ts\n * import { runOnBackground } from '@lynx-js/react';\n *\n * async function someMainthreadFunction() {\n *   'main thread';\n *   const fn = runOnBackground(() => {\n *     return 'hello';\n *   });\n *   const result = await fn();\n}\n * ```\n * @public\n */\nfunction runOnBackground(f) {\n    if (!isRunOnBackgroundEnabled()) {\n        throw new Error('runOnBackground requires Lynx sdk version 2.16.');\n    }\n    if (__JS__) {\n        throw new Error('runOnBackground can only be used on the main thread.');\n    }\n    const obj = f;\n    if (obj._error) {\n        throw new Error(obj._error);\n    }\n    return async (...params) => {\n        return new Promise((resolve) => {\n            const resolveId = onFunctionCall(resolve);\n            lynx.getJSContext().dispatchEvent({\n                type: WorkletEvents.runOnBackground,\n                data: JSON.stringify({\n                    obj: {\n                        _jsFnId: obj._jsFnId,\n                        _execId: obj._execId,\n                    },\n                    params,\n                    resolveId,\n                }),\n            });\n        });\n    };\n}\nexport { registerWorkletCtx, runJSFunction, runOnBackground };\n//# sourceMappingURL=runOnBackground.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { BackgroundSnapshotInstance } from './backgroundSnapshot.js';\nimport { SnapshotInstance } from './snapshot.js';\nlet __root;\nfunction setRoot(root) {\n    __root = root;\n}\nif (__LEPUS__) {\n    setRoot(new SnapshotInstance('root'));\n}\nelse if (__JS__) {\n    setRoot(new BackgroundSnapshotInstance('root'));\n}\nexport { __root, setRoot };\n//# sourceMappingURL=root.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\nimport { LifecycleConstant, NativeUpdateDataType } from '../lifecycleConstant.js';\nimport { PerformanceTimingKeys, beginPipeline, markTiming } from './performance.js';\nimport { BackgroundSnapshotInstance, hydrate } from '../backgroundSnapshot.js';\nimport { destroyBackground } from '../lifecycle/destroy.js';\nimport { commitPatchUpdate, genCommitTaskId, globalCommitTaskMap } from '../lifecycle/patch/commit.js';\nimport { reloadBackground } from '../lifecycle/reload.js';\nimport { renderBackground } from '../lifecycle/render.js';\nimport { CHILDREN, COMPONENT, DIFF, DIFFED, FORCE } from '../renderToOpcodes/constants.js';\nimport { __root } from '../root.js';\nimport { globalRefsToSet, updateBackgroundRefs } from '../snapshot/ref.js';\nimport { backgroundSnapshotInstanceManager } from '../snapshot.js';\nimport { destroyWorklet } from '../worklet/destroy.js';\nexport function runWithForce(cb) {\n    // save vnode and its `_component` in WeakMap\n    const m = new WeakMap();\n    const oldDiff = options[DIFF];\n    options[DIFF] = (vnode) => {\n        if (oldDiff) {\n            oldDiff(vnode);\n        }\n        // when `options[DIFF]` is called, a newVnode is passed in\n        // so its `vnode[COMPONENT]` should be null,\n        // but it will be set later\n        Object.defineProperty(vnode, COMPONENT, {\n            configurable: true,\n            set(c) {\n                m.set(vnode, c);\n                if (c) {\n                    c[FORCE] = true;\n                }\n            },\n            get() {\n                return m.get(vnode);\n            },\n        });\n    };\n    const oldDiffed = options[DIFFED];\n    options[DIFFED] = (vnode) => {\n        if (oldDiffed) {\n            oldDiffed(vnode);\n        }\n        // delete is a reverse operation of previous `Object.defineProperty`\n        delete vnode[COMPONENT];\n        // restore\n        vnode[COMPONENT] = m.get(vnode);\n    };\n    try {\n        cb();\n    }\n    finally {\n        options[DIFF] = oldDiff;\n        options[DIFFED] = oldDiffed;\n    }\n}\nfunction injectTt() {\n    // @ts-ignore\n    const tt = lynxCoreInject.tt;\n    tt.OnLifecycleEvent = OnLifecycleEvent;\n    tt.publishEvent = delayedPublishEvent;\n    tt.publicComponentEvent = delayedPublicComponentEvent;\n    tt.callDestroyLifetimeFun = () => {\n        destroyWorklet();\n        destroyBackground();\n    };\n    tt.updateGlobalProps = updateGlobalProps;\n    tt.updateCardData = updateCardData;\n    tt.onAppReload = reloadBackground;\n    tt.processCardConfig = () => {\n        // used to updateTheme, no longer rely on this function\n    };\n}\nlet delayedLifecycleEvents;\nasync function OnLifecycleEvent([type, data]) {\n    const hasRootRendered = CHILDREN in __root;\n    // never called `render(<App/>, __root)`\n    // happens if user call `root.render()` async\n    if (!hasRootRendered) {\n        delayedLifecycleEvents ??= [];\n        delayedLifecycleEvents.push([type, data]);\n        return;\n    }\n    if (__PROFILE__) {\n        console.profile(`OnLifecycleEvent::${type}`);\n    }\n    switch (type) {\n        case LifecycleConstant.firstScreen: {\n            const { root: lepusSide, refPatch, jsReadyEventIdSwap } = data;\n            if (__PROFILE__) {\n                console.profile('hydrate');\n            }\n            beginPipeline(true, 'react_lynx_hydrate');\n            markTiming(PerformanceTimingKeys.hydrate_parse_snapshot_start);\n            const before = JSON.parse(lepusSide);\n            markTiming(PerformanceTimingKeys.hydrate_parse_snapshot_end);\n            markTiming(PerformanceTimingKeys.diff_vdom_start);\n            const snapshotPatch = hydrate(before, __root);\n            if (__PROFILE__) {\n                console.profileEnd();\n            }\n            markTiming(PerformanceTimingKeys.diff_vdom_end);\n            if (delayedEvents) {\n                delayedEvents.forEach((args) => {\n                    const [handlerName, data] = args;\n                    let [idStr, ...rest] = handlerName.split(':');\n                    while (jsReadyEventIdSwap[idStr])\n                        idStr = jsReadyEventIdSwap[idStr];\n                    try {\n                        publishEvent([idStr, ...rest].join(':'), data);\n                    }\n                    catch (e) {\n                        lynx.reportError(e);\n                    }\n                });\n                delayedEvents.length = 0;\n            }\n            lynxCoreInject.tt.publishEvent = publishEvent;\n            lynxCoreInject.tt.publicComponentEvent = publicComponentEvent;\n            if (__PROFILE__) {\n                console.profile('patchRef');\n            }\n            if (refPatch) {\n                globalRefsToSet.set(0, JSON.parse(refPatch));\n                updateBackgroundRefs(0);\n            }\n            if (__PROFILE__) {\n                console.profileEnd();\n            }\n            // console.debug(\"********** After hydration:\");\n            // printSnapshotInstance(__root as BackgroundSnapshotInstance);\n            if (__PROFILE__) {\n                console.profile('commitChanges');\n            }\n            const commitTaskId = genCommitTaskId();\n            await commitPatchUpdate({ patchList: [{ snapshotPatch, id: commitTaskId }] }, { isHydration: true });\n            updateBackgroundRefs(commitTaskId);\n            globalCommitTaskMap.forEach((commitTask, id) => {\n                if (id > commitTaskId) {\n                    return;\n                }\n                commitTask();\n                globalCommitTaskMap.delete(id);\n            });\n            break;\n        }\n        case LifecycleConstant.globalEventFromLepus: {\n            const [eventName, params] = data;\n            lynx.getJSModule('GlobalEventEmitter').trigger(eventName, params);\n            break;\n        }\n        case LifecycleConstant.ref: {\n            const { refPatch, commitTaskId } = data;\n            if (commitTaskId) {\n                globalRefsToSet.set(commitTaskId, JSON.parse(refPatch));\n            }\n            else {\n                globalRefsToSet.set(0, JSON.parse(refPatch));\n                updateBackgroundRefs(0);\n            }\n            break;\n        }\n    }\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n}\nfunction flushDelayedLifecycleEvents() {\n    if (delayedLifecycleEvents) {\n        delayedLifecycleEvents.forEach((e) => {\n            try {\n                OnLifecycleEvent(e);\n            }\n            catch (e) {\n                lynx.reportError(e);\n            }\n        });\n        delayedLifecycleEvents.length = 0;\n    }\n}\nfunction publishEvent(handlerName, data) {\n    // TODO: delay js events until js ready\n    lynxCoreInject.tt.callBeforePublishEvent?.(data);\n    const eventHandler = backgroundSnapshotInstanceManager.getValueBySign(handlerName);\n    if (eventHandler) {\n        try {\n            eventHandler(data);\n        }\n        catch (e) {\n            lynx.reportError(e);\n        }\n    }\n}\nfunction publicComponentEvent(_componentId, handlerName, data) {\n    publishEvent(handlerName, data);\n}\nlet delayedEvents;\nfunction delayedPublishEvent(handlerName, data) {\n    delayedEvents ??= [];\n    delayedEvents.push([handlerName, data]);\n}\nfunction delayedPublicComponentEvent(_componentId, handlerName, data) {\n    delayedPublishEvent(handlerName, data);\n}\nfunction updateGlobalProps(newData) {\n    Object.assign(lynx.__globalProps, newData);\n    // Our purpose is to make sure SYNC setState inside `emit`'s listeners\n    // can be batched with updateFromRoot\n    // This is already done because updateFromRoot will consume all dirty flags marked by\n    // the setState, and setState's flush will be a noop. No extra diffs will be needed.\n    Promise.resolve().then(() => {\n        runWithForce(() => renderBackground(__root.__jsx, __root));\n    });\n    lynxCoreInject.tt.GlobalEventEmitter.emit('onGlobalPropsChanged');\n}\nfunction updateCardData(newData, options) {\n    const { ['__lynx_timing_flag']: performanceTimingFlag, ...restNewData } = newData;\n    if (performanceTimingFlag) {\n        lynx.reportError(new Error(`Received unsupported updateData with \\`__lynx_timing_flag\\` (value \"${performanceTimingFlag}\"), the timing flag is ignored`));\n    }\n    const { type = NativeUpdateDataType.UPDATE } = options || {};\n    if (type == NativeUpdateDataType.RESET) {\n        // @ts-ignore\n        lynx.__initData = {};\n    }\n    // COW when modify `lynx.__initData` to make sure Provider & Consumer works\n    // @ts-ignore\n    lynx.__initData = Object.assign({}, lynx.__initData, restNewData);\n    lynxCoreInject.tt.GlobalEventEmitter.emit('onDataChanged');\n}\nexport { injectTt, flushDelayedLifecycleEvents, delayedLifecycleEvents };\n//# sourceMappingURL=tt.js.map","var WorkletEvents;\n(function (WorkletEvents) {\n    WorkletEvents[\"runWorkletCtx\"] = \"Lynx.Worklet.runWorkletCtx\";\n    WorkletEvents[\"runOnBackground\"] = \"Lynx.Worklet.runOnBackground\";\n    WorkletEvents[\"FunctionCallRet\"] = \"Lynx.Worklet.FunctionCallRet\";\n    WorkletEvents[\"releaseBackgroundWorkletCtx\"] = \"Lynx.Worklet.releaseBackgroundWorkletCtx\";\n    WorkletEvents[\"releaseWorkletRef\"] = \"Lynx.Worklet.releaseWorkletRef\";\n})(WorkletEvents || (WorkletEvents = {}));\nexport { WorkletEvents };\n//# sourceMappingURL=events.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport class LifecycleConstant {\n    static firstScreen = 'rLynxFirstScreen';\n    static updateFromRoot = 'updateFromRoot';\n    static globalEventFromLepus = 'globalEventFromLepus';\n    static ref = 'rLynxRef';\n    static jsReady = 'rLynxJSReady';\n    static patchUpdate = 'rLynxChange';\n}\nexport var NativeUpdateDataType;\n(function (NativeUpdateDataType) {\n    NativeUpdateDataType[NativeUpdateDataType[\"UPDATE\"] = 0] = \"UPDATE\";\n    NativeUpdateDataType[NativeUpdateDataType[\"RESET\"] = 1] = \"RESET\";\n})(NativeUpdateDataType || (NativeUpdateDataType = {}));\n//# sourceMappingURL=lifecycleConstant.js.map","import { ListUpdateInfoRecording, __pendingListUpdates, snapshotDestroyList } from './list.js';\nimport { unref } from './snapshot/ref.js';\nimport { SnapshotOperation, __globalSnapshotPatch } from './lifecycle/patch/snapshotPatch.js';\nimport { isDirectOrDeepEqual } from './utils.js';\nexport var DynamicPartType;\n(function (DynamicPartType) {\n    DynamicPartType[DynamicPartType[\"Attr\"] = 0] = \"Attr\";\n    DynamicPartType[DynamicPartType[\"Spread\"] = 1] = \"Spread\";\n    DynamicPartType[DynamicPartType[\"Slot\"] = 2] = \"Slot\";\n    // Component,\n    DynamicPartType[DynamicPartType[\"Children\"] = 3] = \"Children\";\n    DynamicPartType[DynamicPartType[\"ListChildren\"] = 4] = \"ListChildren\";\n    // Used by compat layer\n    DynamicPartType[DynamicPartType[\"MultiChildren\"] = 5] = \"MultiChildren\";\n})(DynamicPartType || (DynamicPartType = {}));\nexport let __page;\nexport let __pageId = 0;\nexport function setupPage(page) {\n    __page = page;\n    __pageId = __GetElementUniqueID(page);\n}\nexport const snapshotManager = {\n    values: /* @__PURE__ */ new Map([\n        [\n            'root',\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__page];\n                },\n                update: [],\n                slot: [[DynamicPartType.Children, 0]],\n                isListHolder: false,\n                cssId: 0,\n            },\n        ],\n        [\n            'wrapper',\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__CreateWrapperElement(__pageId)];\n                },\n                update: [],\n                slot: [[DynamicPartType.Children, 0]],\n                isListHolder: false,\n            },\n        ],\n        [\n            null,\n            {\n                create() {\n                    /* v8 ignore start */\n                    if (__JS__ && !__DEV__) {\n                        return [];\n                    }\n                    /* v8 ignore stop */\n                    return [__CreateElement('raw-text', __pageId)];\n                },\n                update: [\n                    ctx => {\n                        /* v8 ignore start */\n                        if (__JS__ && !__DEV__) {\n                            return;\n                        }\n                        /* v8 ignore stop */\n                        if (ctx.__elements) {\n                            __SetAttribute(ctx.__elements[0], 'text', ctx.__values[0]);\n                        }\n                    },\n                ],\n                slot: [],\n                isListHolder: false,\n            },\n        ],\n    ]),\n};\nexport const snapshotInstanceManager = {\n    nextId: 0,\n    values: /* @__PURE__ */ new Map(),\n    clear() {\n        // not resetting `nextId` to prevent id collision\n        this.values.clear();\n    },\n};\nexport const backgroundSnapshotInstanceManager = {\n    nextId: 0,\n    values: /* @__PURE__ */ new Map(),\n    clear() {\n        // not resetting `nextId` to prevent id collision\n        this.values.clear();\n    },\n    updateId(id, newId) {\n        const values = this.values;\n        const si = values.get(id);\n        values.delete(id);\n        values.set(newId, si);\n        si.__id = newId;\n    },\n    getValueBySign(str) {\n        const res = str?.split(':');\n        if (!res || (res.length != 2 && res.length != 3)) {\n            throw new Error('Invalid ctx format: ' + str);\n        }\n        let id = Number(res[0]);\n        const expIndex = Number(res[1]);\n        const ctx = this.values.get(id);\n        if (!ctx) {\n            return null;\n        }\n        const spreadKey = res[2];\n        if (spreadKey) {\n            return ctx.__values[expIndex][spreadKey];\n        }\n        else {\n            return ctx.__values[expIndex];\n        }\n    },\n};\nexport function createSnapshot(uniqID, create, update, slot, cssId, entryName) {\n    if (__DEV__ && __JS__\n        // `__globalSnapshotPatch` does not exist before hydration,\n        // so the snapshot of the first screen will not be sent to the main thread.\n        && __globalSnapshotPatch\n        && !snapshotManager.values.has(uniqID)\n        // `create` may be `null` when loading a lazy bundle after hydration.\n        && create !== null) {\n        // We only update the lepus snapshot if the `uniqID` is different.\n        // This means that `uniqID` is considered the \"hash\" of the snapshot.\n        // When HMR (Hot Module Replacement) or fast refresh updates occur, `createSnapshot` will be re-executed with the new snapshot definition.\n        __globalSnapshotPatch.push(SnapshotOperation.DEV_ONLY_AddSnapshot, uniqID, \n        // We use `Function.prototype.toString` to serialize the `create` and `update` functions for Lepus.\n        // This allows the updates to be applied to Lepus.\n        // As a result, both the static part (`create`) and the dynamic parts (`update` and `slot`) can be updated.\n        create.toString(), update?.map(f => f.toString()) ?? [], slot, cssId, entryName);\n    }\n    if (entryName) {\n        uniqID = `${entryName}:${uniqID}`;\n    }\n    const s = { create, update, slot, cssId, entryName };\n    snapshotManager.values.set(uniqID, s);\n    if (slot && slot[0] && slot[0][0] === DynamicPartType.ListChildren) {\n        s.isListHolder = true;\n    }\n    return uniqID;\n}\nexport function traverseSnapshotInstance(si, callback) {\n    const c = si.childNodes;\n    callback(si);\n    for (const vv of c) {\n        traverseSnapshotInstance(vv, callback);\n    }\n}\nconst DEFAULT_ENTRY_NAME = '__Card__';\nconst DEFAULT_CSS_ID = 0;\nexport class SnapshotInstance {\n    type;\n    __id;\n    __snapshot_def;\n    __elements;\n    __element_root;\n    __values;\n    __current_slot_index = 0;\n    __ref_set;\n    __worklet_ref_set;\n    __listItemPlatformInfo;\n    constructor(type, id) {\n        this.type = type;\n        this.__snapshot_def = snapshotManager.values.get(type);\n        id ||= snapshotInstanceManager.nextId -= 1;\n        this.__id = id;\n        snapshotInstanceManager.values.set(id, this);\n    }\n    ensureElements() {\n        const { create, slot, isListHolder, cssId, entryName } = this.__snapshot_def;\n        const elements = create(this);\n        this.__elements = elements;\n        this.__element_root = elements[0];\n        if (cssId === undefined) {\n            // This means either:\n            //   CSS Scope is removed(We only need to call `__SetCSSId` when there is `entryName`)\n            //   Or an old bundle(`__SetCSSId` is called in `create`), we skip calling `__SetCSSId`\n            if (entryName !== DEFAULT_ENTRY_NAME && entryName !== undefined) {\n                __SetCSSId(this.__elements, DEFAULT_CSS_ID, entryName);\n            }\n        }\n        else {\n            // cssId !== undefined\n            if (entryName !== DEFAULT_ENTRY_NAME && entryName !== undefined) {\n                // For lazy bundle, we need add `entryName` to the third params\n                __SetCSSId(this.__elements, cssId, entryName);\n            }\n            else {\n                __SetCSSId(this.__elements, cssId);\n            }\n        }\n        const values = this.__values;\n        if (values) {\n            this.__values = undefined;\n            this.setAttribute('values', values);\n        }\n        if (isListHolder) {\n            // never recurse into list's children\n        }\n        else {\n            let index = 0;\n            let child = this.__firstChild;\n            while (child) {\n                child.ensureElements();\n                const [type, elementIndex] = slot[index];\n                switch (type) {\n                    case DynamicPartType.Slot: {\n                        __ReplaceElement(child.__element_root, elements[elementIndex]);\n                        elements[elementIndex] = child.__element_root;\n                        index++;\n                        break;\n                    }\n                    /* v8 ignore start */\n                    case DynamicPartType.MultiChildren: {\n                        if (__GetTag(elements[elementIndex]) === 'wrapper') {\n                            __ReplaceElement(child.__element_root, elements[elementIndex]);\n                        }\n                        else {\n                            __AppendElement(elements[elementIndex], child.__element_root);\n                        }\n                        index++;\n                        break;\n                    }\n                    /* v8 ignore end */\n                    case DynamicPartType.Children:\n                    case DynamicPartType.ListChildren: {\n                        __AppendElement(elements[elementIndex], child.__element_root);\n                        break;\n                    }\n                }\n                child = child.__nextSibling;\n            }\n        }\n    }\n    unRenderElements() {\n        const { isListHolder } = this.__snapshot_def;\n        this.__elements = undefined;\n        this.__element_root = undefined;\n        if (isListHolder) {\n            // never recurse into list's children\n        }\n        else {\n            let child = this.__firstChild;\n            while (child) {\n                child.unRenderElements();\n                child = child.__nextSibling;\n            }\n        }\n    }\n    takeElements() {\n        const a = Object.create(SnapshotInstance.prototype);\n        a.__id = this.__id;\n        a.__snapshot_def = this.__snapshot_def;\n        a.__values = this.__values;\n        // all clear\n        a.__parent = null;\n        a.__firstChild = null;\n        a.__lastChild = null;\n        a.__nextSibling = null;\n        a.__previousSibling = null;\n        this.childNodes.map(c => c.takeElements()).forEach(node => a.__insertBefore(node));\n        a.__elements = this.__elements;\n        a.__element_root = this.__element_root;\n        this.__elements = undefined;\n        this.__element_root = undefined;\n        return a;\n    }\n    // onCreate?: () => void;\n    // onAttach?: () => void;\n    // onDetach?: () => void;\n    // onRef?: () => void;\n    // onUnref?: () => void;\n    __parent = null;\n    __firstChild = null;\n    __lastChild = null;\n    __previousSibling = null;\n    __nextSibling = null;\n    get parentNode() {\n        return this.__parent;\n    }\n    get nextSibling() {\n        return this.__nextSibling;\n    }\n    // get isConnected() {\n    //   return !!this.__parent;\n    // }\n    contains(child) {\n        return child.parentNode === this;\n    }\n    get childNodes() {\n        const nodes = [];\n        let node = this.__firstChild;\n        while (node) {\n            nodes.push(node);\n            node = node.__nextSibling;\n        }\n        return nodes;\n    }\n    __insertBefore(node, beforeNode) {\n        // If the node already has a parent, remove it from its current parent\n        if (node.__parent) {\n            node.__parent.__removeChild(node);\n        }\n        // If beforeNode is not provided, add the new node as the last child\n        if (beforeNode) {\n            // If beforeNode is provided, insert the new node before beforeNode\n            if (beforeNode.__previousSibling) {\n                beforeNode.__previousSibling.__nextSibling = node;\n                node.__previousSibling = beforeNode.__previousSibling;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            beforeNode.__previousSibling = node;\n            node.__nextSibling = beforeNode;\n            node.__parent = this;\n        }\n        else {\n            if (this.__lastChild) {\n                this.__lastChild.__nextSibling = node;\n                node.__previousSibling = this.__lastChild;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            this.__lastChild = node;\n            node.__parent = this;\n            node.__nextSibling = null;\n        }\n    }\n    __removeChild(node) {\n        if (node.__parent !== this) {\n            throw new Error('The node to be removed is not a child of this node.');\n        }\n        if (node.__previousSibling) {\n            node.__previousSibling.__nextSibling = node.__nextSibling;\n        }\n        else {\n            this.__firstChild = node.__nextSibling;\n        }\n        if (node.__nextSibling) {\n            node.__nextSibling.__previousSibling = node.__previousSibling;\n        }\n        else {\n            this.__lastChild = node.__previousSibling;\n        }\n        node.__parent = null;\n        node.__previousSibling = null;\n        node.__nextSibling = null;\n    }\n    insertBefore(newNode, existingNode) {\n        const __snapshot_def = this.__snapshot_def;\n        if (__snapshot_def.isListHolder) {\n            (__pendingListUpdates.values[this.__id] ??= new ListUpdateInfoRecording(this)).onInsertBefore(newNode, existingNode);\n            this.__insertBefore(newNode, existingNode);\n            return;\n        }\n        const shouldRemove = newNode.__parent === this;\n        this.__insertBefore(newNode, existingNode);\n        const __elements = this.__elements;\n        if (__elements) {\n            if (!newNode.__elements) {\n                newNode.ensureElements();\n            }\n        }\n        else {\n            return;\n        }\n        const count = __snapshot_def.slot.length;\n        if (count === 1) {\n            const [, elementIndex] = __snapshot_def.slot[0];\n            const parent = __elements[elementIndex];\n            if (shouldRemove) {\n                __RemoveElement(parent, newNode.__element_root);\n            }\n            if (existingNode) {\n                __InsertElementBefore(parent, newNode.__element_root, existingNode.__element_root);\n            }\n            else {\n                __AppendElement(parent, newNode.__element_root);\n            }\n        }\n        else if (count > 1) {\n            const index = this.__current_slot_index++;\n            const [s, elementIndex] = __snapshot_def.slot[index];\n            if (s === DynamicPartType.Slot) {\n                __ReplaceElement(newNode.__element_root, __elements[elementIndex]);\n                __elements[elementIndex] = newNode.__element_root;\n                /* v8 ignore start */\n            }\n            else if (s === DynamicPartType.MultiChildren) {\n                if (__GetTag(__elements[elementIndex]) === 'wrapper') {\n                    __ReplaceElement(newNode.__element_root, __elements[elementIndex]);\n                }\n                else {\n                    __AppendElement(__elements[elementIndex], newNode.__element_root);\n                }\n            }\n            /* v8 ignore end */\n        }\n    }\n    removeChild(child) {\n        const r = () => {\n            this.__removeChild(child);\n            traverseSnapshotInstance(child, v => {\n                v.__parent = null;\n                snapshotInstanceManager.values.delete(v.__id);\n            });\n        };\n        const __snapshot_def = this.__snapshot_def;\n        if (__snapshot_def.isListHolder) {\n            (__pendingListUpdates.values[this.__id] ??= new ListUpdateInfoRecording(this)).onRemoveChild(child);\n            r();\n            return;\n        }\n        // TODO: ref: can this be done on the background thread?\n        unref(child, true);\n        r();\n        if (this.__elements) {\n            const [, elementIndex] = __snapshot_def.slot[0];\n            __RemoveElement(this.__elements[elementIndex], child.__element_root);\n        }\n        if (child.__snapshot_def.isListHolder) {\n            snapshotDestroyList(child);\n        }\n    }\n    setAttribute(key, value) {\n        const helper = (index, oldValue, newValue) => {\n            if (isDirectOrDeepEqual(oldValue, newValue)) { }\n            else {\n                this.__snapshot_def.update[index](this, index, oldValue);\n            }\n        };\n        if (key === 'values') {\n            const oldValues = this.__values;\n            this.__values = value;\n            if (oldValues) {\n                for (let index = 0; index < value.length; index++) {\n                    helper(index, oldValues[index], value[index]);\n                }\n            }\n            else {\n                for (let index = 0; index < value.length; index++) {\n                    helper(index, undefined, value[index]);\n                }\n            }\n            return;\n        }\n        const index = typeof key === 'string' ? Number(key.slice(2)) : key;\n        this.__values ??= [];\n        helper(index, this.__values[index], this.__values[index] = value);\n    }\n    toJSON() {\n        return {\n            id: this.__id,\n            type: this.type,\n            values: this.__values,\n            children: this.__firstChild ? this.childNodes : undefined,\n        };\n    }\n}\n//# sourceMappingURL=snapshot.js.map","export var GestureTypeInner;\n(function (GestureTypeInner) {\n    GestureTypeInner[GestureTypeInner[\"COMPOSED\"] = -1] = \"COMPOSED\";\n    GestureTypeInner[GestureTypeInner[\"PAN\"] = 0] = \"PAN\";\n    GestureTypeInner[GestureTypeInner[\"FLING\"] = 1] = \"FLING\";\n    GestureTypeInner[GestureTypeInner[\"DEFAULT\"] = 2] = \"DEFAULT\";\n    GestureTypeInner[GestureTypeInner[\"TAP\"] = 3] = \"TAP\";\n    GestureTypeInner[GestureTypeInner[\"LONGPRESS\"] = 4] = \"LONGPRESS\";\n    GestureTypeInner[GestureTypeInner[\"ROTATION\"] = 5] = \"ROTATION\";\n    GestureTypeInner[GestureTypeInner[\"PINCH\"] = 6] = \"PINCH\";\n    GestureTypeInner[GestureTypeInner[\"NATIVE\"] = 7] = \"NATIVE\";\n})(GestureTypeInner || (GestureTypeInner = {}));\n//# sourceMappingURL=types.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { componentAtIndexFactory, enqueueComponentFactory, gRecycleMap, gSignMap } from './list.js';\nimport { CHILDREN } from './renderToOpcodes/constants.js';\nimport { SnapshotInstance } from './snapshot.js';\nvar Opcode;\n(function (Opcode) {\n    Opcode[Opcode[\"Begin\"] = 0] = \"Begin\";\n    Opcode[Opcode[\"End\"] = 1] = \"End\";\n    Opcode[Opcode[\"Attr\"] = 2] = \"Attr\";\n    Opcode[Opcode[\"Text\"] = 3] = \"Text\";\n})(Opcode || (Opcode = {}));\nexport function ssrHydrateByOpcodes(opcodes, into, refMap) {\n    let top = into;\n    const stack = [into];\n    for (let i = 0; i < opcodes.length;) {\n        const opcode = opcodes[i];\n        switch (opcode) {\n            case Opcode.Begin: {\n                const p = top;\n                const [type, __id, elements] = opcodes[i + 1];\n                top = new SnapshotInstance(type, __id);\n                top.__pendingElements = elements;\n                p.insertBefore(top);\n                stack.push(top);\n                i += 2;\n                break;\n            }\n            case Opcode.End: {\n                // @ts-ignore\n                top[CHILDREN] = undefined;\n                top.__elements = top.__pendingElements.map(({ ssrID }) => refMap[ssrID]);\n                top.__element_root = top.__elements[0];\n                delete top.__pendingElements;\n                if (top.__snapshot_def.isListHolder) {\n                    const listElement = top.__element_root;\n                    const listElementUniqueID = __GetElementUniqueID(listElement);\n                    const signMap = gSignMap[listElementUniqueID] = new Map();\n                    gRecycleMap[listElementUniqueID] = new Map();\n                    const enqueueFunc = enqueueComponentFactory();\n                    const componentAtIndex = componentAtIndexFactory(top.childNodes);\n                    for (const child of top.childNodes) {\n                        if (child.__element_root) {\n                            const childElementUniqueID = __GetElementUniqueID(child.__element_root);\n                            signMap.set(childElementUniqueID, child);\n                            enqueueFunc(listElement, listElementUniqueID, childElementUniqueID);\n                        }\n                    }\n                    __UpdateListCallbacks(listElement, componentAtIndex, enqueueFunc);\n                }\n                stack.pop();\n                const p = stack[stack.length - 1];\n                top = p;\n                i += 1;\n                break;\n            }\n            case Opcode.Attr: {\n                const key = opcodes[i + 1];\n                const value = opcodes[i + 2];\n                top.setAttribute(key, value);\n                i += 3;\n                break;\n            }\n            case Opcode.Text: {\n                const [[type, __id, elements], text] = opcodes[i + 1];\n                const s = new SnapshotInstance(type, __id);\n                s.setAttribute(0, text);\n                top.insertBefore(s);\n                s.__elements = elements.map(({ ssrID }) => refMap[ssrID]);\n                s.__element_root = s.__elements[0];\n                i += 2;\n                break;\n            }\n        }\n    }\n}\nexport function renderOpcodesInto(opcodes, into) {\n    let top = into;\n    const stack = [into];\n    for (let i = 0; i < opcodes.length;) {\n        const opcode = opcodes[i];\n        switch (opcode) {\n            case Opcode.Begin: {\n                const p = top;\n                top = opcodes[i + 1];\n                // @ts-ignore\n                if (top.__parent) {\n                    // already inserted\n                    top = new SnapshotInstance(top.type);\n                    opcodes[i + 1] = top;\n                }\n                p.insertBefore(top);\n                stack.push(top);\n                i += 2;\n                break;\n            }\n            case Opcode.End: {\n                // @ts-ignore\n                top[CHILDREN] = undefined;\n                stack.pop();\n                const p = stack[stack.length - 1];\n                top = p;\n                i += 1;\n                break;\n            }\n            case Opcode.Attr: {\n                const key = opcodes[i + 1];\n                const value = opcodes[i + 2];\n                top.setAttribute(key, value);\n                i += 3;\n                break;\n            }\n            case Opcode.Text: {\n                const text = opcodes[i + 1];\n                const s = new SnapshotInstance(null);\n                if (__ENABLE_SSR__) {\n                    // We need store the just created SnapshotInstance, or it will be lost when we leave the function\n                    opcodes[i + 1] = [s, text];\n                }\n                s.setAttribute(0, text);\n                top.insertBefore(s);\n                i += 2;\n                break;\n            }\n        }\n    }\n}\n//# sourceMappingURL=opcodes.js.map","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nvar MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nvar MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nvar INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nvar MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nvar RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\nvar EMPTY_OBJ = /** @type {any} */{};\nvar EMPTY_ARR = [];\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\nvar isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nfunction assign(obj, props) {\n  // @ts-expect-error We change the type of `obj` to be `O & P`\n  for (var i in props) obj[i] = props[i];\n  return /** @type {O & P} */obj;\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nfunction removeNode(node) {\n  if (node && node.parentNode) node.parentNode.removeChild(node);\n}\nvar slice = EMPTY_ARR.slice;\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nfunction _catchError(error, vnode, oldVNode, errorInfo) {\n  /** @type {Component} */\n  var component, /** @type {ComponentType} */\n    ctor, /** @type {boolean} */\n    handled;\n  for (; vnode = vnode.__;) {\n    if ((component = vnode.__c) && !component.__) {\n      try {\n        ctor = component.constructor;\n        if (ctor && ctor.getDerivedStateFromError != null) {\n          component.setState(ctor.getDerivedStateFromError(error));\n          handled = component.__d;\n        }\n        if (component.componentDidCatch != null) {\n          component.componentDidCatch(error, errorInfo || {});\n          handled = component.__d;\n        }\n\n        // This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n        if (handled) {\n          return component.__E = component;\n        }\n      } catch (e) {\n        error = e;\n      }\n    }\n  }\n  throw error;\n}\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nvar options = {\n  __e: _catchError\n};\n\nvar vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nfunction createElement(type, props, children) {\n  var normalizedProps = {},\n    key,\n    ref,\n    i;\n  for (i in props) {\n    if (i == 'key') key = props[i];else if (i == 'ref') ref = props[i];else normalizedProps[i] = props[i];\n  }\n  if (arguments.length > 2) {\n    normalizedProps.children = arguments.length > 3 ? slice.call(arguments, 2) : children;\n  }\n\n  // If a Component VNode, check for and apply defaultProps\n  // Note: type may be undefined in development, must never error here.\n  if (typeof type == 'function' && type.defaultProps != null) {\n    for (i in type.defaultProps) {\n      if (normalizedProps[i] === undefined) {\n        normalizedProps[i] = type.defaultProps[i];\n      }\n    }\n  }\n  return createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nfunction createVNode(type, props, key, ref, original) {\n  // V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n  // Do not inline into createElement and coerceToVNode!\n  /** @type {VNode} */\n  var vnode = {\n    type: type,\n    props: props,\n    key: key,\n    ref: ref,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    // _nextDom must be initialized to undefined b/c it will eventually\n    // be set to dom.nextSibling which can return `null` and it is important\n    // to be able to distinguish between an uninitialized _nextDom and\n    // a _nextDom that has been set to `null`\n    __d: undefined,\n    __c: null,\n    constructor: undefined,\n    __v: original == null ? ++vnodeId : original,\n    __i: -1,\n    __u: 0\n  };\n\n  // Only invoke the vnode hook if this was *not* a direct copy:\n  if (original == null && options.vnode != null) options.vnode(vnode);\n  return vnode;\n}\nfunction createRef() {\n  return {\n    current: null\n  };\n}\nfunction Fragment(props) {\n  return props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nvar isValidElement = function isValidElement(vnode) {\n  return vnode != null && vnode.constructor == undefined;\n};\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nfunction BaseComponent(props, context) {\n  this.props = props;\n  this.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n  // only clone state when copying to nextState the first time.\n  var s;\n  if (this.__s != null && this.__s !== this.state) {\n    s = this.__s;\n  } else {\n    s = this.__s = assign({}, this.state);\n  }\n  if (typeof update == 'function') {\n    // Some libraries like `immer` mark the current state as readonly,\n    // preventing us from mutating it, so we need to clone it. See #2716\n    update = update(assign({}, s), this.props);\n  }\n  if (update) {\n    assign(s, update);\n  }\n\n  // Skip update if updater function returned null\n  if (update == null) return;\n  if (this.__v) {\n    if (callback) {\n      this._sb.push(callback);\n    }\n    enqueueRender(this);\n  }\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n  if (this.__v) {\n    // Set render mode so that we can differentiate where the render request\n    // is coming from. We need this because forceUpdate should never call\n    // shouldComponentUpdate\n    this.__e = true;\n    if (callback) this.__h.push(callback);\n    enqueueRender(this);\n  }\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nfunction getDomSibling(vnode, childIndex) {\n  if (childIndex == null) {\n    // Use childIndex==null as a signal to resume the search from the vnode's sibling\n    return vnode.__ ? getDomSibling(vnode.__, vnode.__i + 1) : null;\n  }\n  var sibling;\n  for (; childIndex < vnode.__k.length; childIndex++) {\n    sibling = vnode.__k[childIndex];\n    if (sibling != null && sibling.__e != null) {\n      // Since updateParentDomPointers keeps _dom pointer correct,\n      // we can rely on _dom to tell us if this subtree contains a\n      // rendered DOM node, and what the first rendered DOM node is\n      return sibling.__e;\n    }\n  }\n\n  // If we get here, we have not found a DOM node in this vnode's children.\n  // We must resume from this vnode's sibling (in it's parent _children array)\n  // Only climb up and search the parent if we aren't searching through a DOM\n  // VNode (meaning we reached the DOM parent of the original vnode that began\n  // the search)\n  return typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n  var oldVNode = component.__v,\n    oldDom = oldVNode.__e,\n    commitQueue = [],\n    refQueue = [];\n  if (component.__P) {\n    var newVNode = assign({}, oldVNode);\n    newVNode.__v = oldVNode.__v + 1;\n    if (options.vnode) options.vnode(newVNode);\n    diff(component.__P, newVNode, oldVNode, component.__n, component.__P.namespaceURI, oldVNode.__u & MODE_HYDRATE ? [oldDom] : null, commitQueue, oldDom == null ? getDomSibling(oldVNode) : oldDom, !!(oldVNode.__u & MODE_HYDRATE), refQueue);\n    newVNode.__v = oldVNode.__v;\n    newVNode.__.__k[newVNode.__i] = newVNode;\n    commitRoot(commitQueue, newVNode, refQueue);\n    if (newVNode.__e != oldDom) {\n      updateParentDomPointers(newVNode);\n    }\n  }\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n  if ((vnode = vnode.__) != null && vnode.__c != null) {\n    vnode.__e = vnode.__c.base = null;\n    for (var i = 0; i < vnode.__k.length; i++) {\n      var child = vnode.__k[i];\n      if (child != null && child.__e != null) {\n        vnode.__e = vnode.__c.base = child.__e;\n        break;\n      }\n    }\n    return updateParentDomPointers(vnode);\n  }\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nvar rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nvar prevDebounce;\nvar defer = typeof Promise == 'function' ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nfunction enqueueRender(c) {\n  if (!c.__d && (c.__d = true) && rerenderQueue.push(c) && !process.__r++ || prevDebounce !== options.debounceRendering) {\n    prevDebounce = options.debounceRendering;\n    (prevDebounce || defer)(process);\n  }\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nvar depthSort = function depthSort(a, b) {\n  return a.__v.__b - b.__v.__b;\n};\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n  var c;\n  rerenderQueue.sort(depthSort);\n  // Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n  // process() calls from getting scheduled while `queue` is still being consumed.\n  while (c = rerenderQueue.shift()) {\n    if (c.__d) {\n      var renderQueueLength = rerenderQueue.length;\n      renderComponent(c);\n      if (rerenderQueue.length > renderQueueLength) {\n        // When i.e. rerendering a provider additional new items can be injected, we want to\n        // keep the order from top to bottom with those new items so we can handle them in a\n        // single pass\n        rerenderQueue.sort(depthSort);\n      }\n    }\n  }\n  process.__r = 0;\n}\nprocess.__r = 0;\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nfunction diffChildren(parentDom, renderResult, newParentVNode, oldParentVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue) {\n  var i, /** @type {VNode} */\n    oldVNode, /** @type {VNode} */\n    childVNode, /** @type {PreactElement} */\n    newDom, /** @type {PreactElement} */\n    firstChildDom;\n\n  // This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n  // as EMPTY_OBJ._children should be `undefined`.\n  /** @type {VNode[]} */\n  var oldChildren = oldParentVNode && oldParentVNode.__k || EMPTY_ARR;\n  var newChildrenLength = renderResult.length;\n  newParentVNode.__d = oldDom;\n  constructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n  oldDom = newParentVNode.__d;\n  for (i = 0; i < newChildrenLength; i++) {\n    childVNode = newParentVNode.__k[i];\n    if (childVNode == null) continue;\n\n    // At this point, constructNewChildrenArray has assigned _index to be the\n    // matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n    if (childVNode.__i === -1) {\n      oldVNode = EMPTY_OBJ;\n    } else {\n      oldVNode = oldChildren[childVNode.__i] || EMPTY_OBJ;\n    }\n\n    // Update childVNode._index to its final index\n    childVNode.__i = i;\n\n    // Morph the old element into the new one, but don't append it to the dom yet\n    diff(parentDom, childVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue);\n\n    // Adjust DOM nodes\n    newDom = childVNode.__e;\n    if (childVNode.ref && oldVNode.ref != childVNode.ref) {\n      if (oldVNode.ref) {\n        applyRef(oldVNode.ref, null, childVNode);\n      }\n      refQueue.push(childVNode.ref, childVNode.__c || newDom, childVNode);\n    }\n    if (firstChildDom == null && newDom != null) {\n      firstChildDom = newDom;\n    }\n    if (childVNode.__u & INSERT_VNODE || oldVNode.__k === childVNode.__k) {\n      oldDom = insert(childVNode, oldDom, parentDom);\n    } else if (typeof childVNode.type == 'function' && childVNode.__d !== undefined) {\n      // Since Fragments or components that return Fragment like VNodes can\n      // contain multiple DOM nodes as the same level, continue the diff from\n      // the sibling of last DOM child of this child VNode\n      oldDom = childVNode.__d;\n    } else if (newDom) {\n      oldDom = newDom.nextSibling;\n    }\n\n    // Eagerly cleanup _nextDom. We don't need to persist the value because it\n    // is only used by `diffChildren` to determine where to resume the diff\n    // after diffing Components and Fragments. Once we store it the nextDOM\n    // local var, we can clean up the property. Also prevents us hanging on to\n    // DOM nodes that may have been unmounted.\n    childVNode.__d = undefined;\n\n    // Unset diffing flags\n    childVNode.__u &= ~(INSERT_VNODE | MATCHED);\n  }\n\n  // TODO: With new child diffing algo, consider alt ways to diff Fragments.\n  // Such as dropping oldDom and moving fragments in place\n  //\n  // Because the newParentVNode is Fragment-like, we need to set it's\n  // _nextDom property to the nextSibling of its last child DOM node.\n  //\n  // `oldDom` contains the correct value here because if the last child\n  // is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n  // If the last child is a DOM VNode, then oldDom will be set to that DOM\n  // node's nextSibling.\n  newParentVNode.__d = oldDom;\n  newParentVNode.__e = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n  /** @type {number} */\n  var i;\n  /** @type {VNode} */\n  var childVNode;\n  /** @type {VNode} */\n  var oldVNode;\n  var newChildrenLength = renderResult.length;\n  var oldChildrenLength = oldChildren.length,\n    remainingOldChildren = oldChildrenLength;\n  var skew = 0;\n  newParentVNode.__k = [];\n  for (i = 0; i < newChildrenLength; i++) {\n    // @ts-expect-error We are reusing the childVNode variable to hold both the\n    // pre and post normalized childVNode\n    childVNode = renderResult[i];\n    if (childVNode == null || typeof childVNode == 'boolean' || typeof childVNode == 'function') {\n      childVNode = newParentVNode.__k[i] = null;\n      continue;\n    }\n    // If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n    // or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n    // it's own DOM & etc. pointers\n    else if (typeof childVNode == 'string' || typeof childVNode == 'number' ||\n    // eslint-disable-next-line valid-typeof\n    typeof childVNode == 'bigint' || childVNode.constructor == String) {\n      childVNode = newParentVNode.__k[i] = createVNode(null, childVNode, null, null, null);\n    } else if (isArray(childVNode)) {\n      childVNode = newParentVNode.__k[i] = createVNode(Fragment, {\n        children: childVNode\n      }, null, null, null);\n    } else if (childVNode.constructor === undefined && childVNode.__b > 0) {\n      // VNode is already in use, clone it. This can happen in the following\n      // scenario:\n      //   const reuse = <div />\n      //   <div>{reuse}<span />{reuse}</div>\n      childVNode = newParentVNode.__k[i] = createVNode(childVNode.type, childVNode.props, childVNode.key, childVNode.ref ? childVNode.ref : null, childVNode.__v);\n    } else {\n      childVNode = newParentVNode.__k[i] = childVNode;\n    }\n    var skewedIndex = i + skew;\n    childVNode.__ = newParentVNode;\n    childVNode.__b = newParentVNode.__b + 1;\n\n    // Temporarily store the matchingIndex on the _index property so we can pull\n    // out the oldVNode in diffChildren. We'll override this to the VNode's\n    // final index after using this property to get the oldVNode\n    var matchingIndex = childVNode.__i = findMatchingIndex(childVNode, oldChildren, skewedIndex, remainingOldChildren);\n    oldVNode = null;\n    if (matchingIndex !== -1) {\n      oldVNode = oldChildren[matchingIndex];\n      remainingOldChildren--;\n      if (oldVNode) {\n        oldVNode.__u |= MATCHED;\n      }\n    }\n\n    // Here, we define isMounting for the purposes of the skew diffing\n    // algorithm. Nodes that are unsuspending are considered mounting and we detect\n    // this by checking if oldVNode._original === null\n    var isMounting = oldVNode == null || oldVNode.__v === null;\n    if (isMounting) {\n      if (matchingIndex == -1) {\n        skew--;\n      }\n\n      // If we are mounting a DOM VNode, mark it for insertion\n      if (typeof childVNode.type != 'function') {\n        childVNode.__u |= INSERT_VNODE;\n      }\n    } else if (matchingIndex !== skewedIndex) {\n      // When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n      // --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n      //     we set the skew to 1 as we found an offset.\n      // --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n      //     this makes us increase the skew again.\n      // --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n      //\n      // this becomes an optimization question where currently we see a 1 element offset as an insertion\n      // or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n      // while a more than 1 offset we see as a swap.\n      // We could probably build heuristics for having an optimized course of action here as well, but\n      // might go at the cost of some bytes.\n      //\n      // If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n      // only the first item be a re-scouting and all the others fall in their skewed counter-part.\n      // We could also further optimize for swaps\n      if (matchingIndex == skewedIndex - 1) {\n        skew--;\n      } else if (matchingIndex == skewedIndex + 1) {\n        skew++;\n      } else {\n        if (matchingIndex > skewedIndex) {\n          skew--;\n        } else {\n          skew++;\n        }\n\n        // Move this VNode's DOM if the original index (matchingIndex) doesn't\n        // match the new skew index (i + new skew)\n        // In the former two branches we know that it matches after skewing\n        childVNode.__u |= INSERT_VNODE;\n      }\n    }\n  }\n\n  // Remove remaining oldChildren if there are any. Loop forwards so that as we\n  // unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n  // point to the next child, which needs to be the first DOM node that won't be\n  // unmounted.\n  if (remainingOldChildren) {\n    for (i = 0; i < oldChildrenLength; i++) {\n      oldVNode = oldChildren[i];\n      if (oldVNode != null && (oldVNode.__u & MATCHED) === 0) {\n        if (oldVNode.__e == newParentVNode.__d) {\n          newParentVNode.__d = getDomSibling(oldVNode);\n        }\n        unmount(oldVNode, oldVNode);\n      }\n    }\n  }\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n  // Note: VNodes in nested suspended trees may be missing _children.\n\n  if (typeof parentVNode.type == 'function') {\n    var children = parentVNode.__k;\n    for (var i = 0; children && i < children.length; i++) {\n      if (children[i]) {\n        // If we enter this code path on sCU bailout, where we copy\n        // oldVNode._children to newVNode._children, we need to update the old\n        // children's _parent pointer to point to the newVNode (parentVNode\n        // here).\n        children[i].__ = parentVNode;\n        oldDom = insert(children[i], oldDom, parentDom);\n      }\n    }\n    return oldDom;\n  } else if (parentVNode.__e != oldDom) {\n    if (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n      oldDom = getDomSibling(parentVNode);\n    }\n    parentDom.insertBefore(parentVNode.__e, oldDom || null);\n    oldDom = parentVNode.__e;\n  }\n  do {\n    oldDom = oldDom && oldDom.nextSibling;\n  } while (oldDom != null && oldDom.nodeType === 8);\n  return oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nfunction toChildArray(children, out) {\n  out = out || [];\n  if (children == null || typeof children == 'boolean') ; else if (isArray(children)) {\n    children.some(function (child) {\n      toChildArray(child, out);\n    });\n  } else {\n    out.push(children);\n  }\n  return out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(childVNode, oldChildren, skewedIndex, remainingOldChildren) {\n  var key = childVNode.key;\n  var type = childVNode.type;\n  var x = skewedIndex - 1;\n  var y = skewedIndex + 1;\n  var oldVNode = oldChildren[skewedIndex];\n\n  // We only need to perform a search if there are more children\n  // (remainingOldChildren) to search. However, if the oldVNode we just looked\n  // at skewedIndex was not already used in this diff, then there must be at\n  // least 1 other (so greater than 1) remainingOldChildren to attempt to match\n  // against. So the following condition checks that ensuring\n  // remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n  // if the oldVNode was null or matched, then there could needs to be at least\n  // 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n  var shouldSearch = remainingOldChildren > (oldVNode != null && (oldVNode.__u & MATCHED) === 0 ? 1 : 0);\n  if (oldVNode === null || oldVNode && key == oldVNode.key && type === oldVNode.type && (oldVNode.__u & MATCHED) === 0) {\n    return skewedIndex;\n  } else if (shouldSearch) {\n    while (x >= 0 || y < oldChildren.length) {\n      if (x >= 0) {\n        oldVNode = oldChildren[x];\n        if (oldVNode && (oldVNode.__u & MATCHED) === 0 && key == oldVNode.key && type === oldVNode.type) {\n          return x;\n        }\n        x--;\n      }\n      if (y < oldChildren.length) {\n        oldVNode = oldChildren[y];\n        if (oldVNode && (oldVNode.__u & MATCHED) === 0 && key == oldVNode.key && type === oldVNode.type) {\n          return y;\n        }\n        y++;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction setStyle(style, key, value) {\n  if (key[0] === '-') {\n    style.setProperty(key, value == null ? '' : value);\n  } else if (value == null) {\n    style[key] = '';\n  } else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n    style[key] = value;\n  } else {\n    style[key] = value + 'px';\n  }\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nvar eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nfunction setProperty(dom, name, value, oldValue, namespace) {\n  var useCapture;\n  o: if (name === 'style') {\n    if (typeof value == 'string') {\n      dom.style.cssText = value;\n    } else {\n      if (typeof oldValue == 'string') {\n        dom.style.cssText = oldValue = '';\n      }\n      if (oldValue) {\n        for (name in oldValue) {\n          if (!(value && name in value)) {\n            setStyle(dom.style, name, '');\n          }\n        }\n      }\n      if (value) {\n        for (name in value) {\n          if (!oldValue || value[name] !== oldValue[name]) {\n            setStyle(dom.style, name, value[name]);\n          }\n        }\n      }\n    }\n  }\n  // Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n  else if (name[0] === 'o' && name[1] === 'n') {\n    useCapture = name !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n    // Infer correct casing for DOM built-in events:\n    if (name.toLowerCase() in dom || name === 'onFocusOut' || name === 'onFocusIn') name = name.toLowerCase().slice(2);else name = name.slice(2);\n    if (!dom.l) dom.l = {};\n    dom.l[name + useCapture] = value;\n    if (value) {\n      if (!oldValue) {\n        value._attached = eventClock;\n        dom.addEventListener(name, useCapture ? eventProxyCapture : eventProxy, useCapture);\n      } else {\n        value._attached = oldValue._attached;\n      }\n    } else {\n      dom.removeEventListener(name, useCapture ? eventProxyCapture : eventProxy, useCapture);\n    }\n  } else {\n    if (namespace == 'http://www.w3.org/2000/svg') {\n      // Normalize incorrect prop usage for SVG:\n      // - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n      // - className --> class\n      name = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n    } else if (name != 'width' && name != 'height' && name != 'href' && name != 'list' && name != 'form' &&\n    // Default value in browsers is `-1` and an empty string is\n    // cast to `0` instead\n    name != 'tabIndex' && name != 'download' && name != 'rowSpan' && name != 'colSpan' && name != 'role' && name != 'popover' && name in dom) {\n      try {\n        dom[name] = value == null ? '' : value;\n        // labelled break is 1b smaller here than a return statement (sorry)\n        break o;\n      } catch (e) {}\n    }\n\n    // aria- and data- attributes have no boolean representation.\n    // A `false` value is different from the attribute not being\n    // present, so we can't remove it. For non-boolean aria\n    // attributes we could treat false as a removal, but the\n    // amount of exceptions would cost too many bytes. On top of\n    // that other frameworks generally stringify `false`.\n\n    if (typeof value == 'function') ; else if (value != null && (value !== false || name[4] === '-')) {\n      dom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n    } else {\n      dom.removeAttribute(name);\n    }\n  }\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n  /**\n   * Proxy an event to hooked event handlers\n   * @param {PreactEvent} e The event object from the browser\n   * @private\n   */\n  return function (e) {\n    if (this.l) {\n      var eventHandler = this.l[e.type + useCapture];\n      if (e._dispatched == null) {\n        e._dispatched = eventClock++;\n\n        // When `e._dispatched` is smaller than the time when the targeted event\n        // handler was attached we know we have bubbled up to an element that was added\n        // during patching the DOM.\n      } else if (e._dispatched < eventHandler._attached) {\n        return;\n      }\n      return eventHandler(options.event ? options.event(e) : e);\n    }\n  };\n}\nvar eventProxy = createEventProxy(false);\nvar eventProxyCapture = createEventProxy(true);\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nfunction diff(parentDom, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue) {\n  /** @type {any} */\n  var tmp,\n    newType = newVNode.type;\n\n  // When passing through createElement it assigns the object\n  // constructor as undefined. This to prevent JSON-injection.\n  if (newVNode.constructor !== undefined) return null;\n\n  // If the previous diff bailed out, resume creating/hydrating.\n  if (oldVNode.__u & MODE_SUSPENDED) {\n    isHydrating = !!(oldVNode.__u & MODE_HYDRATE);\n    oldDom = newVNode.__e = oldVNode.__e;\n    excessDomChildren = [oldDom];\n  }\n  if (tmp = options.__b) tmp(newVNode);\n  outer: if (typeof newType == 'function') {\n    try {\n      var c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n      var newProps = newVNode.props;\n      var isClassComponent = 'prototype' in newType && newType.prototype.render;\n\n      // Necessary for createContext api. Setting this property will pass\n      // the context value as `this.context` just for this component.\n      tmp = newType.contextType;\n      var provider = tmp && globalContext[tmp.__c];\n      var componentContext = tmp ? provider ? provider.props.value : tmp.__ : globalContext;\n\n      // Get component and set it to `c`\n      if (oldVNode.__c) {\n        c = newVNode.__c = oldVNode.__c;\n        clearProcessingException = c.__ = c.__E;\n      } else {\n        // Instantiate the new component\n        if (isClassComponent) {\n          // @ts-expect-error The check above verifies that newType is suppose to be constructed\n          newVNode.__c = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n        } else {\n          // @ts-expect-error Trust me, Component implements the interface we want\n          newVNode.__c = c = new BaseComponent(newProps, componentContext);\n          c.constructor = newType;\n          c.render = doRender;\n        }\n        if (provider) provider.sub(c);\n        c.props = newProps;\n        if (!c.state) c.state = {};\n        c.context = componentContext;\n        c.__n = globalContext;\n        isNew = c.__d = true;\n        c.__h = [];\n        c._sb = [];\n      }\n\n      // Invoke getDerivedStateFromProps\n      if (isClassComponent && c.__s == null) {\n        c.__s = c.state;\n      }\n      if (isClassComponent && newType.getDerivedStateFromProps != null) {\n        if (c.__s == c.state) {\n          c.__s = assign({}, c.__s);\n        }\n        assign(c.__s, newType.getDerivedStateFromProps(newProps, c.__s));\n      }\n      oldProps = c.props;\n      oldState = c.state;\n      c.__v = newVNode;\n\n      // Invoke pre-render lifecycle methods\n      if (isNew) {\n        if (isClassComponent && newType.getDerivedStateFromProps == null && c.componentWillMount != null) {\n          c.componentWillMount();\n        }\n        if (isClassComponent && c.componentDidMount != null) {\n          c.__h.push(c.componentDidMount);\n        }\n      } else {\n        if (isClassComponent && newType.getDerivedStateFromProps == null && newProps !== oldProps && c.componentWillReceiveProps != null) {\n          c.componentWillReceiveProps(newProps, componentContext);\n        }\n        if (!c.__e && (c.shouldComponentUpdate != null && c.shouldComponentUpdate(newProps, c.__s, componentContext) === false || newVNode.__v === oldVNode.__v)) {\n          // More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n          if (newVNode.__v !== oldVNode.__v) {\n            // When we are dealing with a bail because of sCU we have to update\n            // the props, state and dirty-state.\n            // when we are dealing with strict-equality we don't as the child could still\n            // be dirtied see #3883\n            c.props = newProps;\n            c.state = c.__s;\n            c.__d = false;\n          }\n          newVNode.__e = oldVNode.__e;\n          newVNode.__k = oldVNode.__k;\n          newVNode.__k.some(function (vnode) {\n            if (vnode) vnode.__ = newVNode;\n          });\n          for (var i = 0; i < c._sb.length; i++) {\n            c.__h.push(c._sb[i]);\n          }\n          c._sb = [];\n          if (c.__h.length) {\n            commitQueue.push(c);\n          }\n          break outer;\n        }\n        if (c.componentWillUpdate != null) {\n          c.componentWillUpdate(newProps, c.__s, componentContext);\n        }\n        if (isClassComponent && c.componentDidUpdate != null) {\n          c.__h.push(function () {\n            c.componentDidUpdate(oldProps, oldState, snapshot);\n          });\n        }\n      }\n      c.context = componentContext;\n      c.props = newProps;\n      c.__P = parentDom;\n      c.__e = false;\n      var renderHook = options.__r,\n        count = 0;\n      if (isClassComponent) {\n        c.state = c.__s;\n        c.__d = false;\n        if (renderHook) renderHook(newVNode);\n        tmp = c.render(c.props, c.state, c.context);\n        for (var _i = 0; _i < c._sb.length; _i++) {\n          c.__h.push(c._sb[_i]);\n        }\n        c._sb = [];\n      } else {\n        do {\n          c.__d = false;\n          if (renderHook) renderHook(newVNode);\n          tmp = c.render(c.props, c.state, c.context);\n\n          // Handle setState called in render, see #2553\n          c.state = c.__s;\n        } while (c.__d && ++count < 25);\n      }\n\n      // Handle setState called in render, see #2553\n      c.state = c.__s;\n      if (c.getChildContext != null) {\n        globalContext = assign(assign({}, globalContext), c.getChildContext());\n      }\n      if (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n        snapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n      }\n      var isTopLevelFragment = tmp != null && tmp.type === Fragment && tmp.key == null;\n      var renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n      diffChildren(parentDom, isArray(renderResult) ? renderResult : [renderResult], newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, oldDom, isHydrating, refQueue);\n      c.base = newVNode.__e;\n\n      // We successfully rendered this VNode, unset any stored hydration/bailout state:\n      newVNode.__u &= RESET_MODE;\n      if (c.__h.length) {\n        commitQueue.push(c);\n      }\n      if (clearProcessingException) {\n        c.__E = c.__ = null;\n      }\n    } catch (e) {\n      newVNode.__v = null;\n      // if hydrating or creating initial tree, bailout preserves DOM:\n      if (isHydrating || excessDomChildren != null) {\n        newVNode.__u |= isHydrating ? MODE_HYDRATE | MODE_SUSPENDED : MODE_HYDRATE;\n        while (oldDom && oldDom.nodeType === 8 && oldDom.nextSibling) {\n          oldDom = oldDom.nextSibling;\n        }\n        excessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n        newVNode.__e = oldDom;\n      } else {\n        newVNode.__e = oldVNode.__e;\n        newVNode.__k = oldVNode.__k;\n      }\n      options.__e(e, newVNode, oldVNode);\n    }\n  } else if (excessDomChildren == null && newVNode.__v === oldVNode.__v) {\n    newVNode.__k = oldVNode.__k;\n    newVNode.__e = oldVNode.__e;\n  } else {\n    newVNode.__e = diffElementNodes(oldVNode.__e, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, isHydrating, refQueue);\n  }\n  if (tmp = options.diffed) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nfunction commitRoot(commitQueue, root, refQueue) {\n  root.__d = undefined;\n  for (var i = 0; i < refQueue.length; i++) {\n    applyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n  }\n  if (options.__c) options.__c(root, commitQueue);\n  commitQueue.some(function (c) {\n    try {\n      // @ts-expect-error Reuse the commitQueue variable here so the type changes\n      commitQueue = c.__h;\n      c.__h = [];\n      commitQueue.some(function (cb) {\n        // @ts-expect-error See above comment on commitQueue\n        cb.call(c);\n      });\n    } catch (e) {\n      options.__e(e, c.__v);\n    }\n  });\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(dom, newVNode, oldVNode, globalContext, namespace, excessDomChildren, commitQueue, isHydrating, refQueue) {\n  var oldProps = oldVNode.props;\n  var newProps = newVNode.props;\n  var nodeType = /** @type {string} */newVNode.type;\n  /** @type {any} */\n  var i;\n  /** @type {{ __html?: string }} */\n  var newHtml;\n  /** @type {{ __html?: string }} */\n  var oldHtml;\n  /** @type {ComponentChildren} */\n  var newChildren;\n  var value;\n  var inputValue;\n  var checked;\n\n  // Tracks entering and exiting namespaces when descending through the tree.\n  if (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';else if (nodeType === 'math') namespace = 'http://www.w3.org/1998/Math/MathML';else if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n  if (excessDomChildren != null) {\n    for (i = 0; i < excessDomChildren.length; i++) {\n      value = excessDomChildren[i];\n\n      // if newVNode matches an element in excessDomChildren or the `dom`\n      // argument matches an element in excessDomChildren, remove it from\n      // excessDomChildren so it isn't later removed in diffChildren\n      if (value && 'setAttribute' in value === !!nodeType && (nodeType ? value.localName === nodeType : value.nodeType === 3)) {\n        dom = value;\n        excessDomChildren[i] = null;\n        break;\n      }\n    }\n  }\n  if (dom == null) {\n    if (nodeType === null) {\n      return options.document.createTextNode(newProps);\n    }\n    dom = options.document.createElementNS(namespace, nodeType, newProps.is && newProps);\n\n    // we are creating a new node, so we can assume this is a new subtree (in\n    // case we are hydrating), this deopts the hydrate\n    if (isHydrating) {\n      if (options.__m) options.__m(newVNode, excessDomChildren);\n      isHydrating = false;\n    }\n    // we created a new parent, so none of the previously attached children can be reused:\n    excessDomChildren = null;\n  }\n  if (nodeType === null) {\n    // During hydration, we still have to split merged text from SSR'd HTML.\n    if (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n      dom.data = newProps;\n    }\n  } else {\n    // If excessDomChildren was not null, repopulate it with the current element's children:\n    excessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n    oldProps = oldVNode.props || EMPTY_OBJ;\n\n    // If we are in a situation where we are not hydrating but are using\n    // existing DOM (e.g. replaceNode) we should read the existing DOM\n    // attributes to diff them\n    if (!isHydrating && excessDomChildren != null) {\n      oldProps = {};\n      for (i = 0; i < dom.attributes.length; i++) {\n        value = dom.attributes[i];\n        oldProps[value.name] = value.value;\n      }\n    }\n    for (i in oldProps) {\n      value = oldProps[i];\n      if (i == 'children') ; else if (i == 'dangerouslySetInnerHTML') {\n        oldHtml = value;\n      } else if (!(i in newProps)) {\n        if (i == 'value' && 'defaultValue' in newProps || i == 'checked' && 'defaultChecked' in newProps) {\n          continue;\n        }\n        setProperty(dom, i, null, value, namespace);\n      }\n    }\n\n    // During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n    // @TODO we should warn in debug mode when props don't match here.\n    for (i in newProps) {\n      value = newProps[i];\n      if (i == 'children') {\n        newChildren = value;\n      } else if (i == 'dangerouslySetInnerHTML') {\n        newHtml = value;\n      } else if (i == 'value') {\n        inputValue = value;\n      } else if (i == 'checked') {\n        checked = value;\n      } else if ((!isHydrating || typeof value == 'function') && oldProps[i] !== value) {\n        setProperty(dom, i, value, oldProps[i], namespace);\n      }\n    }\n\n    // If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n    if (newHtml) {\n      // Avoid re-applying the same '__html' if it did not changed between re-render\n      if (!isHydrating && (!oldHtml || newHtml.__html !== oldHtml.__html && newHtml.__html !== dom.innerHTML)) {\n        dom.innerHTML = newHtml.__html;\n      }\n      newVNode.__k = [];\n    } else {\n      if (oldHtml) dom.innerHTML = '';\n      diffChildren(dom, isArray(newChildren) ? newChildren : [newChildren], newVNode, oldVNode, globalContext, nodeType === 'foreignObject' ? 'http://www.w3.org/1999/xhtml' : namespace, excessDomChildren, commitQueue, excessDomChildren ? excessDomChildren[0] : oldVNode.__k && getDomSibling(oldVNode, 0), isHydrating, refQueue);\n\n      // Remove children that are not part of any vnode.\n      if (excessDomChildren != null) {\n        for (i = excessDomChildren.length; i--;) {\n          removeNode(excessDomChildren[i]);\n        }\n      }\n    }\n\n    // As above, don't diff props during hydration\n    if (!isHydrating) {\n      i = 'value';\n      if (nodeType === 'progress' && inputValue == null) {\n        dom.removeAttribute('value');\n      } else if (inputValue !== undefined && (\n      // #2756 For the <progress>-element the initial value is 0,\n      // despite the attribute not being present. When the attribute\n      // is missing the progress bar is treated as indeterminate.\n      // To fix that we'll always update it when it is 0 for progress elements\n      inputValue !== dom[i] || nodeType === 'progress' && !inputValue ||\n      // This is only for IE 11 to fix <select> value not being updated.\n      // To avoid a stale select value we need to set the option.value\n      // again, which triggers IE11 to re-evaluate the select value\n      nodeType === 'option' && inputValue !== oldProps[i])) {\n        setProperty(dom, i, inputValue, oldProps[i], namespace);\n      }\n      i = 'checked';\n      if (checked !== undefined && checked !== dom[i]) {\n        setProperty(dom, i, checked, oldProps[i], namespace);\n      }\n    }\n  }\n  return dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nfunction applyRef(ref, value, vnode) {\n  try {\n    if (typeof ref == 'function') {\n      var hasRefUnmount = typeof ref.__u == 'function';\n      if (hasRefUnmount) {\n        // @ts-ignore TS doesn't like moving narrowing checks into variables\n        ref.__u();\n      }\n      if (!hasRefUnmount || value != null) {\n        // Store the cleanup function on the function\n        // instance object itself to avoid shape\n        // transitioning vnode\n        ref.__u = ref(value);\n      }\n    } else ref.current = value;\n  } catch (e) {\n    options.__e(e, vnode);\n  }\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nfunction unmount(vnode, parentVNode, skipRemove) {\n  var r;\n  if (options.unmount) options.unmount(vnode);\n  if (r = vnode.ref) {\n    if (!r.current || r.current === vnode.__e) {\n      applyRef(r, null, parentVNode);\n    }\n  }\n  if ((r = vnode.__c) != null) {\n    if (r.componentWillUnmount) {\n      try {\n        r.componentWillUnmount();\n      } catch (e) {\n        options.__e(e, parentVNode);\n      }\n    }\n    r.base = r.__P = null;\n  }\n  if (r = vnode.__k) {\n    for (var i = 0; i < r.length; i++) {\n      if (r[i]) {\n        unmount(r[i], parentVNode, skipRemove || typeof vnode.type != 'function');\n      }\n    }\n  }\n  if (!skipRemove) {\n    removeNode(vnode.__e);\n  }\n\n  // Must be set to `undefined` to properly clean up `_nextDom`\n  // for which `null` is a valid value. See comment in `create-element.js`\n  vnode.__c = vnode.__ = vnode.__e = vnode.__d = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n  return this.constructor(props, context);\n}\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nfunction render(vnode, parentDom, replaceNode) {\n  if (options.__) options.__(vnode, parentDom);\n\n  // We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n  // hydration mode or not by passing the `hydrate` function instead of a DOM\n  // element..\n  var isHydrating = typeof replaceNode == 'function';\n\n  // To be able to support calling `render()` multiple times on the same\n  // DOM node, we need to obtain a reference to the previous tree. We do\n  // this by assigning a new `_children` property to DOM nodes which points\n  // to the last rendered tree. By default this property is not present, which\n  // means that we are mounting a new tree for the first time.\n  var oldVNode = isHydrating ? null : replaceNode && replaceNode.__k || parentDom.__k;\n  vnode = (!isHydrating && replaceNode || parentDom).__k = createElement(Fragment, null, [vnode]);\n\n  // List of effects that need to be called after diffing.\n  var commitQueue = [],\n    refQueue = [];\n  diff(parentDom,\n  // Determine the new vnode tree and store it on the DOM element on\n  // our custom `_children` property.\n  vnode, oldVNode || EMPTY_OBJ, EMPTY_OBJ, parentDom.namespaceURI, !isHydrating && replaceNode ? [replaceNode] : oldVNode ? null : parentDom.firstChild ? slice.call(parentDom.childNodes) : null, commitQueue, !isHydrating && replaceNode ? replaceNode : oldVNode ? oldVNode.__e : parentDom.firstChild, isHydrating, refQueue);\n\n  // Flush all queued effects\n  commitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nfunction hydrate(vnode, parentDom) {\n  render(vnode, parentDom, hydrate);\n}\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nfunction cloneElement(vnode, props, children) {\n  var normalizedProps = assign({}, vnode.props),\n    key,\n    ref,\n    i;\n  var defaultProps;\n  if (vnode.type && vnode.type.defaultProps) {\n    defaultProps = vnode.type.defaultProps;\n  }\n  for (i in props) {\n    if (i == 'key') key = props[i];else if (i == 'ref') ref = props[i];else if (props[i] === undefined && defaultProps !== undefined) {\n      normalizedProps[i] = defaultProps[i];\n    } else {\n      normalizedProps[i] = props[i];\n    }\n  }\n  if (arguments.length > 2) {\n    normalizedProps.children = arguments.length > 3 ? slice.call(arguments, 2) : children;\n  }\n  return createVNode(vnode.type, normalizedProps, key || vnode.key, ref || vnode.ref, null);\n}\n\nvar i = 0;\nfunction createContext(defaultValue, contextId) {\n  contextId = '__cC' + i++;\n  var context = {\n    __c: contextId,\n    __: defaultValue,\n    /** @type {FunctionComponent} */Consumer: function Consumer(props, contextValue) {\n      // return props.children(\n      // \tcontext[contextId] ? context[contextId].props.value : defaultValue\n      // );\n      return props.children(contextValue);\n    },\n    /** @type {FunctionComponent} */Provider: function Provider(props) {\n      if (!this.getChildContext) {\n        /** @type {Component[] | null} */\n        var subs = [];\n        var ctx = {};\n        ctx[contextId] = this;\n        this.getChildContext = function () {\n          return ctx;\n        };\n        this.componentWillUnmount = function () {\n          subs = null;\n        };\n        this.shouldComponentUpdate = function (_props) {\n          if (this.props.value !== _props.value) {\n            subs.some(function (c) {\n              c.__e = true;\n              enqueueRender(c);\n            });\n          }\n        };\n        this.sub = function (c) {\n          subs.push(c);\n          var old = c.componentWillUnmount;\n          c.componentWillUnmount = function () {\n            if (subs) {\n              subs.splice(subs.indexOf(c), 1);\n            }\n            if (old) old.call(c);\n          };\n        };\n      }\n      return props.children;\n    }\n  };\n\n  // Devtools needs access to the context object when it\n  // encounters a Provider. This is necessary to support\n  // setting `displayName` on the context object instead\n  // of on the component itself. See:\n  // https://reactjs.org/docs/context.html#contextdisplayname\n\n  return context.Provider.__ = context.Consumer.contextType = context;\n}\n\nexport { BaseComponent as Component, Fragment, cloneElement, createContext, createElement, createRef, createElement as h, hydrate, isValidElement, options, render, toChildArray };\n//# sourceMappingURL=preact.module.js.map\n","import { options as options$1 } from 'preact';\n\n/** @type {number} */\nvar currentIndex;\n\n/** @type {import('./internal').Component} */\nvar currentComponent;\n\n/** @type {import('./internal').Component} */\nvar previousComponent;\n\n/** @type {number} */\nvar currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nvar afterPaintEffects = [];\n\n// Cast to use internal Options type\nvar options = /** @type {import('./internal').Options} */options$1;\nvar oldBeforeDiff = options.__b;\nvar oldBeforeRender = options.__r;\nvar oldAfterDiff = options.diffed;\nvar oldCommit = options.__c;\nvar oldBeforeUnmount = options.unmount;\nvar oldRoot = options.__;\nvar RAF_TIMEOUT = 100;\nvar prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.__b = function (vnode) {\n  currentComponent = null;\n  if (oldBeforeDiff) oldBeforeDiff(vnode);\n};\noptions.__ = function (vnode, parentDom) {\n  if (vnode && parentDom.__k && parentDom.__k.__m) {\n    vnode.__m = parentDom.__k.__m;\n  }\n  if (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.__r = function (vnode) {\n  if (oldBeforeRender) oldBeforeRender(vnode);\n  currentComponent = vnode.__c;\n  currentIndex = 0;\n  var hooks = currentComponent.__H;\n  if (hooks) {\n    if (previousComponent === currentComponent) {\n      hooks.__h = [];\n      currentComponent.__h = [];\n      hooks.__.forEach(function (hookItem) {\n        if (hookItem.__N) {\n          hookItem.__ = hookItem.__N;\n        }\n        hookItem._pendingArgs = hookItem.__N = undefined;\n      });\n    } else {\n      hooks.__h.forEach(invokeCleanup);\n      hooks.__h.forEach(invokeEffect);\n      hooks.__h = [];\n      currentIndex = 0;\n    }\n  }\n  previousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n  if (oldAfterDiff) oldAfterDiff(vnode);\n  var c = vnode.__c;\n  if (c && c.__H) {\n    if (c.__H.__h.length) afterPaint(afterPaintEffects.push(c));\n    c.__H.__.forEach(function (hookItem) {\n      if (hookItem._pendingArgs) {\n        hookItem.__H = hookItem._pendingArgs;\n      }\n      hookItem._pendingArgs = undefined;\n    });\n  }\n  previousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions.__c = function (vnode, commitQueue) {\n  commitQueue.some(function (component) {\n    try {\n      component.__h.forEach(invokeCleanup);\n      component.__h = component.__h.filter(function (cb) {\n        return cb.__ ? invokeEffect(cb) : true;\n      });\n    } catch (e) {\n      commitQueue.some(function (c) {\n        if (c.__h) c.__h = [];\n      });\n      commitQueue = [];\n      options.__e(e, component.__v);\n    }\n  });\n  if (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = function (vnode) {\n  if (oldBeforeUnmount) oldBeforeUnmount(vnode);\n  var c = vnode.__c;\n  if (c && c.__H) {\n    var hasErrored;\n    c.__H.__.forEach(function (s) {\n      try {\n        invokeCleanup(s);\n      } catch (e) {\n        hasErrored = e;\n      }\n    });\n    c.__H = undefined;\n    if (hasErrored) options.__e(hasErrored, c.__v);\n  }\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n  if (options.__h) {\n    options.__h(currentComponent, index, currentHook || type);\n  }\n  currentHook = 0;\n\n  // Largely inspired by:\n  // * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n  // * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n  // Other implementations to look at:\n  // * https://codesandbox.io/s/mnox05qp8\n  var hooks = currentComponent.__H || (currentComponent.__H = {\n    __: [],\n    __h: []\n  });\n  if (index >= hooks.__.length) {\n    hooks.__.push({});\n  }\n  return hooks.__[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nfunction useState(initialState) {\n  currentHook = 1;\n  return useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nfunction useReducer(reducer, initialState, init) {\n  /** @type {import('./internal').ReducerHookState} */\n  var hookState = getHookState(currentIndex++, 2);\n  hookState._reducer = reducer;\n  if (!hookState.__c) {\n    hookState.__ = [!init ? invokeOrReturn(undefined, initialState) : init(initialState), function (action) {\n      var currentValue = hookState.__N ? hookState.__N[0] : hookState.__[0];\n      var nextValue = hookState._reducer(currentValue, action);\n      if (currentValue !== nextValue) {\n        hookState.__N = [nextValue, hookState.__[1]];\n        hookState.__c.setState({});\n      }\n    }];\n    hookState.__c = currentComponent;\n    if (!currentComponent._hasScuFromHooks) {\n      // This SCU has the purpose of bailing out after repeated updates\n      // to stateful hooks.\n      // we store the next value in _nextValue[0] and keep doing that for all\n      // state setters, if we have next states and\n      // all next states within a component end up being equal to their original state\n      // we are safe to bail out for this specific component.\n      /**\n       *\n       * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n       */\n      // @ts-ignore - We don't use TS to downtranspile\n      // eslint-disable-next-line no-inner-declarations\n      var updateHookState = function updateHookState(p, s, c) {\n        if (!hookState.__c.__H) return true;\n\n        /** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n        var isStateHook = function isStateHook(x) {\n          return !!x.__c;\n        };\n        var stateHooks = hookState.__c.__H.__.filter(isStateHook);\n        var allHooksEmpty = stateHooks.every(function (x) {\n          return !x.__N;\n        });\n        // When we have no updated hooks in the component we invoke the previous SCU or\n        // traverse the VDOM tree further.\n        if (allHooksEmpty) {\n          return prevScu ? prevScu.call(this, p, s, c) : true;\n        }\n\n        // We check whether we have components with a nextValue set that\n        // have values that aren't equal to one another this pushes\n        // us to update further down the tree\n        var shouldUpdate = false;\n        stateHooks.forEach(function (hookItem) {\n          if (hookItem.__N) {\n            var currentValue = hookItem.__[0];\n            hookItem.__ = hookItem.__N;\n            hookItem.__N = undefined;\n            if (currentValue !== hookItem.__[0]) shouldUpdate = true;\n          }\n        });\n        return shouldUpdate || hookState.__c.props !== p ? prevScu ? prevScu.call(this, p, s, c) : true : false;\n      };\n      currentComponent._hasScuFromHooks = true;\n      var prevScu = currentComponent.shouldComponentUpdate;\n      var prevCWU = currentComponent.componentWillUpdate;\n\n      // If we're dealing with a forced update `shouldComponentUpdate` will\n      // not be called. But we use that to update the hook values, so we\n      // need to call it.\n      currentComponent.componentWillUpdate = function (p, s, c) {\n        if (this.__e) {\n          var tmp = prevScu;\n          // Clear to avoid other sCU hooks from being called\n          prevScu = undefined;\n          updateHookState(p, s, c);\n          prevScu = tmp;\n        }\n        if (prevCWU) prevCWU.call(this, p, s, c);\n      };\n      currentComponent.shouldComponentUpdate = updateHookState;\n    }\n  }\n  return hookState.__N || hookState.__;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useEffect(callback, args) {\n  /** @type {import('./internal').EffectHookState} */\n  var state = getHookState(currentIndex++, 3);\n  if (!options.__s && argsChanged(state.__H, args)) {\n    state.__ = callback;\n    state._pendingArgs = args;\n    currentComponent.__H.__h.push(state);\n  }\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useLayoutEffect(callback, args) {\n  /** @type {import('./internal').EffectHookState} */\n  var state = getHookState(currentIndex++, 4);\n  if (!options.__s && argsChanged(state.__H, args)) {\n    state.__ = callback;\n    state._pendingArgs = args;\n    currentComponent.__h.push(state);\n  }\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nfunction useRef(initialValue) {\n  currentHook = 5;\n  return useMemo(function () {\n    return {\n      current: initialValue\n    };\n  }, []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nfunction useImperativeHandle(ref, createHandle, args) {\n  currentHook = 6;\n  useLayoutEffect(function () {\n    if (typeof ref == 'function') {\n      ref(createHandle());\n      return function () {\n        return ref(null);\n      };\n    } else if (ref) {\n      ref.current = createHandle();\n      return function () {\n        return ref.current = null;\n      };\n    }\n  }, args == null ? args : args.concat(ref));\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nfunction useMemo(factory, args) {\n  /** @type {import('./internal').MemoHookState<T>} */\n  var state = getHookState(currentIndex++, 7);\n  if (argsChanged(state.__H, args)) {\n    state.__ = factory();\n    state.__H = args;\n    state.__h = factory;\n  }\n  return state.__;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nfunction useCallback(callback, args) {\n  currentHook = 8;\n  return useMemo(function () {\n    return callback;\n  }, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nfunction useContext(context) {\n  var provider = currentComponent.context[context.__c];\n  // We could skip this call here, but than we'd not call\n  // `options._hook`. We need to do that in order to make\n  // the devtools aware of this hook.\n  /** @type {import('./internal').ContextHookState} */\n  var state = getHookState(currentIndex++, 9);\n  // The devtools needs access to the context object to\n  // be able to pull of the default value when no provider\n  // is present in the tree.\n  state.c = context;\n  if (!provider) return context.__;\n  // This is probably not safe to convert to \"!\"\n  if (state.__ == null) {\n    state.__ = true;\n    provider.sub(currentComponent);\n  }\n  return provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nfunction useDebugValue(value, formatter) {\n  if (options.useDebugValue) {\n    options.useDebugValue(formatter ? formatter(value) : ( /** @type {any}*/value));\n  }\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nfunction useErrorBoundary(cb) {\n  /** @type {import('./internal').ErrorBoundaryHookState} */\n  var state = getHookState(currentIndex++, 10);\n  var errState = useState();\n  state.__ = cb;\n  if (!currentComponent.componentDidCatch) {\n    currentComponent.componentDidCatch = function (err, errorInfo) {\n      if (state.__) state.__(err, errorInfo);\n      errState[1](err);\n    };\n  }\n  return [errState[0], function () {\n    errState[1](undefined);\n  }];\n}\n\n/** @type {() => string} */\nfunction useId() {\n  /** @type {import('./internal').IdHookState} */\n  var state = getHookState(currentIndex++, 11);\n  if (!state.__) {\n    // Grab either the root node or the nearest async boundary node.\n    /** @type {import('./internal.d').VNode} */\n    var root = currentComponent.__v;\n    while (root !== null && !root.__m && root.__ !== null) {\n      root = root.__;\n    }\n    var mask = root.__m || (root.__m = [0, 0]);\n    state.__ = 'P' + mask[0] + '-' + mask[1]++;\n  }\n  return state.__;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n  var component;\n  while (component = afterPaintEffects.shift()) {\n    if (!component.__P || !component.__H) continue;\n    try {\n      component.__H.__h.forEach(invokeCleanup);\n      component.__H.__h.forEach(invokeEffect);\n      component.__H.__h = [];\n    } catch (e) {\n      component.__H.__h = [];\n      options.__e(e, component.__v);\n    }\n  }\n}\nvar HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n  var done = function done() {\n    clearTimeout(timeout);\n    if (HAS_RAF) cancelAnimationFrame(raf);\n    setTimeout(callback);\n  };\n  var timeout = setTimeout(done, RAF_TIMEOUT);\n  var raf;\n  if (HAS_RAF) {\n    raf = requestAnimationFrame(done);\n  }\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n  if (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n    prevRaf = options.requestAnimationFrame;\n    (prevRaf || afterNextFrame)(flushAfterPaintEffects);\n  }\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n  // A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n  // and move the currentComponent away.\n  var comp = currentComponent;\n  var cleanup = hook.__c;\n  if (typeof cleanup == 'function') {\n    hook.__c = undefined;\n    cleanup();\n  }\n  currentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n  // A hook call can introduce a call to render which creates a new root, this will call options.vnode\n  // and move the currentComponent away.\n  var comp = currentComponent;\n  hook.__c = hook.__();\n  currentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n  return !oldArgs || oldArgs.length !== newArgs.length || newArgs.some(function (arg, index) {\n    return arg !== oldArgs[index];\n  });\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n  return typeof f == 'function' ? f(arg) : f;\n}\n\nexport { useCallback, useContext, useDebugValue, useEffect, useErrorBoundary, useId, useImperativeHandle, useLayoutEffect, useMemo, useReducer, useRef, useState };\n//# sourceMappingURL=hooks.module.js.map\n","import { options, Fragment } from 'preact';\nexport { Fragment } from 'preact';\n\nvar ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nfunction encodeEntities(str) {\n  // Skip all work for strings with no entities needing encoding:\n  if (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n  var last = 0,\n    i = 0,\n    out = '',\n    ch = '';\n\n  // Seek forward in str until the next entity char:\n  for (; i < str.length; i++) {\n    switch (str.charCodeAt(i)) {\n      case 34:\n        ch = '&quot;';\n        break;\n      case 38:\n        ch = '&amp;';\n        break;\n      case 60:\n        ch = '&lt;';\n        break;\n      default:\n        continue;\n    }\n    // Append skipped/buffered characters and the encoded entity:\n    if (i !== last) out += str.slice(last, i);\n    out += ch;\n    // Start the next seek/buffer after the entity's offset:\n    last = i + 1;\n  }\n  if (i !== last) out += str.slice(last, i);\n  return out;\n}\n\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\nvar vnodeId = 0;\nvar isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n  if (!props) props = {};\n  // We'll want to preserve `ref` in props to get rid of the need for\n  // forwardRef components in the future, but that should happen via\n  // a separate PR.\n  var normalizedProps = props,\n    ref,\n    i;\n  if ('ref' in normalizedProps) {\n    normalizedProps = {};\n    for (i in props) {\n      if (i == 'ref') {\n        ref = props[i];\n      } else {\n        normalizedProps[i] = props[i];\n      }\n    }\n  }\n\n  /** @type {VNode & { __source: any; __self: any }} */\n  var vnode = {\n    type: type,\n    props: normalizedProps,\n    key: key,\n    ref: ref,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    __d: undefined,\n    __c: null,\n    constructor: undefined,\n    __v: --vnodeId,\n    __i: -1,\n    __u: 0,\n    __source: __source,\n    __self: __self\n  };\n\n  // If a Component VNode, check for and apply defaultProps.\n  // Note: `type` is often a String, and can be `undefined` in development.\n  if (typeof type === 'function' && (ref = type.defaultProps)) {\n    for (i in ref) if (typeof normalizedProps[i] === 'undefined') {\n      normalizedProps[i] = ref[i];\n    }\n  }\n  if (options.vnode) options.vnode(vnode);\n  return vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates) {\n  var vnode = createVNode(Fragment, {\n    tpl: templates,\n    exprs: [].slice.call(arguments, 1)\n  });\n  // Bypass render to string top level Fragment optimization\n  vnode.key = vnode.__v;\n  return vnode;\n}\nvar JS_TO_CSS = {};\nvar CSS_REGEX = /[A-Z]/g;\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n  if (options.attr) {\n    var result = options.attr(name, value);\n    if (typeof result === 'string') return result;\n  }\n  if (name === 'ref' || name === 'key') return '';\n  if (name === 'style' && typeof value === 'object') {\n    var str = '';\n    for (var prop in value) {\n      var val = value[prop];\n      if (val != null && val !== '') {\n        var _name = prop[0] == '-' ? prop : JS_TO_CSS[prop] || (JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n        var suffix = ';';\n        if (typeof val === 'number' &&\n        // Exclude custom-attributes\n        !_name.startsWith('--') && !IS_NON_DIMENSIONAL.test(_name)) {\n          suffix = 'px;';\n        }\n        str = str + _name + ':' + val + suffix;\n      }\n    }\n    return name + '=\"' + str + '\"';\n  }\n  if (value == null || value === false || typeof value === 'function' || typeof value === 'object') {\n    return '';\n  } else if (value === true) return name;\n  return name + '=\"' + encodeEntities(value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n  if (value == null || typeof value === 'boolean' || typeof value === 'function') {\n    return null;\n  }\n  if (typeof value === 'object') {\n    // Check for VNode\n    if (value.constructor === undefined) return value;\n    if (isArray(value)) {\n      for (var i = 0; i < value.length; i++) {\n        value[i] = jsxEscape(value[i]);\n      }\n      return value;\n    }\n  }\n  return encodeEntities('' + value);\n}\n\nexport { createVNode as jsx, jsxAttr, createVNode as jsxDEV, jsxEscape, jsxTemplate, createVNode as jsxs };\n//# sourceMappingURL=jsxRuntime.module.js.map\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) resolve(value);\n    else Promise.resolve(value).then(_next, _throw);\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n\n            _next(undefined);\n        });\n    };\n}\nexport { _async_to_generator as _ };\n","import { _ as _define_property } from \"./_define_property.js\";\n\nfunction _object_spread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(\n                Object.getOwnPropertySymbols(source).filter(function(sym) {\n                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                })\n            );\n        }\n\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n\n    return target;\n}\nexport { _object_spread as _ };\n","function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexport { _define_property as _ };\n","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport const DIFF = '__b';\nexport const RENDER = '__r';\nexport const DIFFED = 'diffed';\nexport const COMMIT = '__c';\nexport const SKIP_EFFECTS = '__s';\nexport const CATCH_ERROR = '__e';\n// VNode properties\nexport const COMPONENT = '__c';\nexport const CHILDREN = '__k';\nexport const PARENT = '__';\nexport const MASK = '__m';\n// Component properties\nexport const VNODE = '__v';\nexport const DIRTY = '__d';\nexport const FORCE = '__e';\nexport const NEXT_STATE = '__s';\nexport const CHILD_DID_SUSPEND = '__c';\nexport const RENDER_CALLBACKS = '__h';\nexport const HOOK = '__h';\n//# sourceMappingURL=constants.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nexport function isDirectOrDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a == 'object' && a !== null && typeof b == 'object' && b !== null && JSON.stringify(a) === JSON.stringify(b)) {\n        return true;\n    }\n    return false;\n}\nexport function isEmptyObject(obj) {\n    for (var _ in obj)\n        return false;\n    return true;\n}\nexport function isSdkVersionGt(major, minor) {\n    const lynxSdkVersion = SystemInfo.lynxSdkVersion || '1.0';\n    const version = lynxSdkVersion.split('.');\n    return Number(version[0]) > major || (Number(version[0]) == major && Number(version[1]) > minor);\n}\nexport function pick(obj, keys) {\n    const result = {};\n    for (const key of keys) {\n        if (key in obj) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=utils.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { isMtsEnabled } from './functionality.js';\nlet initValuePatch = [];\nconst initValueIdSet = /*#__PURE__*/ new Set();\n/**\n * @internal\n */\nexport function addWorkletRefInitValue(id, value) {\n    if (!isMtsEnabled()) {\n        return;\n    }\n    initValueIdSet.add(id);\n    initValuePatch.push([id, value]);\n}\n/**\n * @internal\n */\nexport function takeWorkletRefInitValuePatch() {\n    const res = initValuePatch;\n    initValuePatch = [];\n    return res;\n}\n//# sourceMappingURL=workletRefPool.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nlet reloadVersion = 0;\nfunction getReloadVersion() {\n    return reloadVersion;\n}\nfunction increaseReloadVersion() {\n    return ++reloadVersion;\n}\nexport { getReloadVersion, increaseReloadVersion };\n//# sourceMappingURL=pass.js.map","import { options } from 'preact';\nimport { takeGlobalSnapshotPatch } from './snapshotPatch.js';\nimport { LifecycleConstant } from '../../lifecycleConstant.js';\nimport { PerformanceTimingKeys, globalPipelineOptions, markTiming, markTimingLegacy, setPipeline, } from '../../lynx/performance.js';\nimport { CATCH_ERROR, COMMIT, RENDER_CALLBACKS, VNODE } from '../../renderToOpcodes/constants.js';\nimport { updateBackgroundRefs } from '../../snapshot/ref.js';\nimport { backgroundSnapshotInstanceManager } from '../../snapshot.js';\nimport { isEmptyObject } from '../../utils.js';\nimport { takeWorkletRefInitValuePatch } from '../../worklet/workletRefPool.js';\nimport { runDelayedUnmounts, takeDelayedUnmounts } from '../delayUnmount.js';\nimport { getReloadVersion } from '../pass.js';\nlet globalFlushOptions = {};\nconst globalCommitTaskMap = /*@__PURE__*/ new Map();\nlet nextCommitTaskId = 1;\nlet globalBackgroundSnapshotInstancesToRemove = [];\nlet patchesToCommit = [];\nfunction replaceCommitHook() {\n    const injectDebounceRendering = (debounceRendering) => {\n        return (f) => {\n            debounceRendering(() => {\n                f();\n                void commitToMainThread();\n            });\n        };\n    };\n    const defaultDebounceRendering = options.debounceRendering?.bind(options)\n        ?? Promise.prototype.then.bind(Promise.resolve());\n    let _debounceRendering = injectDebounceRendering(defaultDebounceRendering);\n    Object.defineProperty(options, 'debounceRendering', {\n        get() {\n            return _debounceRendering;\n        },\n        set(debounceRendering) {\n            _debounceRendering = injectDebounceRendering(debounceRendering);\n        },\n    });\n    const oldCommit = options[COMMIT];\n    const commit = async (vnode, commitQueue) => {\n        if (__LEPUS__) {\n            // for testing only\n            commitQueue.length = 0;\n            return;\n        }\n        const renderCallbacks = commitQueue.map((component) => {\n            const ret = {\n                component,\n                [RENDER_CALLBACKS]: component[RENDER_CALLBACKS],\n                [VNODE]: component[VNODE],\n            };\n            component[RENDER_CALLBACKS] = [];\n            return ret;\n        });\n        commitQueue.length = 0;\n        const delayedUnmounts = takeDelayedUnmounts();\n        const backgroundSnapshotInstancesToRemove = globalBackgroundSnapshotInstancesToRemove;\n        globalBackgroundSnapshotInstancesToRemove = [];\n        const commitTaskId = genCommitTaskId();\n        globalCommitTaskMap.set(commitTaskId, () => {\n            updateBackgroundRefs(commitTaskId);\n            runDelayedUnmounts(delayedUnmounts);\n            oldCommit?.(vnode, renderCallbacks);\n            renderCallbacks.some(wrapper => {\n                try {\n                    wrapper[RENDER_CALLBACKS].some((cb) => {\n                        cb.call(wrapper.component);\n                    });\n                }\n                catch (e) {\n                    options[CATCH_ERROR](e, wrapper[VNODE]);\n                }\n            });\n            if (backgroundSnapshotInstancesToRemove.length) {\n                setTimeout(() => {\n                    backgroundSnapshotInstancesToRemove.forEach(id => {\n                        backgroundSnapshotInstanceManager.values.delete(id);\n                    });\n                }, 10000);\n            }\n        });\n        const snapshotPatch = takeGlobalSnapshotPatch();\n        const workletRefInitValuePatch = takeWorkletRefInitValuePatch();\n        if (!snapshotPatch && workletRefInitValuePatch.length === 0) {\n            // before hydration, skip patch\n            return;\n        }\n        const patch = {\n            id: commitTaskId,\n        };\n        // TODO: check all fields in `flushOptions` from runtime3\n        if (snapshotPatch?.length) {\n            patch.snapshotPatch = snapshotPatch;\n        }\n        if (workletRefInitValuePatch.length) {\n            patch.workletRefInitValuePatch = workletRefInitValuePatch;\n        }\n        patchesToCommit.push(patch);\n    };\n    options[COMMIT] = commit;\n}\nasync function commitToMainThread() {\n    if (patchesToCommit.length === 0) {\n        return;\n    }\n    markTimingLegacy(PerformanceTimingKeys.update_diff_vdom_end);\n    markTiming(PerformanceTimingKeys.diff_vdom_end);\n    const flushOptions = globalFlushOptions;\n    globalFlushOptions = {};\n    const patchList = {\n        patchList: patchesToCommit,\n    };\n    patchesToCommit = [];\n    if (!isEmptyObject(flushOptions)) {\n        patchList.flushOptions = flushOptions;\n    }\n    await commitPatchUpdate(patchList, {});\n    for (let i = 0; i < patchList.patchList.length; i++) {\n        const patch = patchList.patchList[i];\n        const commitTask = globalCommitTaskMap.get(patch.id);\n        if (commitTask) {\n            commitTask();\n            globalCommitTaskMap.delete(patch.id);\n        }\n    }\n}\nfunction commitPatchUpdate(patchList, patchOptions) {\n    return new Promise(resolve => {\n        // console.debug('********** JS update:');\n        // printSnapshotInstance(\n        //   (backgroundSnapshotInstanceManager.values.get(1) || backgroundSnapshotInstanceManager.values.get(-1))!,\n        // );\n        // console.debug('commitPatchUpdate: ', JSON.stringify(patchList));\n        if (__PROFILE__) {\n            console.profile('commitChanges');\n        }\n        markTiming(PerformanceTimingKeys.pack_changes_start);\n        const obj = {\n            data: JSON.stringify(patchList),\n            patchOptions: {\n                ...patchOptions,\n                reloadVersion: getReloadVersion(),\n            },\n        };\n        markTiming(PerformanceTimingKeys.pack_changes_end);\n        if (globalPipelineOptions) {\n            obj.patchOptions.pipelineOptions = globalPipelineOptions;\n            setPipeline(undefined);\n        }\n        lynx.getNativeApp().callLepusMethod(LifecycleConstant.patchUpdate, obj, resolve);\n        if (__PROFILE__) {\n            console.profileEnd();\n        }\n    });\n}\nfunction genCommitTaskId() {\n    return nextCommitTaskId++;\n}\nfunction replaceRequestAnimationFrame() {\n    // to make afterPaintEffects run faster\n    const resolvedPromise = Promise.resolve();\n    options.requestAnimationFrame = (cb) => {\n        void resolvedPromise.then(cb);\n    };\n}\n/**\n * @internal\n */\nexport { commitPatchUpdate, commitToMainThread, genCommitTaskId, globalBackgroundSnapshotInstancesToRemove, globalCommitTaskMap, globalFlushOptions, nextCommitTaskId, replaceCommitHook, replaceRequestAnimationFrame, };\n//# sourceMappingURL=commit.js.map","function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n\n    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n\n    return target;\n}\nexport { _object_spread_props as _ };\n","import { nextCommitTaskId } from '../lifecycle/patch/commit.js';\nimport { SnapshotInstance, backgroundSnapshotInstanceManager } from '../snapshot.js';\nimport { workletUnRef } from './workletRef.js';\nlet globalRefPatch = {};\nconst globalRefsToRemove = /* @__PURE__ */ new Map();\nconst globalRefsToSet = /* @__PURE__ */ new Map();\nlet nextRefId = 1;\nfunction unref(snapshot, recursive) {\n    snapshot.__ref_set?.forEach(v => {\n        globalRefPatch[v] = null;\n    });\n    snapshot.__ref_set?.clear();\n    snapshot.__worklet_ref_set?.forEach(v => {\n        if (v) {\n            workletUnRef(v);\n        }\n    });\n    snapshot.__worklet_ref_set?.clear();\n    if (recursive) {\n        snapshot.childNodes.forEach(it => {\n            unref(it, recursive);\n        });\n    }\n}\nfunction applyRef(ref, value) {\n    // TODO: ref: exceptions thrown in user functions should be able to be caught by an Error Boundary\n    if (typeof ref == 'function') {\n        const hasRefUnmount = typeof ref._unmount == 'function';\n        if (hasRefUnmount) {\n            // @ts-ignore TS doesn't like moving narrowing checks into variables\n            ref._unmount();\n        }\n        if (!hasRefUnmount || value != null) {\n            // Store the cleanup function on the function\n            // instance object itself to avoid shape\n            // transitioning vnode\n            ref._unmount = ref(value);\n        }\n    }\n    else\n        ref.current = value;\n}\nfunction updateBackgroundRefs(commitId) {\n    const oldRefMap = globalRefsToRemove.get(commitId);\n    if (oldRefMap) {\n        globalRefsToRemove.delete(commitId);\n        for (const ref of oldRefMap.values()) {\n            applyRef(ref, null);\n        }\n    }\n    const newRefMap = globalRefsToSet.get(commitId);\n    if (newRefMap) {\n        globalRefsToSet.delete(commitId);\n        for (const sign in newRefMap) {\n            const ref = backgroundSnapshotInstanceManager.getValueBySign(sign);\n            if (ref) {\n                // TODO: ref: support __REF_FIRE_IMMEDIATELY__\n                const v = newRefMap[sign] && lynx.createSelectorQuery().selectUniqueID(newRefMap[sign]);\n                applyRef(ref, v);\n            }\n        }\n    }\n}\nfunction updateRef(snapshot, expIndex, oldValue, elementIndex, spreadKey) {\n    const value = snapshot.__values[expIndex];\n    let ref;\n    if (!value) {\n        ref = undefined;\n    }\n    else if (typeof value === 'string') {\n        ref = value;\n    }\n    else {\n        ref = `${snapshot.__id}:${expIndex}:${spreadKey}`;\n    }\n    snapshot.__values[expIndex] = ref;\n    if (snapshot.__elements && ref) {\n        __SetAttribute(snapshot.__elements[elementIndex], 'has-react-ref', true);\n        const uid = __GetElementUniqueID(snapshot.__elements[elementIndex]);\n        globalRefPatch[ref] = uid;\n        snapshot.__ref_set ??= new Set();\n        snapshot.__ref_set.add(ref);\n    }\n    if (oldValue !== ref) {\n        snapshot.__ref_set?.delete(oldValue);\n    }\n}\nfunction takeGlobalRefPatchMap() {\n    const patch = globalRefPatch;\n    globalRefPatch = {};\n    return patch;\n}\nfunction transformRef(ref) {\n    if (ref === undefined || ref === null) {\n        return ref;\n    }\n    if (typeof ref === 'function' || (typeof ref === 'object' && 'current' in ref)) {\n        if ('__ref' in ref) {\n            return ref;\n        }\n        return Object.defineProperty(ref, '__ref', { value: nextRefId++ });\n    }\n    throw new Error(`Elements' \"ref\" property should be a function, or an object created `\n        + `by createRef(), but got [${typeof ref}] instead`);\n}\nfunction markRefToRemove(sign, ref) {\n    if (!ref) {\n        return;\n    }\n    let oldRefs = globalRefsToRemove.get(nextCommitTaskId);\n    if (!oldRefs) {\n        oldRefs = new Map();\n        globalRefsToRemove.set(nextCommitTaskId, oldRefs);\n    }\n    oldRefs.set(sign, ref);\n}\nexport { updateRef, takeGlobalRefPatchMap, updateBackgroundRefs, unref, transformRef, globalRefsToRemove, globalRefsToSet, markRefToRemove, };\n//# sourceMappingURL=ref.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { SnapshotInstance } from '../snapshot.js';\nimport { updateEvent } from './event.js';\nimport { BackgroundSnapshotInstance } from '../backgroundSnapshot.js';\nimport { transformRef, updateRef } from './ref.js';\nimport { updateWorkletEvent } from './workletEvent.js';\nimport { updateWorkletRef } from './workletRef.js';\nimport { updateGesture } from './gesture.js';\nimport { platformInfoAttributes, updateListItemPlatformInfo } from './platformInfo.js';\nimport { isDirectOrDeepEqual, isEmptyObject, pick } from '../utils.js';\nimport { __pendingListUpdates, ListUpdateInfoRecording } from '../list.js';\nconst eventRegExp = /^(([A-Za-z-]*):)?(bind|catch|capture-bind|capture-catch|global-bind)([A-Za-z]+)$/;\nconst eventTypeMap = {\n    bind: 'bindEvent',\n    catch: 'catchEvent',\n    'capture-bind': 'capture-bind',\n    'capture-catch': 'capture-catch',\n    'global-bind': 'global-bindEvent',\n};\nconst noFlattenAttributes = /* @__PURE__ */ new Set([\n    'name',\n    'clip-radius',\n    'overlap',\n    'exposure-scene',\n    'exposure-id',\n]);\nfunction updateSpread(snapshot, index, oldValue, elementIndex) {\n    oldValue ||= {};\n    let newValue = snapshot.__values[index]; // compiler guarantee this must be an object;\n    // @ts-ignore\n    const list = snapshot.__parent;\n    if (list?.__snapshot_def.isListHolder) {\n        const oldPlatformInfo = pick(oldValue, platformInfoAttributes);\n        const platformInfo = pick(newValue, platformInfoAttributes);\n        if (!isDirectOrDeepEqual(oldPlatformInfo, platformInfo)) {\n            (__pendingListUpdates.values[list.__id] ??= new ListUpdateInfoRecording(list)).onSetAttribute(snapshot, platformInfo, oldPlatformInfo);\n            snapshot.__listItemPlatformInfo = platformInfo;\n            // The fakeSnapshot is missing `__parent`, so no `ListUpdateInfoRecording#onSetAttribute` will be called\n            const fakeSnapshot = {\n                __values: {\n                    get [index]() {\n                        return platformInfo;\n                    },\n                },\n                __id: snapshot.__id,\n                __elements: snapshot.__elements,\n            };\n            updateListItemPlatformInfo(fakeSnapshot, index, oldPlatformInfo, elementIndex);\n        }\n    }\n    if (!snapshot.__elements) {\n        return;\n    }\n    if ('__spread' in newValue) {\n        // first screen\n        newValue = transformSpread(snapshot, index, newValue);\n        snapshot.__values[index] = newValue;\n    }\n    const dataset = {};\n    let match = null;\n    for (const key in newValue) {\n        const v = newValue[key];\n        if (v !== oldValue[key]) {\n            if (key === 'className') {\n                __SetClasses(snapshot.__elements[elementIndex], v);\n            }\n            else if (key === 'style') {\n                __SetInlineStyles(snapshot.__elements[elementIndex], v);\n            }\n            else if (key === 'id') {\n                __SetID(snapshot.__elements[elementIndex], v);\n            }\n            else if (key.startsWith('data-')) {\n                // collected below\n            }\n            else if (key === 'ref') {\n                snapshot.__ref_set ??= new Set();\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return v;\n                        },\n                        set [index](value) {\n                            // Modifications to the ref value should be reflected in the corresponding position of the spread.\n                            newValue[key] = value;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                    __ref_set: snapshot.__ref_set,\n                };\n                updateRef(fakeSnapshot, index, oldValue[key], elementIndex, key);\n            }\n            else if (key.endsWith(':ref')) {\n                snapshot.__worklet_ref_set ??= new Set();\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return v;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                    __worklet_ref_set: snapshot.__worklet_ref_set,\n                };\n                updateWorkletRef(fakeSnapshot, index, oldValue[key], elementIndex, key.slice(0, -4));\n            }\n            else if (key.endsWith(':gesture')) {\n                const workletType = key.slice(0, -8);\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return v;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                };\n                updateGesture(fakeSnapshot, index, oldValue[key], elementIndex, workletType);\n            }\n            else if ((match = key.match(eventRegExp))) {\n                const workletType = match[2];\n                const eventType = eventTypeMap[match[3]];\n                const eventName = match[4];\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return v;\n                        },\n                        set [index](value) {\n                            // Modifications to the event value should be reflected in the corresponding position of the spread.\n                            newValue[key] = value;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                };\n                if (workletType) {\n                    updateWorkletEvent(fakeSnapshot, index, oldValue[key], elementIndex, workletType, eventType, eventName);\n                }\n                else {\n                    updateEvent(fakeSnapshot, index, oldValue[key], elementIndex, eventType, eventName, key);\n                }\n            }\n            else if (platformInfoAttributes.has(key)) {\n                // ignore\n            }\n            else {\n                __SetAttribute(snapshot.__elements[elementIndex], key, v);\n            }\n        }\n        // collect data regardless of whether it has changed\n        if (key.startsWith('data-')) {\n            dataset[key.slice(5)] = v;\n        }\n    }\n    let hasOldDataset = false;\n    for (const key in oldValue) {\n        if (!(key in newValue)) {\n            if (key === 'className') {\n                __SetClasses(snapshot.__elements[elementIndex], '');\n            }\n            else if (key === 'style') {\n                __SetInlineStyles(snapshot.__elements[elementIndex], '');\n            }\n            else if (key === 'id') {\n                __SetID(snapshot.__elements[elementIndex], null);\n            }\n            else if (key.startsWith('data-')) {\n                // collected below\n            }\n            else if (key === 'ref') {\n                snapshot.__ref_set ??= new Set();\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return undefined;\n                        },\n                        set [index](value) {\n                            // Modifications to the ref value should be reflected in the corresponding position of the spread.\n                            newValue[key] = value;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                    __ref_set: snapshot.__ref_set,\n                };\n                updateRef(fakeSnapshot, index, oldValue[key], elementIndex, key);\n            }\n            else if (key.endsWith(':ref')) {\n                snapshot.__worklet_ref_set ??= new Set();\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return undefined;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                    __worklet_ref_set: snapshot.__worklet_ref_set,\n                };\n                updateWorkletRef(fakeSnapshot, index, oldValue[key], elementIndex, key.slice(0, -4));\n            }\n            else if (key.endsWith(':gesture')) {\n                const workletType = key.slice(0, -8);\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return undefined;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                };\n                updateGesture(fakeSnapshot, index, oldValue[key], elementIndex, workletType);\n            }\n            else if ((match = key.match(eventRegExp))) {\n                const workletType = match[2];\n                const eventType = eventTypeMap[match[3]];\n                const eventName = match[4];\n                const fakeSnapshot = {\n                    __values: {\n                        get [index]() {\n                            return undefined;\n                        },\n                        set [index](value) {\n                            newValue[key] = value;\n                        },\n                    },\n                    __id: snapshot.__id,\n                    __elements: snapshot.__elements,\n                };\n                if (workletType) {\n                    updateWorkletEvent(fakeSnapshot, index, oldValue[key], elementIndex, workletType, eventType, eventName);\n                }\n                else {\n                    updateEvent(fakeSnapshot, index, oldValue[key], elementIndex, eventType, eventName, key);\n                }\n            }\n            else if (platformInfoAttributes.has(key)) {\n                // ignore\n            }\n            else {\n                __SetAttribute(snapshot.__elements[elementIndex], key, null);\n            }\n        }\n        // collect data regardless of whether it has changed\n        if (key.startsWith('data-')) {\n            hasOldDataset = true;\n        }\n    }\n    // TODO: compare dataset before commit it to native?\n    if (hasOldDataset || !isEmptyObject(dataset)) {\n        __SetDataset(snapshot.__elements[elementIndex], dataset);\n    }\n}\nfunction transformSpread(snapshot, index, spread) {\n    const result = {};\n    let hasNoFlattenAttributes = false;\n    for (const key in spread) {\n        let value = spread[key];\n        if (key === '__spread') { }\n        else if (key === 'class' || key === 'className') {\n            value ??= '';\n            result['className'] = value;\n        }\n        else if (key === 'ref') {\n            // @ts-ignore\n            result[key] = transformRef(value)?.__ref;\n        }\n        else if (typeof value === 'function') {\n            result[key] = `${snapshot.__id}:${index}:${key}`;\n        }\n        else {\n            if (!hasNoFlattenAttributes && noFlattenAttributes.has(key)) {\n                hasNoFlattenAttributes = true;\n            }\n            result[key] = value;\n        }\n    }\n    if (hasNoFlattenAttributes) {\n        result['flatten'] = false;\n    }\n    return result;\n}\nexport { updateSpread, transformSpread };\n//# sourceMappingURL=spread.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { takeWorkletRefInitValuePatch } from './workletRefPool.js';\nexport const destroyTasks = [];\nexport function destroyWorklet() {\n    takeWorkletRefInitValuePatch();\n    for (const task of destroyTasks) {\n        task();\n    }\n    destroyTasks.length = 0;\n}\n//# sourceMappingURL=destroy.js.map","class IndexMap {\n    lastIndex = 0;\n    indexMap = new Map();\n    add(value) {\n        const index = ++this.lastIndex;\n        this.indexMap.set(index, value);\n        return index;\n    }\n    get(index) {\n        return this.indexMap.get(index);\n    }\n    remove(index) {\n        this.indexMap.delete(index);\n    }\n}\nexport { IndexMap };\n//# sourceMappingURL=indexMap.js.map","import { IndexMap } from './indexMap.js';\n/**\n * `WorkletExecIdMap` ensures the worklet object is not released in js context when the main thread is still holding the\n * worklet object (or any of its jsFnHandles). The worklet object holds the js functions which might be called by `runOnBackground()`.\n * If the worklet object is incorrectly released earlier, the `runOnBackground()` would result in failure.\n *\n * Every time a worklet object is sent to the main thread, an `execId` is distributed and will be sent to element\n * context with the worklet object. This relationship is recorded in this class. When all the references to the\n * worklet object are released in the main thread, a message will be sent back to remove the record here.\n *\n * @internal\n */\nexport class WorkletExecIdMap extends IndexMap {\n    add(worklet) {\n        const execId = super.add(worklet);\n        worklet._execId = execId;\n        return execId;\n    }\n    findJsFnHandle(execId, fnId) {\n        const worklet = this.get(execId);\n        if (!worklet) {\n            return undefined;\n        }\n        const f = (obj) => {\n            if (obj === null || typeof obj !== 'object') {\n                return undefined;\n            }\n            if ('_jsFnId' in obj && obj._jsFnId === fnId) {\n                return obj;\n            }\n            for (const i in obj) {\n                const result = f(obj[i]);\n                if (result) {\n                    return result;\n                }\n            }\n            return undefined;\n        };\n        return f(worklet);\n    }\n}\n//# sourceMappingURL=execMap.js.map","import { isMtsEnabled, isRunOnBackgroundEnabled } from './functionality.js';\nimport { registerWorkletCtx } from './runOnBackground.js';\n/**\n * @internal\n */\nexport function onPostWorkletCtx(afterValue) {\n    if (!isMtsEnabled() && afterValue) {\n        lynx.reportError(new Error('Main thread script requires Lynx sdk version 2.14'));\n        return null;\n    }\n    if (!afterValue || !isRunOnBackgroundEnabled()) {\n        return afterValue;\n    }\n    registerWorkletCtx(afterValue);\n    return afterValue;\n}\n//# sourceMappingURL=ctx.js.map","import { onPostWorkletCtx } from '../worklet/ctx.js';\nimport { GestureTypeInner } from './types.js';\nexport function processGestureBackground(gesture) {\n    if (gesture.type === GestureTypeInner.COMPOSED) {\n        for (const subGesture of gesture.gestures) {\n            processGestureBackground(subGesture);\n        }\n    }\n    else {\n        const baseGesture = gesture;\n        for (const [name, value] of Object.entries(baseGesture.callbacks)) {\n            baseGesture.callbacks[name] = onPostWorkletCtx(value);\n        }\n    }\n}\n//# sourceMappingURL=processGestureBagkround.js.map","import { diffArrayAction, diffArrayLepus } from './hydrate.js';\nimport { globalBackgroundSnapshotInstancesToRemove } from './lifecycle/patch/commit.js';\nimport { markRefToRemove } from './snapshot/ref.js';\nimport { transformSpread } from './snapshot/spread.js';\nimport { DynamicPartType, backgroundSnapshotInstanceManager, snapshotManager, traverseSnapshotInstance, } from './snapshot.js';\nimport { SnapshotOperation, __globalSnapshotPatch, initGlobalSnapshotPatch, takeGlobalSnapshotPatch, } from './lifecycle/patch/snapshotPatch.js';\nimport { isDirectOrDeepEqual } from './utils.js';\nimport { onPostWorkletCtx } from './worklet/ctx.js';\nimport { processGestureBackground } from './gesture/processGestureBagkround.js';\nimport { globalPipelineOptions } from './lynx/performance.js';\nexport class BackgroundSnapshotInstance {\n    type;\n    constructor(type) {\n        this.type = type;\n        let id;\n        id = this.__id = backgroundSnapshotInstanceManager.nextId += 1;\n        backgroundSnapshotInstanceManager.values.set(id, this);\n        __globalSnapshotPatch?.push(SnapshotOperation.CreateElement, type, id);\n    }\n    __id;\n    __values;\n    __parent = null;\n    __firstChild = null;\n    __lastChild = null;\n    __previousSibling = null;\n    __nextSibling = null;\n    get parentNode() {\n        return this.__parent;\n    }\n    get nextSibling() {\n        return this.__nextSibling;\n    }\n    // get isConnected() {\n    //   return !!this.__parent;\n    // }\n    contains(child) {\n        return child.parentNode === this;\n    }\n    // TODO: write tests for this\n    // This will be called in `lazy`/`Suspense`.\n    // We currently ignore this since we did not find a way to test.\n    /* v8 ignore start */\n    appendChild(child) {\n        return this.insertBefore(child);\n    }\n    /* v8 ignore stop */\n    insertBefore(node, beforeNode) {\n        __globalSnapshotPatch?.push(SnapshotOperation.InsertBefore, this.__id, node.__id, beforeNode?.__id);\n        // If the node already has a parent, remove it from its current parent\n        const p = node.__parent;\n        if (p) {\n            if (node.__previousSibling) {\n                node.__previousSibling.__nextSibling = node.__nextSibling;\n            }\n            else {\n                p.__firstChild = node.__nextSibling;\n            }\n            if (node.__nextSibling) {\n                node.__nextSibling.__previousSibling = node.__previousSibling;\n            }\n            else {\n                p.__lastChild = node.__previousSibling;\n            }\n        }\n        // If beforeNode is not provided, add the new node as the last child\n        if (beforeNode) {\n            // If beforeNode is provided, insert the new node before beforeNode\n            if (beforeNode.__previousSibling) {\n                beforeNode.__previousSibling.__nextSibling = node;\n                node.__previousSibling = beforeNode.__previousSibling;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            beforeNode.__previousSibling = node;\n            node.__nextSibling = beforeNode;\n            node.__parent = this;\n        }\n        else {\n            if (this.__lastChild) {\n                this.__lastChild.__nextSibling = node;\n                node.__previousSibling = this.__lastChild;\n            }\n            else {\n                this.__firstChild = node;\n                node.__previousSibling = null;\n            }\n            this.__lastChild = node;\n            node.__parent = this;\n            node.__nextSibling = null;\n        }\n    }\n    removeChild(node) {\n        __globalSnapshotPatch?.push(SnapshotOperation.RemoveChild, this.__id, node.__id);\n        if (node.__parent !== this) {\n            throw new Error('The node to be removed is not a child of this node.');\n        }\n        if (node.__previousSibling) {\n            node.__previousSibling.__nextSibling = node.__nextSibling;\n        }\n        else {\n            this.__firstChild = node.__nextSibling;\n        }\n        if (node.__nextSibling) {\n            node.__nextSibling.__previousSibling = node.__previousSibling;\n        }\n        else {\n            this.__lastChild = node.__previousSibling;\n        }\n        node.__parent = null;\n        node.__previousSibling = null;\n        node.__nextSibling = null;\n        traverseSnapshotInstance(node, v => {\n            v.__parent = null;\n            globalBackgroundSnapshotInstancesToRemove.push(v.__id);\n        });\n    }\n    get childNodes() {\n        const nodes = [];\n        let node = this.__firstChild;\n        while (node) {\n            nodes.push(node);\n            if (node === this.__lastChild) {\n                break;\n            }\n            node = node.__nextSibling;\n        }\n        return nodes;\n    }\n    setAttribute(key, value) {\n        if (__PROFILE__) {\n            console.profile('setAttribute');\n        }\n        if (key === 'values') {\n            if (__globalSnapshotPatch) {\n                const oldValues = this.__values;\n                if (oldValues) {\n                    for (let index = 0; index < value.length; index++) {\n                        const { needUpdate, valueToCommit } = this.setAttributeImpl(value[index], oldValues[index], index);\n                        if (needUpdate) {\n                            __globalSnapshotPatch?.push(SnapshotOperation.SetAttribute, this.__id, index, valueToCommit);\n                        }\n                    }\n                }\n                else {\n                    const patch = [];\n                    const length = value.length;\n                    for (let index = 0; index < length; ++index) {\n                        const { valueToCommit } = this.setAttributeImpl(value[index], null, index);\n                        patch[index] = valueToCommit;\n                    }\n                    __globalSnapshotPatch?.push(SnapshotOperation.SetAttributes, this.__id, patch);\n                }\n            }\n            this.__values = value;\n            if (__PROFILE__) {\n                console.profileEnd();\n            }\n            return;\n        }\n        // old path (`<__snapshot_xxxx_xxxx __0={} __1={} />` or `this.setAttribute(0, xxx)`)\n        // is reserved as slow path\n        const index = typeof key === 'string' ? Number(key.slice(2)) : key;\n        (this.__values ??= [])[index] = value;\n        __globalSnapshotPatch?.push(SnapshotOperation.SetAttribute, this.__id, index, value);\n        if (__PROFILE__) {\n            console.profileEnd();\n        }\n    }\n    setAttributeImpl(newValue, oldValue, index) {\n        if (!newValue) {\n            if (oldValue && oldValue.__ref) {\n                markRefToRemove(`${this.__id}:${index}:`, oldValue);\n            }\n            return { needUpdate: oldValue !== newValue, valueToCommit: newValue };\n        }\n        const newType = typeof newValue;\n        if (newType === 'object') {\n            if (newValue.__spread) {\n                const oldSpread = oldValue ? oldValue.__spread : oldValue;\n                const newSpread = transformSpread(this, index, newValue);\n                const needUpdate = !isDirectOrDeepEqual(oldSpread, newSpread);\n                // use __spread to cache the transform result for next diff\n                newValue.__spread = newSpread;\n                if (needUpdate) {\n                    if (oldSpread && oldSpread.ref) {\n                        markRefToRemove(`${this.__id}:${index}:ref`, oldValue.ref);\n                    }\n                    for (let key in newSpread) {\n                        const newSpreadValue = newSpread[key];\n                        if (!newSpreadValue) {\n                            continue;\n                        }\n                        if (newSpreadValue._wkltId) {\n                            newSpread[key] = onPostWorkletCtx(newSpreadValue);\n                        }\n                        else if (newSpreadValue.__isGesture) {\n                            processGestureBackground(newSpreadValue);\n                        }\n                        else if (key == '__lynx_timing_flag' && oldSpread?.[key] != newSpreadValue) {\n                            if (globalPipelineOptions) {\n                                globalPipelineOptions.needTimestamps = true;\n                            }\n                        }\n                    }\n                }\n                return { needUpdate, valueToCommit: newSpread };\n            }\n            if (newValue.__ref) {\n                // force update to update ref value\n                // TODO: ref: optimize this. The ref update maybe can be done on the background thread to reduce updating.\n                // The old ref must have a place to be stored because it needs to be cleared when the main thread returns.\n                markRefToRemove(`${this.__id}:${index}:`, oldValue);\n                // update ref. On the main thread, the ref id will be replaced with value's sign when updating.\n                return { needUpdate: true, valueToCommit: newValue.__ref };\n            }\n            if (newValue._wkltId) {\n                return { needUpdate: true, valueToCommit: onPostWorkletCtx(newValue) };\n            }\n            if (newValue.__isGesture) {\n                processGestureBackground(newValue);\n                return { needUpdate: true, valueToCommit: newValue };\n            }\n            if (newValue.__ltf) {\n                // __lynx_timing_flag\n                if (globalPipelineOptions && oldValue?.__ltf != newValue.__ltf) {\n                    globalPipelineOptions.needTimestamps = true;\n                    return { needUpdate: true, valueToCommit: newValue };\n                }\n                return { needUpdate: false, valueToCommit: newValue };\n            }\n            return { needUpdate: !isDirectOrDeepEqual(oldValue, newValue), valueToCommit: newValue };\n        }\n        if (newType === 'function') {\n            if (newValue.__ref) {\n                markRefToRemove(`${this.__id}:${index}:`, oldValue);\n                return { needUpdate: true, valueToCommit: newValue.__ref };\n            }\n            /* event */\n            return { needUpdate: !oldValue, valueToCommit: 1 };\n        }\n        return { needUpdate: oldValue !== newValue, valueToCommit: newValue };\n    }\n}\nexport function hydrate(before, after) {\n    initGlobalSnapshotPatch();\n    const helper2 = (afters, parentId) => {\n        for (const child of afters) {\n            const id = child.__id;\n            __globalSnapshotPatch.push(SnapshotOperation.CreateElement, child.type, id);\n            const values = child.__values;\n            if (values) {\n                child.__values = undefined;\n                child.setAttribute('values', values);\n            }\n            helper2(child.childNodes, id);\n            __globalSnapshotPatch.push(SnapshotOperation.InsertBefore, parentId, id, undefined);\n        }\n    };\n    const helper = (before, after) => {\n        backgroundSnapshotInstanceManager.updateId(after.__id, before.id);\n        after.__values?.forEach((value, index) => {\n            const old = before.values[index];\n            if (value) {\n                if (value.__spread) {\n                    // `value.__spread` my contain event ids using snapshot ids before hydration. Remove it.\n                    delete value.__spread;\n                    value = transformSpread(after, index, value);\n                    for (let key in value) {\n                        if (value[key] && value[key]._wkltId) {\n                            onPostWorkletCtx(value[key]);\n                        }\n                        else if (value[key] && value[key].__isGesture) {\n                            processGestureBackground(value[key]);\n                        }\n                    }\n                    after.__values[index].__spread = value;\n                }\n                else if (value.__ref) {\n                    if (old) {\n                        // skip patch\n                        value = old;\n                    }\n                    else {\n                        value = value.__ref;\n                    }\n                }\n                else if (typeof value === 'function') {\n                    value = `${after.__id}:${index}:`;\n                }\n            }\n            if (value && value._wkltId) {\n                onPostWorkletCtx(value);\n            }\n            else if (value && value.__isGesture) {\n                processGestureBackground(value);\n            }\n            if (!isDirectOrDeepEqual(value, old)) {\n                __globalSnapshotPatch.push(SnapshotOperation.SetAttribute, after.__id, index, value);\n            }\n        });\n        const { slot } = snapshotManager.values.get(after.type);\n        const beforeChildNodes = before.children || [];\n        const afterChildNodes = after.childNodes;\n        if (!slot) {\n            return;\n        }\n        slot.forEach(([type], index) => {\n            switch (type) {\n                case DynamicPartType.Slot:\n                case DynamicPartType.MultiChildren: {\n                    // TODO: the following null assertions are not 100% safe\n                    const v1 = beforeChildNodes[index];\n                    const v2 = afterChildNodes[index];\n                    helper(v1, v2);\n                    break;\n                }\n                case DynamicPartType.Children:\n                case DynamicPartType.ListChildren: {\n                    const diffResult = diffArrayLepus(beforeChildNodes, afterChildNodes, (a, b) => a.type === b.type, (a, b) => {\n                        helper(a, b);\n                    });\n                    diffArrayAction(beforeChildNodes, diffResult, (node, target) => {\n                        __globalSnapshotPatch.push(SnapshotOperation.CreateElement, node.type, node.__id);\n                        helper2(node.childNodes, node.__id);\n                        const values = node.__values;\n                        if (values) {\n                            node.__values = undefined;\n                            node.setAttribute('values', values);\n                        }\n                        __globalSnapshotPatch.push(SnapshotOperation.InsertBefore, before.id, node.__id, target?.id);\n                        return undefined;\n                    }, node => {\n                        __globalSnapshotPatch.push(SnapshotOperation.RemoveChild, before.id, node.id);\n                    }, (node, target) => {\n                        // changedList.push([SnapshotOperation.RemoveChild, before.id, node.id]);\n                        __globalSnapshotPatch.push(SnapshotOperation.InsertBefore, before.id, node.id, target?.id);\n                    });\n                    break;\n                }\n            }\n        });\n    };\n    helper(before, after);\n    return takeGlobalSnapshotPatch();\n}\n//# sourceMappingURL=backgroundSnapshot.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { BackgroundSnapshotInstance } from './backgroundSnapshot.js';\nimport { SnapshotInstance } from './snapshot.js';\nconst document = {};\nfunction setupBackgroundDocument() {\n    document.createElement = function (type) {\n        return new BackgroundSnapshotInstance(type);\n    };\n    document.createElementNS = function (_ns, type) {\n        return new BackgroundSnapshotInstance(type);\n    };\n    document.createTextNode = function (text) {\n        const i = new BackgroundSnapshotInstance(null);\n        i.setAttribute(0, text);\n        Object.defineProperty(i, 'data', {\n            set(v) {\n                i.setAttribute(0, v);\n            },\n        });\n        return i;\n    };\n}\nfunction setupDocument() {\n    document.createElement = function (type) {\n        return new SnapshotInstance(type);\n    };\n    document.createElementNS = function (_ns, type) {\n        return new SnapshotInstance(type);\n    };\n    document.createTextNode = function (text) {\n        const i = new SnapshotInstance(null);\n        i.setAttribute(0, text);\n        Object.defineProperty(i, 'data', {\n            set(v) {\n                i.setAttribute(0, v);\n            },\n        });\n        return i;\n    };\n}\n// if (__JS__) {\n//   setupBackgroundDocument();\n// } else if (__LEPUS__) {\n//   setupDocument();\n// }\nexport { setupBackgroundDocument, setupDocument, document };\n//# sourceMappingURL=document.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { render } from 'preact';\nimport { renderOpcodesInto } from '../opcodes.js';\nimport { render as renderToString } from '../renderToOpcodes/index.js';\nimport { __root } from '../root.js';\nimport { commitToMainThread } from './patch/commit.js';\nfunction renderMainThread() {\n    /* v8 ignore start */\n    if (process.env['NODE_ENV'] === 'test' && typeof __TESTING_FORCE_RENDER_TO_OPCODE__ !== 'undefined'\n        && !__TESTING_FORCE_RENDER_TO_OPCODE__) {\n        render(__root.__jsx, __root);\n    }\n    else {\n        let opcodes;\n        try {\n            if (__PROFILE__) {\n                console.profile('renderToString');\n            }\n            // @ts-ignore\n            opcodes = renderToString(__root.__jsx);\n        }\n        catch (e) {\n            lynx.reportError(e);\n            opcodes = [];\n        }\n        finally {\n            if (__PROFILE__) {\n                console.profileEnd();\n            }\n        }\n        if (__PROFILE__) {\n            console.profile('renderOpcodesInto');\n        }\n        renderOpcodesInto(opcodes, __root);\n        if (__ENABLE_SSR__) {\n            __root.__opcodes = opcodes;\n        }\n        if (__PROFILE__) {\n            console.profileEnd();\n        }\n    }\n    /* v8 ignore stop */\n}\nfunction renderBackground(vnode, parent) {\n    render(vnode, parent);\n    void commitToMainThread();\n}\nexport { renderMainThread, renderBackground };\n//# sourceMappingURL=render.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { __root } from '../root.js';\nimport { globalCommitTaskMap } from './patch/commit.js';\nimport { renderBackground } from './render.js';\nfunction destroyBackground() {\n    if (__PROFILE__) {\n        console.profile('destroyBackground');\n    }\n    renderBackground(null, __root);\n    globalCommitTaskMap.forEach(task => {\n        task();\n    });\n    globalCommitTaskMap.clear();\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n}\nexport { destroyBackground };\n//# sourceMappingURL=destroy.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { hydrate } from '../hydrate.js';\nimport { LifecycleConstant } from '../lifecycleConstant.js';\nimport { __pendingListUpdates } from '../list.js';\nimport { __root, setRoot } from '../root.js';\nimport { takeGlobalRefPatchMap } from '../snapshot/ref.js';\nimport { SnapshotInstance, __page, snapshotInstanceManager } from '../snapshot.js';\nimport { isEmptyObject } from '../utils.js';\nimport { destroyBackground } from './destroy.js';\nimport { destroyWorklet } from '../worklet/destroy.js';\nimport { clearJSReadyEventIdSwap, isJSReady } from './event/jsReady.js';\nimport { increaseReloadVersion } from './pass.js';\nimport { deinitGlobalSnapshotPatch } from './patch/snapshotPatch.js';\nimport { renderBackground, renderMainThread } from './render.js';\nfunction reloadMainThread(data, options) {\n    if (__PROFILE__) {\n        console.profile('reloadTemplate');\n    }\n    increaseReloadVersion();\n    if (typeof data == 'object' && !isEmptyObject(data)) {\n        Object.assign(lynx.__initData, data);\n    }\n    destroyWorklet();\n    snapshotInstanceManager.clear();\n    __pendingListUpdates.clear();\n    clearJSReadyEventIdSwap();\n    const oldRoot = __root;\n    setRoot(new SnapshotInstance('root'));\n    __root.__jsx = oldRoot.__jsx;\n    renderMainThread();\n    hydrate(oldRoot, __root, {\n        skipUnRef: true,\n    });\n    // always call this before `__FlushElementTree`\n    __pendingListUpdates.flush();\n    if (isJSReady) {\n        __OnLifecycleEvent([\n            LifecycleConstant.firstScreen, /* FIRST_SCREEN */\n            {\n                root: JSON.stringify(__root),\n                refPatch: JSON.stringify(takeGlobalRefPatchMap()),\n            },\n        ]);\n    }\n    __FlushElementTree(__page, options);\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n    return;\n}\nfunction reloadBackground(updateData) {\n    if (__PROFILE__) {\n        console.profile('reload');\n    }\n    deinitGlobalSnapshotPatch();\n    destroyBackground();\n    increaseReloadVersion();\n    // COW when modify `lynx.__initData` to make sure Provider & Consumer works\n    lynx.__initData = Object.assign({}, lynx.__initData, updateData);\n    renderBackground(__root.__jsx, __root);\n    if (__PROFILE__) {\n        console.profileEnd();\n    }\n}\nexport { reloadBackground, reloadMainThread };\n//# sourceMappingURL=reload.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { __pendingListUpdates, componentAtIndexFactory, enqueueComponentFactory } from './list.js';\nimport { unref } from './snapshot/ref.js';\nimport { DynamicPartType, SnapshotInstance } from './snapshot.js';\nimport { isEmptyObject } from './utils.js';\nexport function isEmptyDiffResult(diffResult) {\n    const hasChanged = !isEmptyObject(diffResult.i)\n        || !isEmptyObject(diffResult.m) || diffResult.r.length > 0;\n    return !hasChanged;\n}\nexport function diffArrayLepus(before, after, isSameType, onDiffChildren) {\n    let lastPlacedIndex = 0;\n    const result = {\n        $$diff: true,\n        i: {},\n        r: [],\n        m: {},\n    };\n    const beforeMap = {};\n    for (let i = 0; i < before.length; i++) {\n        const node = before[i];\n        (beforeMap[node.type] ??= new Set()).add([node, i]);\n    }\n    for (let i = 0; i < after.length; i++) {\n        const afterNode = after[i];\n        const beforeNodes = beforeMap[afterNode.type];\n        let beforeNode;\n        if (beforeNodes\n            && beforeNodes.size > 0\n            // @ts-expect-error TS does not know about iterator :)\n            && (([beforeNode] = beforeNodes), beforeNode)\n            && isSameType(beforeNode[0], afterNode)) {\n            // Reuse old node\n            beforeNodes.delete(beforeNode);\n            const oldIndex = beforeNode[1];\n            onDiffChildren(beforeNode[0], afterNode, oldIndex, i);\n            if (oldIndex < lastPlacedIndex) {\n                result.m[oldIndex] = i;\n                continue;\n            }\n            else {\n                lastPlacedIndex = oldIndex;\n            }\n        }\n        else {\n            // Create new node\n            result.i[i] = afterNode;\n        }\n    }\n    // Delete\n    for (const k in beforeMap) {\n        for (const [, i] of beforeMap[k]) {\n            result.r.push(i);\n        }\n    }\n    return result;\n}\n// export function diffIterableLepus<A extends Typed, B extends Typed>(\n//   before: A[],\n//   after: Iterable<B>,\n//   isSameType: (a: A, b: B) => boolean,\n//   onDiffChildren: (a: A, b: B) => void\n// ): DiffResult<B> {\n//   let returnResult = EMPTY_DIFF_RESULT as DiffResult<B>;\n//   let lastPlacedIndex = 0;\n//   const result: DiffResult<B> = {\n//     $$diff: true,\n//     i: {},\n//     r: [],\n//     m: {},\n//   };\n//   const beforeMap: Record<string, Set<[A, number]>> = {};\n//   for (let i = 0; i < before.length; i++) {\n//     let node = before[i];\n//     (beforeMap[node.type] ??= new Set()).add([node, i]);\n//   }\n//   let i = 0;\n//   for (const afterNode of after) {\n//     const beforeNodes = beforeMap[afterNode.type];\n//     let beforeNode: [A, number];\n//     if (beforeNodes && (([beforeNode] = beforeNodes), beforeNode) && isSameType(beforeNode[0], afterNode)) {\n//       // Reuse old node\n//       beforeNodes.delete(beforeNode);\n//       const oldIndex = beforeNode[1];\n//       onDiffChildren(beforeNode[0], afterNode);\n//       if (oldIndex < lastPlacedIndex) {\n//         result.m[oldIndex] = i;\n//         returnResult = result;\n//         i++;\n//         continue;\n//       } else {\n//         lastPlacedIndex = oldIndex;\n//       }\n//     } else {\n//       // Create new node\n//       result.i[i] = afterNode;\n//       returnResult = result;\n//     }\n//     i++;\n//   }\n//   // delete\n//   for (const k in beforeMap) {\n//     for (const [, i] of beforeMap[k]) {\n//       result.r.push(i);\n//       returnResult = result;\n//     }\n//   }\n//   return result;\n// }\nexport function diffArrayAction(before, diffResult, onInsert, onRemove, onMove) {\n    if (isEmptyDiffResult(diffResult)) {\n        return before;\n    }\n    const deleteSet = new Set(diffResult.r);\n    const { i: insertMap, m: placementMap } = diffResult;\n    const moveTempMap = new Map();\n    let old;\n    let k = 0;\n    old = before[k];\n    // let current: T | null | undefined = null;\n    const result = [];\n    let i = 0; // index of the old list\n    let j = 0; // index of the new list\n    let remain = Object.keys(insertMap).length;\n    while (old || remain > 0) {\n        let keep = false;\n        if (old && deleteSet.has(j)) {\n            // delete\n            onRemove(old);\n        }\n        else if (old && placementMap[j] !== undefined) {\n            // save node to re-use\n            moveTempMap.set(placementMap[j], old);\n            remain++;\n        }\n        else {\n            // insert node\n            let newNode = old;\n            if (moveTempMap.has(i)) {\n                // insert re-used node\n                newNode = moveTempMap.get(i);\n                keep = true;\n                onMove(newNode, old);\n                remain--;\n            }\n            else if (insertMap[i] !== undefined) {\n                // insert new node\n                newNode = onInsert(insertMap[i], old);\n                keep = true;\n                remain--;\n            }\n            result.push(newNode);\n            i++;\n        }\n        if (old && !keep) {\n            old = before[++k];\n            j++;\n        }\n    }\n    return result;\n}\nexport function hydrate(before, after, options) {\n    after.__elements = before.__elements;\n    after.__element_root = before.__element_root;\n    if (!(options?.skipUnRef)) {\n        unref(before, false);\n    }\n    let swap;\n    if (swap = options?.swap) {\n        swap[before.__id] = after.__id;\n    }\n    after.__values?.forEach((value, index) => {\n        const old = before.__values[index];\n        if (value !== old) {\n            after.__values[index] = old;\n            after.setAttribute(index, value);\n        }\n    });\n    const { slot } = after.__snapshot_def;\n    if (!slot) {\n        return;\n    }\n    const beforeChildNodes = before.childNodes;\n    const afterChildNodes = after.childNodes;\n    slot.forEach(([type, elementIndex], index) => {\n        switch (type) {\n            case DynamicPartType.Slot:\n            case DynamicPartType.MultiChildren: {\n                // TODO: the following null assertions are not 100% safe\n                const v1 = beforeChildNodes[index];\n                const v2 = afterChildNodes[index];\n                hydrate(v1, v2, options);\n                break;\n            }\n            case DynamicPartType.Children: {\n                const diffResult = diffArrayLepus(beforeChildNodes, afterChildNodes, (a, b) => a.type === b.type, (a, b) => {\n                    hydrate(a, b, options);\n                });\n                diffArrayAction(beforeChildNodes, diffResult, (node, target) => {\n                    node.ensureElements();\n                    __InsertElementBefore(before.__elements[elementIndex], node.__element_root, target?.__element_root);\n                    return node;\n                }, node => {\n                    __RemoveElement(before.__elements[elementIndex], node.__element_root);\n                }, (node, target) => {\n                    __RemoveElement(before.__elements[elementIndex], node.__element_root);\n                    __InsertElementBefore(before.__elements[elementIndex], node.__element_root, target?.__element_root);\n                });\n                break;\n            }\n            case DynamicPartType.ListChildren: {\n                const removals = [];\n                const insertions = [];\n                const updateAction = [];\n                const diffResult = diffArrayLepus(beforeChildNodes, afterChildNodes, (a, b) => a.type === b.type, (a, b, oldIndex, newIndex) => {\n                    if (JSON.stringify(a.__listItemPlatformInfo)\n                        !== JSON.stringify(b.__listItemPlatformInfo)) {\n                        updateAction.push({\n                            ...b.__listItemPlatformInfo,\n                            from: newIndex,\n                            to: newIndex,\n                            // no flush\n                            flush: false,\n                        });\n                    }\n                    // Mark list-item which is rendered (has `__elements`) as DELETE\n                    // so list platform will call `enqueueComponent` on it\n                    // and will call `componentAtIndex` on the inserted one\n                    // In this way:\n                    //  1. we make sure `<list/>` for hydrate is like a leaf node\n                    //  2. we avoid hydrate so modifying recycleMap can be avoid\n                    //  3. the delete list-item is recycled for later use, so no waste\n                    if (a.__elements) {\n                        removals.push(oldIndex);\n                        insertions.push(newIndex);\n                    }\n                });\n                for (const i of diffResult.r) {\n                    removals.push(i);\n                }\n                for (const i in diffResult.i) {\n                    insertions.push(Number(i));\n                }\n                for (const i in diffResult.m) {\n                    removals.push(Number(i));\n                    insertions.push(diffResult.m[i]);\n                }\n                insertions.sort((a, b) => a - b);\n                removals.sort((a, b) => a - b);\n                const info = {\n                    insertAction: insertions.map((it) => ({\n                        position: it,\n                        type: afterChildNodes[it].type,\n                        ...afterChildNodes[it].__listItemPlatformInfo,\n                    })),\n                    removeAction: removals,\n                    updateAction,\n                };\n                const listElement = before.__elements[elementIndex];\n                __SetAttribute(listElement, 'update-list-info', info);\n                __UpdateListCallbacks(listElement, componentAtIndexFactory(afterChildNodes), enqueueComponentFactory());\n                // The `before` & `after` target to the same list element, so we need to\n                // avoid the newly created list's (behind snapshot instance `after`) \"update-list-info\" being recorded.\n                delete __pendingListUpdates.values[after.__id];\n            }\n        }\n    });\n}\n//# sourceMappingURL=hydrate.js.map","import { _ as _object_without_properties_loose } from \"./_object_without_properties_loose.js\";\n\nfunction _object_without_properties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _object_without_properties_loose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n\n    return target;\n}\nexport { _object_without_properties as _ };\n","function _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n\n    return target;\n}\nexport { _object_without_properties_loose as _ };\n","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { options } from 'preact';\n// to make sure preact's hooks to register earlier than ours\nimport './hooks/react.js';\nimport { initProfileHook } from './debug/profile.js';\nimport { document, setupBackgroundDocument } from './document.js';\nimport { initDelayUnmount } from './lifecycle/delayUnmount.js';\nimport { replaceCommitHook, replaceRequestAnimationFrame } from './lifecycle/patch/commit.js';\nimport { injectUpdateMainThread } from './lifecycle/patch/updateMainThread.js';\nimport { injectCalledByNative } from './lynx/calledByNative.js';\nimport { setupLynxEnv } from './lynx/env.js';\nimport { injectLepusMethods } from './lynx/injectLepusMethods.js';\nimport { initTimingAPI } from './lynx/performance.js';\nimport { injectTt } from './lynx/tt.js';\n// @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature\nif (__LEPUS__ && typeof globalThis.processEvalResult === 'undefined') {\n    // @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature\n    globalThis.processEvalResult = (result, schema) => {\n        return result?.(schema);\n    };\n}\nif (__LEPUS__) {\n    injectCalledByNative();\n    injectUpdateMainThread();\n    if (__DEV__) {\n        injectLepusMethods();\n    }\n}\n// TODO: replace this with __PROFILE__\nif (__PROFILE__) {\n    // We are profiling both main-thread and background.\n    initProfileHook();\n}\nif (__JS__) {\n    options.document = document;\n    setupBackgroundDocument();\n    injectTt();\n    if (process.env['NODE_ENV'] === 'test') { }\n    else {\n        replaceCommitHook();\n        replaceRequestAnimationFrame();\n        initTimingAPI();\n        initDelayUnmount();\n    }\n}\nsetupLynxEnv();\n//# sourceMappingURL=lynx.js.map","export function setupLynxEnv() {\n    if (!__LEPUS__) {\n        const { initData, updateData } = lynxCoreInject.tt._params;\n        // @ts-ignore\n        lynx.__initData = { ...initData, ...updateData };\n        lynx.registerDataProcessors = function () { };\n    }\n    if (__LEPUS__) {\n        // @ts-ignore\n        lynx.__initData = {\n        /* available only in renderPage */\n        };\n        // @ts-ignore\n        globalThis.SystemInfo = lynx.SystemInfo || {};\n        lynx.reportError = function (e) {\n            _ReportError(e, {\n                errorCode: 1101, // ErrCode::LYNX_ERROR_CODE_LEPUS in Lynx/base/debug/error_code.h\n            });\n        };\n        lynx.triggerGlobalEventFromLepus = function (eventName, params) {\n            __OnLifecycleEvent(['globalEventFromLepus', [eventName, params]]);\n        };\n        {\n            function __name(empty) {\n                return `Native${empty}Modules`;\n            }\n            // TODO(hongzhiyuan.hzy): make sure this is run before any other code (especially code access `NativeModules`)\n            // @ts-ignore\n            if (typeof globalThis[__name('')] === 'undefined') {\n                // @ts-ignore\n                globalThis[__name('')] = undefined;\n            }\n        }\n        lynx.registerDataProcessors = function (dataProcessorDefinition) {\n            let hasDefaultDataProcessorExecuted = false;\n            // @ts-ignore\n            globalThis.processData = (data, processorName) => {\n                if (__PROFILE__) {\n                    console.profile('processData');\n                }\n                let r;\n                try {\n                    if (processorName) {\n                        r = dataProcessorDefinition?.dataProcessors?.[processorName]?.(data)\n                            ?? data;\n                    }\n                    else {\n                        r = dataProcessorDefinition?.defaultDataProcessor?.(data) ?? data;\n                    }\n                }\n                catch (e) {\n                    lynx.reportError(e);\n                    // when there is an error\n                    // we should perform like dataProcessor returns nothing\n                    // so use `{}` rather than `data`\n                    r = {};\n                }\n                if (__PROFILE__) {\n                    console.profileEnd();\n                }\n                if (hasDefaultDataProcessorExecuted === false) {\n                    // @ts-ignore\n                    if (globalThis.__I18N_RESOURCE_TRANSLATION__) {\n                        r = {\n                            ...r,\n                            // @ts-ignore\n                            __I18N_RESOURCE_TRANSLATION__: globalThis.__I18N_RESOURCE_TRANSLATION__,\n                        };\n                    }\n                    // @ts-ignore\n                    if (__EXTRACT_STR__) {\n                        r = {\n                            ...r,\n                            // @ts-ignore\n                            _EXTRACT_STR: __EXTRACT_STR_IDENT_FLAG__,\n                        };\n                    }\n                }\n                if (processorName) { }\n                else {\n                    hasDefaultDataProcessorExecuted = true;\n                }\n                return r;\n                // TODO\n            };\n        };\n        // register empty DataProcessors to make sure `globalThis.processData` is set\n        lynx.registerDataProcessors();\n    }\n}\n//# sourceMappingURL=env.js.map","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { Component } from 'preact';\nimport { PerfSpecificKey, PerformanceTimingKeys, markTimingLegacy } from './performance.js';\nimport { globalFlushOptions } from '../lifecycle/patch/commit.js';\nimport { NEXT_STATE } from '../renderToOpcodes/constants.js';\nif (__JS__) {\n    const __Component = Component;\n    __Component.prototype._reactAppInstance = lynxCoreInject.tt;\n    __Component.prototype.getNodeRef = function (a, b) {\n        if (!__DISABLE_CREATE_SELECTOR_QUERY_INCOMPATIBLE_WARNING__) {\n            lynx.reportError(new Error('getNodeRef is deprecated and has different behavior in ReactLynx 3.0, please use ref or lynx.createSelectorQuery instead.'));\n        }\n        return lynxCoreInject.tt._reactLynx.ReactComponent.prototype.getNodeRef\n            .call({\n            _type: '',\n            _nativeApp: lynxCoreInject.tt._nativeApp,\n            _uiModule: lynxCoreInject.tt._nativeApp.nativeModuleProxy.LynxUIMethodModule,\n            _reactAppInstance: lynxCoreInject.tt,\n        }, a, b);\n    };\n    __Component.prototype.getNodeRefFromRoot = function (a) {\n        if (!__DISABLE_CREATE_SELECTOR_QUERY_INCOMPATIBLE_WARNING__) {\n            lynx.reportError(new Error('getNodeRefFromRoot is deprecated and has different behavior in ReactLynx 3.0, please use ref or lynx.createSelectorQuery instead.'));\n        }\n        return lynxCoreInject.tt._reactLynx.ReactComponent.prototype\n            .getNodeRefFromRoot.call({\n            _type: '',\n            _nativeApp: lynxCoreInject.tt._nativeApp,\n            _uiModule: lynxCoreInject.tt._nativeApp.nativeModuleProxy.LynxUIMethodModule,\n            _reactAppInstance: lynxCoreInject.tt,\n        }, a);\n    };\n    __Component.prototype.registerModule = function (name, module) {\n        this._reactAppInstance.registerModule(name, module);\n    };\n    __Component.prototype.getJSModule = function (name) {\n        return this._reactAppInstance.getJSModule(name);\n    };\n    __Component.prototype.addGlobalEventListener = function (eventName, callback, context) {\n        return this._reactAppInstance.getJSModule('GlobalEventEmitter').addListener(eventName, callback, context);\n    };\n    __Component.prototype.getElementById = function (id) {\n        if (!__DISABLE_CREATE_SELECTOR_QUERY_INCOMPATIBLE_WARNING__) {\n            lynx.reportError(new Error('getElementById on component instance is deprecated and has different behavior in ReactLynx 3.0, please use ref or lynx.getElementById instead.'));\n        }\n        return lynx.getElementById(id);\n    };\n    __Component.prototype.GlobalEventEmitter = lynxCoreInject.tt.GlobalEventEmitter;\n    __Component.prototype.createSelectorQuery = function () {\n        if (!__DISABLE_CREATE_SELECTOR_QUERY_INCOMPATIBLE_WARNING__) {\n            lynx.reportError(new Error('createSelectorQuery on component instance is deprecated and has different behavior in ReactLynx 3.0, please use ref or lynx.createSelectorQuery instead.'));\n        }\n        return lynx.createSelectorQuery();\n    };\n    const oldSetState = __Component.prototype.setState;\n    __Component.prototype.setState = function (state, callback) {\n        oldSetState.call(this, state, callback);\n        // @ts-ignore\n        const timingFlag = this[NEXT_STATE][PerfSpecificKey];\n        if (timingFlag) {\n            globalFlushOptions.__lynx_timing_flag = timingFlag;\n            markTimingLegacy(PerformanceTimingKeys.update_set_state_trigger, timingFlag);\n            this[NEXT_STATE][PerfSpecificKey] = '';\n        }\n    };\n}\n//# sourceMappingURL=component.js.map","import { Component, createElement, options, toChildArray, Fragment, render as render$1, hydrate as hydrate$1, createContext, createRef, cloneElement as cloneElement$1 } from 'preact';\nexport { Component, Fragment, createContext, createElement, createRef } from 'preact';\nimport { useCallback, useContext, useDebugValue, useEffect, useId, useImperativeHandle, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'preact/hooks';\nexport * from 'preact/hooks';\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nfunction assign(obj, props) {\n  for (var i in props) obj[i] = props[i];\n  return /** @type {O & P} */obj;\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nfunction shallowDiffers(a, b) {\n  for (var i in a) if (i !== '__source' && !(i in b)) return true;\n  for (var _i in b) if (_i !== '__source' && a[_i] !== b[_i]) return true;\n  return false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nfunction PureComponent(p, c) {\n  this.props = p;\n  this.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n  return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nfunction memo(c, comparer) {\n  function shouldUpdate(nextProps) {\n    var ref = this.props.ref;\n    var updateRef = ref == nextProps.ref;\n    if (!updateRef && ref) {\n      ref.call ? ref(null) : ref.current = null;\n    }\n    if (!comparer) {\n      return shallowDiffers(this.props, nextProps);\n    }\n    return !comparer(this.props, nextProps) || !updateRef;\n  }\n  function Memoed(props) {\n    this.shouldComponentUpdate = shouldUpdate;\n    return createElement(c, props);\n  }\n  Memoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n  Memoed.prototype.isReactComponent = true;\n  Memoed.__f = true;\n  return Memoed;\n}\n\nvar oldDiffHook = options.__b;\noptions.__b = function (vnode) {\n  if (vnode.type && vnode.type.__f && vnode.ref) {\n    vnode.props.ref = vnode.ref;\n    vnode.ref = null;\n  }\n  if (oldDiffHook) oldDiffHook(vnode);\n};\nvar REACT_FORWARD_SYMBOL = typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.forward_ref') || 0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nfunction forwardRef(fn) {\n  function Forwarded(props) {\n    var clone = assign({}, props);\n    delete clone.ref;\n    return fn(clone, props.ref || null);\n  }\n\n  // mobx-react checks for this being present\n  Forwarded.$$typeof = REACT_FORWARD_SYMBOL;\n  // mobx-react heavily relies on implementation details.\n  // It expects an object here with a `render` property,\n  // and prototype.render will fail. Without this\n  // mobx-react throws.\n  Forwarded.render = Forwarded;\n  Forwarded.prototype.isReactComponent = Forwarded.__f = true;\n  Forwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n  return Forwarded;\n}\n\nvar mapFn = function mapFn(children, fn) {\n  if (children == null) return null;\n  return toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nvar Children = {\n  map: mapFn,\n  forEach: mapFn,\n  count: function count(children) {\n    return children ? toChildArray(children).length : 0;\n  },\n  only: function only(children) {\n    var normalized = toChildArray(children);\n    if (normalized.length !== 1) throw 'Children.only';\n    return normalized[0];\n  },\n  toArray: toChildArray\n};\n\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nvar MODE_HYDRATE = 1 << 5;\n\nvar oldCatchError = options.__e;\noptions.__e = function (error, newVNode, oldVNode, errorInfo) {\n  if (error.then) {\n    /** @type {import('./internal').Component} */\n    var component;\n    var vnode = newVNode;\n    for (; vnode = vnode.__;) {\n      if ((component = vnode.__c) && component.__c) {\n        if (newVNode.__e == null) {\n          newVNode.__e = oldVNode.__e;\n          newVNode.__k = oldVNode.__k;\n        }\n        // Don't call oldCatchError if we found a Suspense\n        return component.__c(error, newVNode);\n      }\n    }\n  }\n  oldCatchError(error, newVNode, oldVNode, errorInfo);\n};\nvar oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n  /** @type {import('./internal').Component} */\n  var component = vnode.__c;\n  if (component && component.__R) {\n    component.__R();\n  }\n\n  // if the component is still hydrating\n  // most likely it is because the component is suspended\n  // we set the vnode.type as `null` so that it is not a typeof function\n  // so the unmount will remove the vnode._dom\n  if (component && vnode.__u & MODE_HYDRATE) {\n    vnode.type = null;\n  }\n  if (oldUnmount) oldUnmount(vnode);\n};\nfunction detachedClone(vnode, detachedParent, parentDom) {\n  if (vnode) {\n    if (vnode.__c && vnode.__c.__H) {\n      vnode.__c.__H.__.forEach(function (effect) {\n        if (typeof effect.__c == 'function') effect.__c();\n      });\n      vnode.__c.__H = null;\n    }\n    vnode = assign({}, vnode);\n    if (vnode.__c != null) {\n      if (vnode.__c.__P === parentDom) {\n        vnode.__c.__P = detachedParent;\n      }\n      vnode.__c = null;\n    }\n    vnode.__k = vnode.__k && vnode.__k.map(function (child) {\n      return detachedClone(child, detachedParent, parentDom);\n    });\n  }\n  return vnode;\n}\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n  if (vnode && originalParent) {\n    vnode.__v = null;\n    vnode.__k = vnode.__k && vnode.__k.map(function (child) {\n      return removeOriginal(child, detachedParent, originalParent);\n    });\n    if (vnode.__c) {\n      if (vnode.__c.__P === detachedParent) {\n        if (vnode.__e) {\n          originalParent.appendChild(vnode.__e);\n        }\n        vnode.__c.__e = true;\n        vnode.__c.__P = originalParent;\n      }\n    }\n  }\n  return vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nfunction Suspense() {\n  // we do not call super here to golf some bytes...\n  this.__u = 0;\n  this._suspenders = null;\n  this.__b = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype.__c = function (promise, suspendingVNode) {\n  var suspendingComponent = suspendingVNode.__c;\n\n  /** @type {import('./internal').SuspenseComponent} */\n  var c = this;\n  if (c._suspenders == null) {\n    c._suspenders = [];\n  }\n  c._suspenders.push(suspendingComponent);\n  var resolve = suspended(c.__v);\n  var resolved = false;\n  var onResolved = function onResolved() {\n    if (resolved) return;\n    resolved = true;\n    suspendingComponent.__R = null;\n    if (resolve) {\n      resolve(onSuspensionComplete);\n    } else {\n      onSuspensionComplete();\n    }\n  };\n  suspendingComponent.__R = onResolved;\n  var onSuspensionComplete = function onSuspensionComplete() {\n    if (! --c.__u) {\n      // If the suspension was during hydration we don't need to restore the\n      // suspended children into the _children array\n      if (c.state.__a) {\n        var suspendedVNode = c.state.__a;\n        c.__v.__k[0] = removeOriginal(suspendedVNode, suspendedVNode.__c.__P, suspendedVNode.__c.__O);\n      }\n      c.setState({\n        __a: c.__b = null\n      });\n      var _suspended;\n      while (_suspended = c._suspenders.pop()) {\n        _suspended.forceUpdate();\n      }\n    }\n  };\n\n  /**\n   * We do not set `suspended: true` during hydration because we want the actual markup\n   * to remain on screen and hydrate it when the suspense actually gets resolved.\n   * While in non-hydration cases the usual fallback -> component flow would occour.\n   */\n  if (!c.__u++ && !(suspendingVNode.__u & MODE_HYDRATE)) {\n    c.setState({\n      __a: c.__b = c.__v.__k[0]\n    });\n  }\n  promise.then(onResolved, onResolved);\n};\nSuspense.prototype.componentWillUnmount = function () {\n  this._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n  if (this.__b) {\n    // When the Suspense's _vnode was created by a call to createVNode\n    // (i.e. due to a setState further up in the tree)\n    // it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n    if (this.__v.__k) {\n      var detachedParent = options.document.createElement('div');\n      var detachedComponent = this.__v.__k[0].__c;\n      this.__v.__k[0] = detachedClone(this.__b, detachedParent, detachedComponent.__O = detachedComponent.__P);\n    }\n    this.__b = null;\n  }\n\n  // Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n  /** @type {import('./internal').VNode} */\n  var fallback = state.__a && createElement(Fragment, null, props.fallback);\n  if (fallback) fallback.__u &= ~MODE_HYDRATE;\n  return [createElement(Fragment, null, state.__a ? null : props.children), fallback];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nfunction suspended(vnode) {\n  /** @type {import('./internal').Component} */\n  var component = vnode.__.__c;\n  return component && component.__a && component.__a(vnode);\n}\nfunction lazy(loader) {\n  var prom;\n  var component;\n  var error;\n  function Lazy(props) {\n    if (!prom) {\n      prom = loader();\n      prom.then(function (exports) {\n        component = exports.default || exports;\n      }, function (e) {\n        error = e;\n      });\n    }\n    if (error) {\n      throw error;\n    }\n    if (!component) {\n      throw prom;\n    }\n    return createElement(component, props);\n  }\n  Lazy.displayName = 'Lazy';\n  Lazy.__f = true;\n  return Lazy;\n}\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nvar SUSPENDED_COUNT = 0;\nvar RESOLVED_COUNT = 1;\nvar NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nfunction SuspenseList() {\n  this._next = null;\n  this._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nvar resolve = function resolve(list, child, node) {\n  if (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n    // The number a child (or any of its descendants) has been suspended\n    // matches the number of times it's been resolved. Therefore we\n    // mark the child as completely resolved by deleting it from ._map.\n    // This is used to figure out when *all* children have been completely\n    // resolved when revealOrder is 'together'.\n    list._map.delete(child);\n  }\n\n  // If revealOrder is falsy then we can do an early exit, as the\n  // callbacks won't get queued in the node anyway.\n  // If revealOrder is 'together' then also do an early exit\n  // if all suspended descendants have not yet been resolved.\n  if (!list.props.revealOrder || list.props.revealOrder[0] === 't' && list._map.size) {\n    return;\n  }\n\n  // Walk the currently suspended children in order, calling their\n  // stored callbacks on the way. Stop if we encounter a child that\n  // has not been completely resolved yet.\n  node = list._next;\n  while (node) {\n    while (node.length > 3) {\n      node.pop()();\n    }\n    if (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n      break;\n    }\n    list._next = node = node[NEXT_NODE];\n  }\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\nSuspenseList.prototype.__a = function (child) {\n  var list = this;\n  var delegated = suspended(list.__v);\n  var node = list._map.get(child);\n  node[SUSPENDED_COUNT]++;\n  return function (unsuspend) {\n    var wrappedUnsuspend = function wrappedUnsuspend() {\n      if (!list.props.revealOrder) {\n        // Special case the undefined (falsy) revealOrder, as there\n        // is no need to coordinate a specific order or unsuspends.\n        unsuspend();\n      } else {\n        node.push(unsuspend);\n        resolve(list, child, node);\n      }\n    };\n    if (delegated) {\n      delegated(wrappedUnsuspend);\n    } else {\n      wrappedUnsuspend();\n    }\n  };\n};\nSuspenseList.prototype.render = function (props) {\n  this._next = null;\n  this._map = new Map();\n  var children = toChildArray(props.children);\n  if (props.revealOrder && props.revealOrder[0] === 'b') {\n    // If order === 'backwards' (or, well, anything starting with a 'b')\n    // then flip the child list around so that the last child will be\n    // the first in the linked list.\n    children.reverse();\n  }\n  // Build the linked list. Iterate through the children in reverse order\n  // so that `_next` points to the first linked list node to be resolved.\n  for (var i = children.length; i--;) {\n    // Create a new linked list node as an array of form:\n    // \t[suspended_count, resolved_count, next_node]\n    // where suspended_count and resolved_count are numeric counters for\n    // keeping track how many times a node has been suspended and resolved.\n    //\n    // Note that suspended_count starts from 1 instead of 0, so we can block\n    // processing callbacks until componentDidMount has been called. In a sense\n    // node is suspended at least until componentDidMount gets called!\n    //\n    // Pending callbacks are added to the end of the node:\n    // \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n    this._map.set(children[i], this._next = [1, 0, this._next]);\n  }\n  return props.children;\n};\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function () {\n  var _this = this;\n  // Iterate through all children after mounting for two reasons:\n  // 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n  //    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n  //    The nodes can now be completely consumed from the linked list.\n  // 2. Handle nodes that might have gotten resolved between render and\n  //    componentDidMount.\n  this._map.forEach(function (node, child) {\n    resolve(_this, child, node);\n  });\n};\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n  this.getChildContext = function () {\n    return props.context;\n  };\n  return props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n  var _this = this;\n  var container = props._container;\n  _this.componentWillUnmount = function () {\n    render$1(null, _this._temp);\n    _this._temp = null;\n    _this._container = null;\n  };\n\n  // When we change container we should clear our old container and\n  // indicate a new mount.\n  if (_this._container && _this._container !== container) {\n    _this.componentWillUnmount();\n  }\n  if (!_this._temp) {\n    _this._container = container;\n\n    // Create a fake DOM parent node that manages a subset of `container`'s children:\n    _this._temp = {\n      nodeType: 1,\n      parentNode: container,\n      childNodes: [],\n      contains: function contains() {\n        return true;\n      },\n      appendChild: function appendChild(child) {\n        this.childNodes.push(child);\n        _this._container.appendChild(child);\n      },\n      insertBefore: function insertBefore(child, before) {\n        this.childNodes.push(child);\n        _this._container.appendChild(child);\n      },\n      removeChild: function removeChild(child) {\n        this.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n        _this._container.removeChild(child);\n      }\n    };\n  }\n\n  // Render our wrapping element into temp.\n  render$1(createElement(ContextProvider, {\n    context: _this.context\n  }, props.__v), _this._temp);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nfunction createPortal(vnode, container) {\n  var el = createElement(Portal, {\n    __v: vnode,\n    _container: container\n  });\n  el.containerInfo = container;\n  return el;\n}\n\nvar REACT_ELEMENT_TYPE = typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\nvar oldVNodeHook = options.vnode;\noptions.vnode = function (vnode) {\n  vnode.$$typeof = REACT_ELEMENT_TYPE;\n  if (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n['componentWillMount', 'componentWillReceiveProps', 'componentWillUpdate'].forEach(function (key) {\n  Object.defineProperty(Component.prototype, key, {\n    configurable: true,\n    get: function get() {\n      return this['UNSAFE_' + key];\n    },\n    set: function set(v) {\n      Object.defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        value: v\n      });\n    }\n  });\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nfunction render(vnode, parent, callback) {\n  // React destroys any existing DOM nodes, see #1727\n  // ...but only on the first render, see #1828\n  if (parent.__k == null) {\n    parent.textContent = '';\n  }\n  render$1(vnode, parent);\n  if (typeof callback == 'function') callback();\n  return vnode ? vnode.__c : null;\n}\nfunction hydrate(vnode, parent, callback) {\n  hydrate$1(vnode, parent);\n  if (typeof callback == 'function') callback();\n  return vnode ? vnode.__c : null;\n}\nvar oldEventHook = options.event;\noptions.event = function (e) {\n  if (oldEventHook) e = oldEventHook(e);\n  e.persist = empty;\n  e.isPropagationStopped = isPropagationStopped;\n  e.isDefaultPrevented = isDefaultPrevented;\n  return e.nativeEvent = e;\n};\nfunction empty() {}\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nvar __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n  ReactCurrentDispatcher: {\n    current: {\n      useCallback: useCallback,\n      useContext: useContext,\n      useDebugValue: useDebugValue,\n      useDeferredValue: useDeferredValue,\n      useEffect: useEffect,\n      useId: useId,\n      useImperativeHandle: useImperativeHandle,\n      useInsertionEffect: useInsertionEffect,\n      useLayoutEffect: useLayoutEffect,\n      useMemo: useMemo,\n      // useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n      useReducer: useReducer,\n      useRef: useRef,\n      useState: useState,\n      useSyncExternalStore: useSyncExternalStore,\n      useTransition: useTransition\n    }\n  }\n};\n\nvar version = '18.3.1'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n  return createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n  return !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n  return isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n  return !!element && !!element.displayName && (typeof element.displayName === 'string' || element.displayName instanceof String) && element.displayName.startsWith('Memo(');\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n  if (!isValidElement(element)) return element;\n  return cloneElement$1.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n  if (container.__k) {\n    render$1(null, container);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n  return component && (component.base || component.nodeType === 1 && component) || null;\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nvar unstable_batchedUpdates = function unstable_batchedUpdates(callback, arg) {\n  return callback(arg);\n};\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nvar flushSync = function flushSync(callback, arg) {\n  return callback(arg);\n};\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nvar StrictMode = Fragment;\nfunction startTransition(cb) {\n  cb();\n}\nfunction useDeferredValue(val) {\n  return val;\n}\nfunction useTransition() {\n  return [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nvar useInsertionEffect = useLayoutEffect;\n\n// compat to react-is\nvar isElement = isValidElement;\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nfunction useSyncExternalStore(subscribe, getSnapshot) {\n  var value = getSnapshot();\n\n  /**\n   * @typedef {{ _instance: Store }} StoreRef\n   * @type {[StoreRef, (store: StoreRef) => void]}\n   */\n  var _useState = useState({\n      _instance: {\n        __: value,\n        _getSnapshot: getSnapshot\n      }\n    }),\n    _instance = _useState[0]._instance,\n    forceUpdate = _useState[1];\n  useLayoutEffect(function () {\n    _instance.__ = value;\n    _instance._getSnapshot = getSnapshot;\n    if (didSnapshotChange(_instance)) {\n      forceUpdate({\n        _instance: _instance\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    if (didSnapshotChange(_instance)) {\n      forceUpdate({\n        _instance: _instance\n      });\n    }\n    return subscribe(function () {\n      if (didSnapshotChange(_instance)) {\n        forceUpdate({\n          _instance: _instance\n        });\n      }\n    });\n  }, [subscribe]);\n  return value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n  var latestGetSnapshot = inst._getSnapshot;\n  var prevValue = inst.__;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\n// React copies the named exports to the default one.\nvar index = {\n  useState: useState,\n  useId: useId,\n  useReducer: useReducer,\n  useEffect: useEffect,\n  useLayoutEffect: useLayoutEffect,\n  useInsertionEffect: useInsertionEffect,\n  useTransition: useTransition,\n  useDeferredValue: useDeferredValue,\n  useSyncExternalStore: useSyncExternalStore,\n  startTransition: startTransition,\n  useRef: useRef,\n  useImperativeHandle: useImperativeHandle,\n  useMemo: useMemo,\n  useCallback: useCallback,\n  useContext: useContext,\n  useDebugValue: useDebugValue,\n  version: version,\n  Children: Children,\n  render: render,\n  hydrate: hydrate,\n  unmountComponentAtNode: unmountComponentAtNode,\n  createPortal: createPortal,\n  createElement: createElement,\n  createContext: createContext,\n  createFactory: createFactory,\n  cloneElement: cloneElement,\n  createRef: createRef,\n  Fragment: Fragment,\n  isValidElement: isValidElement,\n  isElement: isElement,\n  isFragment: isFragment,\n  isMemo: isMemo,\n  findDOMNode: findDOMNode,\n  Component: Component,\n  PureComponent: PureComponent,\n  memo: memo,\n  forwardRef: forwardRef,\n  flushSync: flushSync,\n  unstable_batchedUpdates: unstable_batchedUpdates,\n  StrictMode: StrictMode,\n  Suspense: Suspense,\n  SuspenseList: SuspenseList,\n  lazy: lazy,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\nexport { Children, PureComponent, StrictMode, Suspense, SuspenseList, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, cloneElement, createFactory, createPortal, index as default, findDOMNode, flushSync, forwardRef, hydrate, isElement, isFragment, isMemo, isValidElement, lazy, memo, render, startTransition, unmountComponentAtNode, unstable_batchedUpdates, useDeferredValue, useInsertionEffect, useSyncExternalStore, useTransition, version };\n//# sourceMappingURL=compat.module.js.map\n","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { Suspense, createElement, lazy } from 'preact/compat';\nimport './lynx.js';\nimport { factory as factory2 } from './compat/componentIs.js';\nimport { useMemo } from './hooks/react.js';\nimport { snapshotCreateList } from './list.js';\nimport { loadLazyBundle } from './lynx/lazy-bundle.js';\nimport { __root } from './root.js';\nimport { DynamicPartType, SnapshotInstance, __page, __pageId, createSnapshot, snapshotManager } from './snapshot.js';\nexport { __page, __pageId, __root };\nexport { SnapshotInstance, snapshotCreateList, createSnapshot, snapshotManager };\nexport const __DynamicPartSlot = DynamicPartType.Slot;\nexport const __DynamicPartMultiChildren = DynamicPartType.MultiChildren;\nexport const __DynamicPartChildren = DynamicPartType.Children;\nexport const __DynamicPartListChildren = DynamicPartType.ListChildren;\nexport const __DynamicPartChildren_0 = [[DynamicPartType.Children, 0]];\nexport { updateSpread } from './snapshot/spread.js';\nexport { updateEvent } from './snapshot/event.js';\nexport { updateRef, transformRef } from './snapshot/ref.js';\nexport { updateWorkletEvent } from './snapshot/workletEvent.js';\nexport { updateWorkletRef } from './snapshot/workletRef.js';\nexport { updateGesture } from './snapshot/gesture.js';\nexport { updateListItemPlatformInfo } from './snapshot/platformInfo.js';\nexport { options, \n// Component is not an internal API, but refresh needs it from 'react/internal'\nComponent, } from 'preact';\nexport { loadDynamicJS, __dynamicImport } from './lynx/dynamic-js.js';\nexport { withInitDataInState } from './compat/initData.js';\nexport { wrapWithLynxComponent } from './compat/lynxComponent.js';\n/**\n * @internal a polyfill for <component is=? />\n */\nexport const __ComponentIsPolyfill = /* @__PURE__ */ factory2(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n{ Suspense, lazy, createElement, useMemo }, loadLazyBundle);\nexport { loadLazyBundle } from './lynx/lazy-bundle.js';\nexport { transformToWorklet } from './worklet/transformToWorklet.js';\nexport { registerWorkletOnBackground } from './worklet/hmr.js';\nexport { loadWorkletRuntime } from '@lynx-js/react/worklet-runtime/bindings';\n//# sourceMappingURL=internal.js.map","import { useCallback } from '@lynx-js/react'\n\nimport './App.css'\nimport arrow from './assets/arrow.png'\nimport reactLynxLogo from './assets/react-logo.png'\n\nif (__BACKGROUND__) {\n  const app = (lynx as any).getApp()\n  const originalHandleError = app.handleError;\n  app.handleError = function(error: Error, originError?: Error, errorLevel?: any) {\n    console.log('error received in handleError: ', error, originError, errorLevel)\n    originalHandleError.call(app, error, originError, errorLevel)\n  }\n}\n\nexport function App() {\n  const onTap = useCallback(() => {\n    throw new Error('test error')\n  }, [])\n  return (\n    <view>\n      <view className='Background' />\n      <view className='App'>\n        <view className='Banner'>\n          <view className='Logo' bindtap={onTap}>\n            <image src={reactLynxLogo} className='Logo--react' />\n          </view>\n          <text className='Title'>React</text>\n          <text className='Subtitle'>on Lynx</text>\n        </view>\n        <view className='Content'>\n          <image src={arrow} className='Arrow' />\n          <Button text=\"Send exception\" onTap={onTap} />\n        </view>\n        <view style={{ flex: 1 }}></view>\n      </view>\n    </view>\n  )\n}\n\nexport function Button({ text, onTap }: { text: string, onTap: () => void }) {\n  return (\n    <view className=\"button\" bindtap={onTap}>\n      <text>{text}</text>\n    </view>\n  );\n}","import { root } from '@lynx-js/react';\nimport * as Sentry from \"@sentry/browser\";\nimport { App } from './App.js';\n\n// Create a wrapper around lynx.fetch to match the expected fetch signature\nconst fetchWrapper = (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n  // Cast the result to Promise<Response> to satisfy TypeScript\n  return lynx.fetch(input as RequestInfo, init) as unknown as Promise<Response>;\n};\n\nif (__MAIN_THREAD__ && __BACKGROUND__) {\n// Use the wrapper instead of lynx.fetch directly\nSentry.WINDOW.fetch = fetchWrapper;\n\nSentry.init({\n  dsn: 'https://e85b375ffb9f43cf8bdf9787768149e0@o447951.ingest.sentry.io/5428562',\n  integrations: [Sentry.rewriteFramesIntegration({\n    iteratee: (frame) => {\n      frame.filename = '/test/main.lynx.bundle'\n      frame.abs_path = '/test/main.lynx.bundle'\n      return frame;\n    }\n  })],\n  defaultIntegrations: false,\n  debug: true,\n  release: 'rel124'\n});\n}\n\n\nroot.render(<App />);\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n}\n\n\n","// Copyright 2024 The Lynx Authors. All rights reserved.\n// Licensed under the Apache License Version 2.0 that can be found in the\n// LICENSE file in the root directory of this source tree.\nimport { createContext, createElement } from 'preact/compat';\nimport { useState } from 'preact/hooks';\nimport { factory, withInitDataInState } from './compat/initData.js';\nimport { useLynxGlobalEventListener } from './hooks/useLynxGlobalEventListener.js';\nimport { renderBackground } from './lifecycle/render.js';\nimport { LifecycleConstant } from './lifecycleConstant.js';\nimport { flushDelayedLifecycleEvents } from './lynx/tt.js';\nimport { __root } from './root.js';\n/**\n * The default and only root of ReactLynx for you to render JSX\n * @example\n * ```ts\n * import { root } from \"@lynx-js/react\"\n * ```\n *\n * @public\n */\nexport const root = {\n    render: (jsx) => {\n        if (__LEPUS__) {\n            __root.__jsx = jsx;\n        }\n        else {\n            __root.__jsx = jsx;\n            renderBackground(jsx, __root);\n            if (__FIRST_SCREEN_SYNC_TIMING__ === 'immediately') { }\n            else {\n                lynx.getNativeApp().callLepusMethod(LifecycleConstant.jsReady, {});\n            }\n            flushDelayedLifecycleEvents();\n        }\n    },\n    registerDataProcessors: (dataProcessorDefinition) => {\n        lynx.registerDataProcessors(dataProcessorDefinition);\n    },\n};\nconst _InitData = /* @__PURE__ */ factory({\n    createContext,\n    useState,\n    createElement,\n    useLynxGlobalEventListener,\n}, '__initData', 'onDataChanged');\n/**\n * The {@link https://react.dev/reference/react/createContext#provider | Provider} Component that provide `initData`,\n * you must wrap your JSX inside it\n * @group Components\n *\n * @example\n *\n * ```ts\n * import { root } from \"@lynx-js/react\"\n *\n * function App() {\n *   return (\n *     <InitDataConsumer children={(initData) => <view>...</view>}/>\n *   )\n * }\n *\n * root.render(\n *   <InitDataProvider>\n *      <App/>\n *   </InitDataProvider>\n * );\n *\n * ```\n *\n * @public\n */\nexport const InitDataProvider = /* @__PURE__ */ _InitData.Provider();\n/**\n * The {@link https://react.dev/reference/react/createContext#consumer | Consumer} Component that provide `initData`.\n * This should be used with {@link InitDataProvider}\n * @group Components\n * @public\n */\nexport const InitDataConsumer = /* @__PURE__ */ _InitData.Consumer();\n/**\n * A React Hooks for you to get `initData`.\n * If `initData` is changed, a re-render will be triggered automatically.\n *\n * @example\n *\n * ```ts\n * function App() {\n *   const initData = useInitData();\n *\n *   initData.someProperty // use it\n * }\n * ```\n *\n * @public\n */\nexport const useInitData = /* @__PURE__ */ _InitData.use();\n/**\n * A React Hooks for you to get notified when `initData` changed.\n *\n * @example\n * ```ts\n * function App() {\n *   useInitDataChanged((data) => {\n *     data.someProperty // can use it\n *   })\n * }\n * ```\n * @public\n */\nexport const useInitDataChanged = /* @__PURE__ */ _InitData.useChanged();\nexport { withInitDataInState };\nexport { runOnMainThread } from './worklet/runOnMainThread.js';\nexport { runOnBackground } from './worklet/runOnBackground.js';\nexport { MainThreadRef, useMainThreadRef } from './worklet/workletRef.js';\nexport { useLynxGlobalEventListener } from './hooks/useLynxGlobalEventListener.js';\n//# sourceMappingURL=lynx-api.js.map"],"names":["globalPipelineOptions","mtsEnabled","runOnBackgroundEnabled","execIdMap","delayedLifecycleEvents","delayedEvents","WorkletEvents","SnapshotOperation","NativeUpdateDataType","PerformanceTimingKeys","DynamicPartType","GestureTypeInner","Opcode","prevDebounce","currentIndex","currentComponent","previousComponent","prevRaf","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","isArray","Array","obj","props","i","removeNode","node","slice","error","vnode","oldVNode","errorInfo","component","ctor","handled","e","vnodeId","type","children","key","ref","normalizedProps","arguments","undefined","createVNode","original","BaseComponent","context","getDomSibling","childIndex","sibling","update","callback","s","enqueueRender","rerenderQueue","defer","Promise","setTimeout","c","process","a","b","renderQueueLength","renderComponent","oldDom","commitQueue","refQueue","newVNode","diff","commitRoot","updateParentDomPointers","child","diffChildren","parentDom","renderResult","newParentVNode","oldParentVNode","globalContext","namespace","excessDomChildren","isHydrating","childVNode","newDom","firstChildDom","oldChildren","newChildrenLength","constructNewChildrenArray","oldChildrenLength","remainingOldChildren","skew","String","skewedIndex","matchingIndex","findMatchingIndex","x","y","shouldSearch","parentVNode","skipRemove","r","applyRef","insert","setStyle","style","value","eventClock","setProperty","dom","name","oldValue","useCapture","o","eventProxyCapture","eventProxy","createEventProxy","eventHandler","isNew","oldProps","oldState","snapshot","clearProcessingException","tmp","newType","outer","newProps","isClassComponent","provider","componentContext","doRender","renderHook","count","_i","isTopLevelFragment","MODE_HYDRATE","diffElementNodes","newHtml","oldHtml","newChildren","inputValue","checked","nodeType","root","cb","hasRefUnmount","state","isStaticChildren","__source","__self","currentHook","afterPaintEffects","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldBeforeUnmount","flushAfterPaintEffects","invokeCleanup","invokeEffect","hooks","hookItem","newQueueLength","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","requestAnimationFrame","hasErrored","hook","comp","cleanup","takeGlobalSnapshotPatch","list","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","fn","self","args","err","target","source","ownKeys","Object","sym","PerfSpecificKey","shouldMarkDiffVdomStart","shouldMarkDiffVdomEnd","markTimingLegacy","timingFlag_","lynx","beginPipeline","needTimestamps","timingFlag","timestampKey","force","JSON","_","isSdkVersionGt","major","minor","version","lynxSdkVersion","SystemInfo","Number","initValuePatch","takeWorkletRefInitValuePatch","res","reloadVersion","globalFlushOptions","globalCommitTaskMap","Map","nextCommitTaskId","globalBackgroundSnapshotInstancesToRemove","patchesToCommit","flushOptions","patchList","commitPatchUpdate","patch","commitTask","patchOptions","object","enumerableOnly","keys","symbols","globalRefsToRemove","globalRefsToSet","nextRefId","updateBackgroundRefs","commitId","oldRefMap","newRefMap","sign","backgroundSnapshotInstanceManager","markRefToRemove","oldRefs","snapshotManager","ctx","id","newId","values","si","str","Error","expIndex","spreadKey","createSnapshot","uniqID","create","slot","cssId","entryName","noFlattenAttributes","Set","transformSpread","index","spread","result","hasNoFlattenAttributes","WorkletExecIdMap","worklet","execId","fnId","f","runJSFunction","event","data","returnValue","releaseBackgroundWorkletCtx","afterValue","processGestureBackground","gesture","subGesture","baseGesture","BackgroundSnapshotInstance","beforeNode","p","traverseSnapshotInstance","vv","v","nodes","oldValues","needUpdate","valueToCommit","length","newValue","oldSpread","newSpread","newSpreadValue","renderBackground","parent","replaceNode","commitToMainThread","destroyBackground","task","reloadBackground","updateData","lepusSide","refPatch","jsReadyEventIdSwap","before","snapshotPatch","after","helper2","afters","parentId","helper","old","beforeChildNodes","afterChildNodes","diffResult","diffArrayLepus","isSameType","onDiffChildren","lastPlacedIndex","beforeMap","afterNode","beforeNodes","oldIndex","k","diffArrayAction","onInsert","onRemove","onMove","deleteSet","insertMap","placementMap","moveTempMap","j","remain","keep","newNode","handlerName","idStr","rest","publishEvent","lynxCoreInject","publicComponentEvent","commitTaskId","eventName","params","_componentId","delayedPublishEvent","delayedPublicComponentEvent","updateGlobalProps","newData","runWithForce","m","WeakMap","oldDiff","oldDiffed","updateCardData","options","performanceTimingFlag","restNewData","excluded","_object_without_properties_loose","sourceKeys","sourceSymbolKeys","_ns","text","injectTt","tt","OnLifecycleEvent","replaceCommitHook","injectDebounceRendering","debounceRendering","_debounceRendering","oldCommit","commit","renderCallbacks","ret","delayedUnmounts","takeDelayedUnmounts","backgroundSnapshotInstancesToRemove","runDelayedUnmounts","wrapper","workletRefInitValuePatch","replaceRequestAnimationFrame","resolvedPromise","initTimingAPI","initDelayUnmount","oldUnmount","vnode_clone","unmount","parentVNode_","setupLynxEnv","initData","__Component","module","oldSetState","shallowDiffers","oldDiffHook","Symbol","oldCatchError","suspended","SuspenseList","promise","suspendingVNode","suspendingComponent","resolved","onResolved","onSuspensionComplete","_suspended","suspendedVNode","removeOriginal","detachedParent","originalParent","detachedComponent","detachedClone","effect","fallback","delegated","unsuspend","wrappedUnsuspend","out","_this","REACT_ELEMENT_TYPE","oldVNodeHook","oldEventHook","empty","isPropagationStopped","isDefaultPrevented","__DynamicPartChildren","app","originalHandleError","originError","errorLevel","console","Button","onTap","jsx","dataProcessorDefinition","factory","oldArgs","newArgs"],"mappings":"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"}